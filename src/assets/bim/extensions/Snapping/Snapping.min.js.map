{"version":3,"sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/external \"THREE\"","webpack://Autodesk.Extensions.[name]/(webpack)/buildin/global.js","webpack://Autodesk.Extensions.[name]/./extensions/Snapping/index.js","webpack://Autodesk.Extensions.[name]/./src/wgs/scene/VertexBufferReader.js","webpack://Autodesk.Extensions.[name]/./extensions/Snapping/Snapper.js","webpack://Autodesk.Extensions.[name]/./extensions/Snapping/SnapMath.js","webpack://Autodesk.Extensions.[name]/./extensions/Snapping/SnapperIndicator.js","webpack://Autodesk.Extensions.[name]/./src/compat.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","THREE","g","this","Function","e","window","av","Autodesk","Viewing","namespace","AutodeskNamespace","_export","prop","require","SnappingExtension","viewer","options","loadExtension","Extension","theExtensionManager","registerExtension","TAU","Math","PI","VertexBufferReader","geometry","vb","buffer","vbf","Float32Array","vbi","Int32Array","vbs","Uint16Array","ib","stride","vbstride","vcount","length","useInstancing","numInstances","useCompactBuffers","unpackXform","texData","tIdColor","image","data","Uint32Array","BoundsCallback","bounds","point","z","w","getDbIdAt","vindex","getColorAt","getVertexFlagsAt","getLayerIndexAt","getViewportIndexAt","decodeLineAt","layer","vpId","callback","onLineSegment","vertexOffset","x0","x","y0","y","angle","distAlong","max","lineWidth","baseOffset","x1","cos","y1","sin","decodeCircularArcAt","onCircularArc","cx","cy","start","end","radius","decodeEllipticalArcAt","onEllipticalArc","major","minor","tilt","decodeTexQuadAt","onTexQuad","centerX","centerY","rotation","width","height","decodeOneTriangleAt","onOneTriangle","x2","y2","x3","y3","decodeTriangleIndexed","vi0","vi1","vi2","enumGeomsForObject","dbId","geomType","layerId","visible","vi","enumGeomsForVisibleLayer","layerIdsVisible","enumGeoms","viewportId","indexOf","filter","onVertex","expandByPoint","halfWidth","halfHeight","rmtx","mtx","makeRotationZ","makeTranslation","multiply","applyMatrix4","MeasureCommon","EPSILON","SnapType","SnapResult","SNAP_PRECISION","isEqualWithPrecision","a","b","abs","isEqualVectorsWithPrecision","v1","v2","distancePointToLine","lineStart","lineEnd","distance","param","X0","Vector3","X1","subVectors","dot","distanceTo","cross","sqrt","SnapCandidateType","Unknown","Line","CircularArc","EllipticalArc","SnapCandidate","type","radiusX","radiusY","center","startAngle","endAngle","p1","p2","clone","CirularArc","other","optionalTarget","isLine","intersectLines","findIntersectionSnap","candidates","intersectPoint","snapRadius","sort","ca","cb","result","snapPoint","first","second","getIntersection","Vector2","Snapper","_snapResult","_viewer","setGlobalManager","globalManager","_names","_options","markupMode","_active","_distanceToEdge","Number","MAX_VALUE","_distanceToVertex","_isDragging","_isPressing","_isSnapped","_forcedVpId","_snapToPixel","indicator","SnapperIndicator","renderSnappedGeometry","renderSnappedTopology","detectRadiusInPixels","isMobileDevice","isActive","getNames","getName","getPriority","activate","deactivate","destroy","copyResults","destiny","copyTo","getEdge","geomEdge","getVertex","geomVertex","getGeometry","getGeometryType","getIntersectPoint","getSnapResult","isSnapped","clearSnapped","clear","setViewportId","setSnapToPixel","enable","snapping3D","snapNode","modelId","model","id","fragIds","face","fragId","undefined","hasTopology","snapping3DwithTopology","snapping3DtoMesh","getData","instanceTree","enumNodeFragments","push","geomFace","fi","mesh","impl","getRenderProxy","topoIndex","getTopoIndex","topology","getTopology","facesTopology","faces","edgesTopology","edges","faceSnappingWithTopology","normalMatrix","Matrix3","getNormalMatrix","matrixWorld","faceNormal","normal","applyMatrix3","normalize","edgeSnappingWithTopology","vertexSnappingWithTopology","setDetectRadius","forceSnapVertices","SNAP_VERTEX","forceSnapEdges","edgeIsCircle","circularArcCenter","circularArcRadius","vertices","SNAP_CIRCULARARC","edgeIsCurved","SNAP_CURVEDEDGE","SNAP_EDGE","faceIsCurved","SNAP_CURVEDFACE","SNAP_FACE","Face3","faceSnapping","applyMatrix","edgeSnapping","vertexSnapping","vA","vB","vC","geom","Geometry","attributes","index","positions","position","array","indexList","faceId","j","set","vIndex","indices","offsets","count","oi","Triangle","va","getTrianglesOnSameFace","isIncludeFace","vertexIndices","slice","vc","intersectFace","vCount","equals","k","trianglesSharedEdge","ci","splice","a1","a2","a3","b1","b2","b3","c1","c2","c3","minDistTopoIndex","edgeGeom","minDist","dist","lineGeom","isEdge_12","isEdge_13","isEdge_23","minDistIndex","getConnectedLineSegmentsOnSameLine","edgeVertices","V0","V1","edge","dist1","dist2","add","divideScalar","V2","fN1","vA1","fN2","vA2","angleVector2","vector","atan","GeometryCallback","snapper","aDetectRadius","circularArc","ellipticalArc","ellipticalArcCenter","vpIdLine","vpIdCircular","vpIdElliptical","detectRadius","snapCandidates","fromLine","sub","pointOnArc","nearestPointOnCircularArc","fromCircularArc","arc","CircleGeometry","Matrix4","major1","minor1","major2","minor2","equation1","equation2","rx","ry","numPoints","sampleEllipsePoint","createEllipticalArcGeometry","pop","nearestPoint","nearestVertexInVertexToEdge","makeEllipticalArc","snapping2D","Array","isArray","getFragmentList","gc","reverseMapDbId","finishSnapping2D","RASTER_PIXEL","snapping2DOverlay","meshes","snapping2DWithSegmentEnum","enumSegments","intersectSnap","viewportIndex2d","SNAP_INTERSECTION","lineStripToPieces","mid","addVectors","md","sd","ed","SNAP_CIRCLE_CENTER","snappingLeaflet","snapMidpoint","isMidpoint","midpoint","SNAP_MIDPOINT","setPerpendicular","isPerpendicular","navapi","navigation","camera","getCamera","getPosition","isPerspective","getEyeVector","fov","getVerticalFov","worldHeight","tan","degToRad","viewport","getScreenViewport","devicePixelRatio","getWindow","handleButtonDown","event","button","handleButtonUp","handleMouseMove","onMouseMove","canvasX","canvasY","handleSingleTap","handlePressHold","handleGesture","onMouseDown","mousePosition","snappingHitTest","vpVec","clientToViewport","intersectGroundViewport","GlobalManagerMixin","outResult","deltaAngle","normalizeAngle","trunc","angleInsideArc","outPoint","dir","copy","atan2","multiplyScalar","pStart","pEnd","startIsCloser","distanceToSquared","p3","p4","checkInsideSegment","epsilon","denom","ua","ub","isEqualVectors","NO_OVERLAY","GEOMETRIES_OVERLAY","INDICATOR_OVERLAY","_point","_indicatorColor","_geometryColor","overlayType","previewsIntersectPoint","createOverlayScene","geometryMaterial","MeshPhongMaterial","color","ambient","opacity","transparent","depthTest","depthWrite","side","DoubleSide","indicatorMaterial","MeshBasicMaterial","constructor","proto","render","snapResult","clearOverlay","isEmpty","renderGeometry","renderIndicator","removeOverlay","overlayName","removeOverlayScene","clearOverlays","addOverlay","drawFace","material","snapperPlane","Mesh","cylinderMesh","pointX","pointY","direction","orientation","lookAt","Object3D","up","cylinder","CylinderGeometry","drawPoint","drawLine","renderVertexIndicator","pos","getSnapResultPosition","setScale","rightVec","getCameraRightVector","upVec","getCameraUpVector","renderMidpointIndicator","renderEdgeIndicator","renderCircleIndicator","drawCircle","renderPerpendicular","renderPixelIndicator","is2d","setEdgeScale","isLeaflet","SphereGeometry","pointMesh","setPointScale","torus","TorusGeometry","torusMesh","setCircleScale","scale","updatePointScale","overlay","overlayScenes","scene","children","updateEdgeScale","onCameraChange","dispose","getGlobal","self","global","_window","_document","document","isBrowser","navigator","isIE11","userAgent","match","CustomEvent","params","bubbles","cancelable","detail","evt","createEvent","initCustomEvent","ArrayBuffer","byteLength","len","view","Uint8Array","out","log2","log","LN2","BlobBuilder","WebKitBlobBuilder","MozBlobBuilder","MSBlobBuilder","_isIOSDevice","test","toLowerCase","platform","maxTouchPoints","isIOSDevice","_isAndroidDevice","performance","Date","isInteger","isFinite","floor","String","repeat","pattern","valueOf","fill","lastIndexOf","searchElement","fromIndex","find","_this","item","assign","target","varArgs","TypeError","to","arguments","nextSource","nextKey","writable","configurable","HTMLCanvasElement","toBlob","quality","canvas","setTimeout","binStr","atob","toDataURL","split","arr","charCodeAt","Blob","begin","toString","_slice","size","cloned","upTo","min","charAt"],"mappings":";;;;;;;;;;;;;;;;;;yCACE,IAAIA,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAI,EAAQL,GAAUM,KAAKJ,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QA0Df,OArDAF,EAAoBQ,EAAIF,EAGxBN,EAAoBS,EAAIV,EAGxBC,EAAoBU,EAAI,SAASR,EAASS,EAAMC,GAC3CZ,EAAoBa,EAAEX,EAASS,IAClCG,OAAOC,eAAeb,EAASS,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEZ,EAAoBkB,EAAI,SAAShB,GACX,oBAAXiB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeb,EAASiB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,KAQvDrB,EAAoBsB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQrB,EAAoBqB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFA1B,EAAoBkB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOrB,EAAoBU,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRzB,EAAoB6B,EAAI,SAAS1B,GAChC,IAAIS,EAAST,GAAUA,EAAOqB,WAC7B,WAAwB,OAAOrB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBU,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRZ,EAAoBa,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG/B,EAAoBkC,EAAI,GAIjBlC,EAAoBA,EAAoBmC,EAAI,K,kBClFrDhC,EAAOD,QAAUkC,O,iBCAjB,IAAIC,EAGJA,EAAI,WACH,OAAOC,KADJ,GAIJ,IAECD,EAAIA,GAAK,IAAIE,SAAS,cAAb,GACR,MAAOC,GAEc,iBAAXC,SAAqBJ,EAAII,QAOrCtC,EAAOD,QAAUmC,G,2zBClBjB,IAAIK,EAAKC,SAASC,QAKdC,EAAYC,kBAAkB,wCAElC,SAASC,EAAQvC,EAAGiB,GAChB,IAAK,IAAIuB,KAAQxC,EACTA,EAAEyB,eAAee,KAEjB7C,EAAOD,QAAQ8C,GAAQxC,EAAEwC,GAGzBvB,EAAGuB,GAAQxC,EAAEwC,IAKzBD,EAAQE,EAAQ,IAAkBJ,GAClCE,EAAQE,EAAQ,KAAiBJ,GACjCE,EAAQE,EAAQ,IAA0BJ,G,IAgBpCK,E,YAMF,WAAYC,EAAQC,GAAS,O,4FAAC,CAAD,8BACnBD,EAAQC,I,8RAYd,OAAOd,KAAKa,OAAOE,cAAc,uB,+BAW1B,OAAO,I,iCAUL,OAAO,I,mCASL,OAAO,O,8BAjDMX,EAAGY,WAqDnCZ,EAAGa,oBAAoBC,kBAAkB,oBAAqBN,I,mECtF1DO,EAAgB,EAAVC,KAAKC,GAyBR,SAASC,EAAmBC,GAE/BvB,KAAKwB,GAAMD,EAASC,GAAGC,OACvBzB,KAAK0B,IAAM,IAAIC,aAAa3B,KAAKwB,IACjCxB,KAAK4B,IAAM,IAAIC,WAAW7B,KAAKwB,IAC/BxB,KAAK8B,IAAM,IAAIC,YAAY/B,KAAKwB,IAEhCxB,KAAKgC,GAAKT,EAASS,GAEnBhC,KAAKiC,OAASV,EAASW,SACvBlC,KAAKmC,OAASnC,KAAK0B,IAAIU,OAASpC,KAAKiC,OAErCjC,KAAKqC,cAAgBd,EAASe,aAAe,EAC7CtC,KAAKuC,kBAAoBhB,EAASiB,YAClCxC,KAAKyC,QAAUzC,KAAKuC,mBAAqBhB,EAASmB,UAAYnB,EAASmB,SAASC,OAASpB,EAASmB,SAASC,MAAMC,MAAQ,IAAIC,YAAYtB,EAASmB,SAASC,MAAMC,KAAKnB,QAmYnK,SAASqB,EAAeC,GAC3B/C,KAAK+C,OAASA,EAEd/C,KAAKgD,MAAQ,IAAIlD,UACjBE,KAAKgD,MAAMC,EAAI,EACfjD,KAAKgD,MAAME,EAAI,EArYnB5B,EAAmB5B,UAAUyD,UAAY,SAASC,GAC9C,OAAGpD,KAAKyC,QACGzC,KAAKyC,QAAQzC,KAAK8B,IAAIsB,EAAOpD,KAAKiC,OAAS,EA3BhC,IA6BfjC,KAAK4B,IAAIwB,EAAOpD,KAAKiC,OA7BN,IAgC1BX,EAAmB5B,UAAU2D,WAAa,SAASD,GAC/C,OAAGpD,KAAKyC,QACGzC,KAAKyC,QAAQzC,KAAK8B,IAAIsB,EAAOpD,KAAKiC,OAAS,EAnChC,IAqCfjC,KAAK4B,IAAIwB,EAAOpD,KAAKiC,OArCN,IAwC1BX,EAAmB5B,UAAU4D,iBAAmB,SAASF,GACrD,OAAGpD,KAAKyC,QACGzC,KAAK4B,IAAIwB,EAAOpD,KAAKiC,OAAS,GAElCjC,KAAK4B,IAAIwB,EAAOpD,KAAKiC,OA1CN,IA6C1BX,EAAmB5B,UAAU6D,gBAAkB,SAASH,GACpD,OAAGpD,KAAKyC,QACsC,MAAnCzC,KAAK4B,IAAIwB,EAAOpD,KAAKiC,OAAS,GAEmB,MAArDjC,KAAK4B,IAAIwB,EAAOpD,KAAKiC,OAhDN,IAmD1BX,EAAmB5B,UAAU8D,mBAAqB,SAASJ,GACvD,OAAGpD,KAAKyC,QACIzC,KAAK4B,IAAIwB,EAAOpD,KAAKiC,OAAS,IAAM,GAAM,MAE9CjC,KAAK4B,IAAIwB,EAAOpD,KAAKiC,OAvDP,IAuDwC,GAAM,OAGxEX,EAAmB5B,UAAU+D,aAAe,SAASL,EAAQM,EAAOC,EAAMC,GAEtE,GAAKA,EAASC,cAAd,CAEA,GAAG7D,KAAKuC,kBACJ,IAAIuB,EAAe9D,KAAKiC,OAASmB,EAAS,EACtCW,EAAe/D,KAAKuC,kBAAkByB,EAAIhE,KAAK8B,IAAIgC,GAAiB,MAAS9D,KAAKuC,kBAAkBU,EACpGgB,EAAejE,KAAKuC,kBAAkB2B,EAAIlE,KAAK8B,IAAIgC,EAAa,GAAM,MAAS9D,KAAKuC,kBAAkBW,EACtGiB,EAAenE,KAAK8B,IAAIgC,EAAa,GAAK,MAAS3C,EAAOC,KAAKC,GAC/D+C,EAAcpE,KAAK8B,IAAIgC,EAAa,GAAK,MAAS1C,KAAKiD,IAAIrE,KAAKuC,kBAAkByB,EAAGhE,KAAKuC,kBAAkB2B,GAC5GI,EAAgBtE,KAAK8B,IAAIgC,EAAa,GAAM,MAAS1C,KAAKiD,IAAIrE,KAAKuC,kBAAkByB,EAAGhE,KAAKuC,kBAAkB2B,GAAM,MAEzH,KAAIK,EAAavE,KAAKiC,OAASmB,EAC3BW,EAAa/D,KAAK0B,IAAI6C,GACtBN,EAAajE,KAAK0B,IAAI6C,EAAW,GACjCJ,EAAanE,KAAK0B,IAAI6C,EAAW,GAAKpD,EAAMC,KAAKC,GACjD+C,EAAapE,KAAK0B,IAAI6C,EAAW,GACjCD,EAAsC,EAAzBtE,KAAK0B,IAAI6C,EAAW,GAGzC,IAAIC,EAAKT,EAAKK,EAAYhD,KAAKqD,IAAIN,GAC/BO,EAAKT,EAAKG,EAAYhD,KAAKuD,IAAIR,GAEnCP,EAASC,cAAcE,EAAIE,EAAIO,EAAIE,EAAIf,EAAMW,KAGjDhD,EAAmB5B,UAAUkF,oBAAsB,SAASxB,EAAQM,EAAOC,EAAMC,GAE7E,GAAKA,EAASiB,cAAd,CAEA,GAAG7E,KAAKuC,kBACJ,IAAIuB,EAAe9D,KAAKiC,OAASmB,EAAS,EACtC0B,EAAe9E,KAAKuC,kBAAkByB,EAAIhE,KAAK8B,IAAIgC,GAAiB,MAAS9D,KAAKuC,kBAAkBU,EACpG8B,EAAe/E,KAAKuC,kBAAkB2B,EAAIlE,KAAK8B,IAAIgC,EAAa,GAAM,MAAS9D,KAAKuC,kBAAkBW,EACtG8B,EAAchF,KAAK8B,IAAIgC,EAAa,GAAK,MAAS3C,EAClD8D,EAAcjF,KAAK8B,IAAIgC,EAAa,GAAK,MAAS3C,EAClD+D,EAAclF,KAAK8B,IAAIgC,EAAa,GAAK,MAAS1C,KAAKiD,IAAIrE,KAAKuC,kBAAkByB,EAAGhE,KAAKuC,kBAAkB2B,OAEhH,KAAIK,EAAavE,KAAKiC,OAASmB,EAC3B0B,EAAa9E,KAAK0B,IAAI6C,GACtBQ,EAAa/E,KAAK0B,IAAI6C,EAAW,GACjCS,EAAahF,KAAK0B,IAAI6C,EAAW,GAAKpD,EACtC8D,EAAajF,KAAK0B,IAAI6C,EAAW,GAAKpD,EACtC+D,EAAalF,KAAK0B,IAAI6C,EAAW,GAGzCX,EAASiB,cAAcC,EAAIC,EAAIC,EAAOC,EAAKC,EAAQvB,KAGvDrC,EAAmB5B,UAAUyF,sBAAwB,SAAS/B,EAAQM,EAAOC,EAAMC,GAE/E,GAAKA,EAASwB,gBAAd,CAGA,IAAIb,EAAavE,KAAKiC,OAASmB,EAC3B0B,EAAa9E,KAAK0B,IAAI6C,GACtBQ,EAAa/E,KAAK0B,IAAI6C,EAAW,GACjCS,EAAahF,KAAK0B,IAAI6C,EAAW,GAAKpD,EACtC8D,EAAajF,KAAK0B,IAAI6C,EAAW,GAAKpD,EACtCkE,EAAarF,KAAK0B,IAAI6C,EAAW,GACjCe,EAAatF,KAAK0B,IAAI6C,EAAW,IACjCgB,EAAavF,KAAK0B,IAAI6C,EAAW,IAErCX,EAASwB,gBAAgBN,EAAIC,EAAIC,EAAOC,EAAKI,EAAOC,EAAOC,EAAM5B,KAGrErC,EAAmB5B,UAAU8F,gBAAkB,SAASpC,EAAQM,EAAOC,EAAMC,GAEzE,GAAKA,EAAS6B,UAAd,CAEA,GAAGzF,KAAKuC,kBACJ,IAAIuB,EAAe9D,KAAKiC,OAASmB,EAAS,EACtCsC,EAAe1F,KAAKuC,kBAAkByB,EAAIhE,KAAK8B,IAAIgC,GAAiB,MAAS9D,KAAKuC,kBAAkBU,EACpG0C,EAAe3F,KAAKuC,kBAAkB2B,EAAIlE,KAAK8B,IAAIgC,EAAa,GAAM,MAAS9D,KAAKuC,kBAAkBW,EACtG0C,EAAc5F,KAAK8B,IAAIgC,EAAa,GAAK,MAAS3C,EAClD0E,EAAc7F,KAAK8B,IAAIgC,EAAa,GAAK,MAAS1C,KAAKiD,IAAIrE,KAAKuC,kBAAkByB,EAAGhE,KAAKuC,kBAAkB2B,GAC5G4B,EAAc9F,KAAK8B,IAAIgC,EAAa,GAAK,MAAS1C,KAAKiD,IAAIrE,KAAKuC,kBAAkByB,EAAGhE,KAAKuC,kBAAkB2B,OAEhH,KAAIK,EAAavE,KAAKiC,OAASmB,EAC3BsC,EAAa1F,KAAK0B,IAAI6C,GACtBoB,EAAa3F,KAAK0B,IAAI6C,EAAW,GAEjCqB,EAAa5F,KAAK0B,IAAI6C,EAAW,GAAKpD,EACtC0E,EAAa7F,KAAK0B,IAAI6C,EAAW,GACjCuB,EAAa9F,KAAK0B,IAAI6C,EAAW,GAGzCX,EAAS6B,UAAUC,EAASC,EAASE,EAAOC,EAAQF,EAAUjC,KAGlErC,EAAmB5B,UAAUqG,oBAAsB,SAAS3C,EAAQM,EAAOC,EAAMC,GAE7E,GAAKA,EAASoC,cAAd,CAEA,GAAGhG,KAAKuC,kBACJ,IAAIuB,EAAe9D,KAAKiC,OAASmB,EAAS,EACtCoB,EAAexE,KAAKuC,kBAAkByB,EAAIhE,KAAK8B,IAAIgC,GAAiB,MAAS9D,KAAKuC,kBAAkBU,EACpGyB,EAAe1E,KAAKuC,kBAAkB2B,EAAIlE,KAAK8B,IAAIgC,EAAa,GAAM,MAAS9D,KAAKuC,kBAAkBW,EACtG+C,EAAejG,KAAKuC,kBAAkByB,EAAIhE,KAAK8B,IAAIgC,EAAa,GAAM,MAAS9D,KAAKuC,kBAAkBU,EACtGiD,EAAelG,KAAKuC,kBAAkB2B,EAAIlE,KAAK8B,IAAIgC,EAAa,GAAM,MAAS9D,KAAKuC,kBAAkBW,EACtGiD,EAAenG,KAAKuC,kBAAkByB,EAAIhE,KAAK8B,IAAIgC,EAAa,GAAM,MAAS9D,KAAKuC,kBAAkBU,EACtGmD,EAAepG,KAAKuC,kBAAkB2B,EAAIlE,KAAK8B,IAAIgC,EAAa,GAAM,MAAS9D,KAAKuC,kBAAkBW,MAE1G,KAAIqB,EAAavE,KAAKiC,OAASmB,EAC3BoB,EAAaxE,KAAK0B,IAAI6C,GACtBG,EAAa1E,KAAK0B,IAAI6C,EAAW,GACjC0B,EAAajG,KAAK0B,IAAI6C,EAAW,GACjC2B,EAAalG,KAAK0B,IAAI6C,EAAW,GACjC4B,EAAanG,KAAK0B,IAAI6C,EAAW,GACjC6B,EAAapG,KAAK0B,IAAI6C,EAAW,GAGzCX,EAASoC,cAAcxB,EAAIE,EAAIuB,EAAIC,EAAIC,EAAIC,EAAIzC,KAInDrC,EAAmB5B,UAAU2G,sBAAwB,SAASC,EAAKC,EAAKC,EAAK9C,EAAOC,EAAMC,GAEtF,GAAKA,EAASoC,cAAd,CAEA,GAAGhG,KAAKuC,kBAAmB,CACvB,IAAIuB,EAAe9D,KAAKiC,OAASqE,EAAM,EACnC9B,EAAexE,KAAKuC,kBAAkByB,EAAIhE,KAAK8B,IAAIgC,GAAiB,MAAS9D,KAAKuC,kBAAkBU,EACpGyB,EAAe1E,KAAKuC,kBAAkB2B,EAAIlE,KAAK8B,IAAIgC,EAAa,GAAM,MAAS9D,KAAKuC,kBAAkBW,EAE1GY,EAAiB9D,KAAKiC,OAASsE,EAAM,EACrC,IAAIN,EAAejG,KAAKuC,kBAAkByB,EAAIhE,KAAK8B,IAAIgC,GAAiB,MAAS9D,KAAKuC,kBAAkBU,EACpGiD,EAAelG,KAAKuC,kBAAkB2B,EAAIlE,KAAK8B,IAAIgC,EAAa,GAAM,MAAS9D,KAAKuC,kBAAkBW,EAE1GY,EAAiB9D,KAAKiC,OAASuE,EAAM,EACrC,IAAIL,EAAenG,KAAKuC,kBAAkByB,EAAIhE,KAAK8B,IAAIgC,GAAiB,MAAS9D,KAAKuC,kBAAkBU,EACpGmD,EAAepG,KAAKuC,kBAAkB2B,EAAIlE,KAAK8B,IAAIgC,EAAa,GAAM,MAAS9D,KAAKuC,kBAAkBW,MACvG,CACH,IAAIqB,EAAavE,KAAKiC,OAASqE,EAC3B9B,EAAaxE,KAAK0B,IAAI6C,GACtBG,EAAa1E,KAAK0B,IAAI6C,EAAW,GAErCA,EAAiBvE,KAAKiC,OAASsE,EAC3BN,EAAajG,KAAK0B,IAAI6C,GACtB2B,EAAalG,KAAK0B,IAAI6C,EAAW,GAErCA,EAAiBvE,KAAKiC,OAASuE,EAC3BL,EAAanG,KAAK0B,IAAI6C,GACtB6B,EAAapG,KAAK0B,IAAI6C,EAAW,GAGzCX,EAASoC,cAAcxB,EAAIE,EAAIuB,EAAIC,EAAIC,EAAIC,EAAIzC,KAKnDrC,EAAmB5B,UAAU+G,mBAAqB,SAASC,EAAM9C,GAE7D,GAAI5D,KAAKqC,cAML,IADA,IAAIvE,EAAI,EACDA,EAAIkC,KAAKmC,QAAQ,CACpB,IAGIwE,EAHO3G,KAAKsD,iBAAiBxF,IAGL,EAAK,IAE7B8I,EAAc5G,KAAKuD,gBAAgBzF,GACnC6F,EAAc3D,KAAKwD,mBAAmB1F,GAE1C,GADI+I,EAAc7G,KAAKmD,UAAUrF,KAAO4I,EAEpC,OAAQC,GACJ,KAnPU,EAmPuB3G,KAAKyD,aAAsB3F,EAAG8I,EAASjD,EAAMC,GAAW,MACzF,KAnPU,EAmPuB5D,KAAK4E,oBAAsB9G,EAAG8I,EAASjD,EAAMC,GAAW,MACzF,KAnPU,EAmPuB5D,KAAKmF,sBAAsBrH,EAAG8I,EAASjD,EAAMC,GAAW,MACzF,KAnPU,EAmPuB5D,KAAKwF,gBAAsB1H,EAAG8I,EAASjD,EAAMC,GAAW,MACzF,KAnPU,EAmPuB5D,KAAK+F,oBAAsBjI,EAAG8I,EAASjD,EAAMC,GAOtF9F,GAAK,OAKT,IADIA,EAAI,EACDA,EAAIkC,KAAKgC,GAAGI,QAAQ,CACvB,IAAI0E,EAAK9G,KAAKgC,GAAGlE,GASb+I,GALAF,EAHO3G,KAAKsD,iBAAiBwD,IAGL,EAAK,IAE7BF,EAAc5G,KAAKuD,gBAAgBuD,GACnCnD,EAAc3D,KAAKwD,mBAAmBsD,GAE5B9G,KAAKmD,UAAU2D,KAAQJ,GAErC,GAhRkB,IAgRdC,EAIIE,GACA7G,KAAKqG,sBAAsBrG,KAAKgC,GAAGlE,GAAIkC,KAAKgC,GAAGlE,EAAE,GAAIkC,KAAKgC,GAAGlE,EAAE,GAAI8I,EAASjD,EAAMC,GAItF9F,GAAK,MAEF,CAEH,GAAI+I,EACA,OAAQF,GACJ,KA9RM,EA8R2B3G,KAAKyD,aAAsBqD,EAAIF,EAASjD,EAAMC,GAAW,MAC1F,KA9RM,EA8R2B5D,KAAK4E,oBAAsBkC,EAAIF,EAASjD,EAAMC,GAAW,MAC1F,KA9RM,EA8R2B5D,KAAKmF,sBAAsB2B,EAAIF,EAASjD,EAAMC,GAAW,MAC1F,KA9RM,EA8R2B5D,KAAKwF,gBAAsBsB,EAAIF,EAASjD,EAAMC,GAAW,MAC1F,KA9RM,EA8R2B5D,KAAK+F,oBAAsBe,EAAIF,EAASjD,EAAMC,GAOvF9F,GAAK,KAgBrBwD,EAAmB5B,UAAUqH,yBAA2B,SAASC,EAAiBpD,GAK9E5D,KAAKiH,WAHQ,SAASP,EAAME,EAASM,GACjC,OAAQF,GAAgC,IAAZJ,IAAuD,IAAtCI,EAAgBG,QAAQP,KAElDhD,IAU3BtC,EAAmB5B,UAAUuH,UAAY,SAASG,EAAQxD,GAEtD,GAAI5D,KAAKqC,cAML,IADA,IAAIvE,EAAI,EACDA,EAAIkC,KAAKmC,QAAQ,CACpB,IAGIwE,EAHO3G,KAAKsD,iBAAiBxF,IAGL,EAAK,IAE7B8I,EAAc5G,KAAKuD,gBAAgBzF,GACnC6F,EAAc3D,KAAKwD,mBAAmB1F,GACtC4I,EAAc1G,KAAKmD,UAAUrF,GAKjC,GADI+I,GAAWO,GAAUA,EAAOV,EAAME,EAASjD,GAE3C,OAAQgD,GACJ,KA/VU,EA+VuB3G,KAAKyD,aAAsB3F,EAAG8I,EAASjD,EAAMC,GAAW,MACzF,KA/VU,EA+VuB5D,KAAK4E,oBAAsB9G,EAAG8I,EAASjD,EAAMC,GAAW,MACzF,KA/VU,EA+VuB5D,KAAKmF,sBAAsBrH,EAAG8I,EAASjD,EAAMC,GAAW,MACzF,KA/VU,EA+VuB5D,KAAKwF,gBAAsB1H,EAAG8I,EAASjD,EAAMC,GAAW,MACzF,KA/VU,EA+VuB5D,KAAK+F,oBAAsBjI,EAAG8I,EAASjD,EAAMC,GAOtF9F,GAAK,OAKT,IADIA,EAAI,EACDA,EAAIkC,KAAKgC,GAAGI,QAAQ,CACvB,IAAI0E,EAAK9G,KAAKgC,GAAGlE,GAYb+I,GARAF,EAHO3G,KAAKsD,iBAAiBwD,IAGL,EAAK,IAE7BF,EAAc5G,KAAKuD,gBAAgBuD,GACnCnD,EAAc3D,KAAKwD,mBAAmBsD,GACtCJ,EAAc1G,KAAKmD,UAAU2D,IAIlBM,GAAUA,EAAOV,EAAME,EAASjD,IAE/C,GA/XkB,IA+XdgD,EAIIE,GACA7G,KAAKqG,sBAAsBrG,KAAKgC,GAAGlE,GAAIkC,KAAKgC,GAAGlE,EAAE,GAAIkC,KAAKgC,GAAGlE,EAAE,GAAI8I,EAASjD,EAAMC,GAItF9F,GAAK,MAEF,CAEH,GAAI+I,EACA,OAAQF,GACJ,KA7YM,EA6Y2B3G,KAAKyD,aAAsBqD,EAAIF,EAASjD,EAAMC,GAAW,MAC1F,KA7YM,EA6Y2B5D,KAAK4E,oBAAsBkC,EAAIF,EAASjD,EAAMC,GAAW,MAC1F,KA7YM,EA6Y2B5D,KAAKmF,sBAAsB2B,EAAIF,EAASjD,EAAMC,GAAW,MAC1F,KA7YM,EA6Y2B5D,KAAKwF,gBAAsBsB,EAAIF,EAASjD,EAAMC,GAAW,MAC1F,KA7YM,EA6Y2B5D,KAAK+F,oBAAsBe,EAAIF,EAASjD,EAAMC,GAOvF9F,GAAK,KAsBrBgF,EAAepD,UAAU2H,SAAW,SAASvC,EAAIC,EAAIpB,GACjD3D,KAAKgD,MAAMgB,EAAIc,EACf9E,KAAKgD,MAAMkB,EAAIa,EACf/E,KAAK+C,OAAOuE,cAAetH,KAAKgD,QAGpCF,EAAepD,UAAUmE,cAAgB,SAASW,EAAIE,EAAIuB,EAAIC,EAAIvC,GAC9D3D,KAAKqH,SAAU7C,EAAIE,GACnB1E,KAAKqH,SAAUpB,EAAIC,IAGvBpD,EAAepD,UAAUmF,cAAgB,SAASC,EAAIC,EAAIC,EAAOC,EAAKC,EAAQvB,GAC1E3D,KAAKoF,gBAAgBN,EAAIC,EAAIC,EAAOC,EAAKC,EAAQA,EAAQ,EAAKvB,IAGlEb,EAAepD,UAAU0F,gBAAkB,SAASN,EAAIC,EAAIC,EAAOC,EAAKI,EAAOC,EAAOC,EAAM5B,GAC3E,GAAR4B,EAEKP,GAAS,GAAOC,GAAO,EAAM7D,KAAKC,GAAK,KAEzCrB,KAAKyF,UAAUX,EAAIC,EAAI,EAAEM,EAAO,EAAEC,EAAOC,EAAM5B,IAO/C3D,KAAKgD,MAAMgB,EAAIc,EAAK1D,KAAKqD,IAAIO,GAAOK,EACpCrF,KAAKgD,MAAMkB,EAAIa,EAAK3D,KAAKuD,IAAIK,GAAOM,EACpCtF,KAAK+C,OAAOuE,cAAetH,KAAKgD,OAChChD,KAAKgD,MAAMgB,EAAIc,EAAK1D,KAAKqD,IAAIQ,GAAKI,EAClCrF,KAAKgD,MAAMkB,EAAIa,EAAK3D,KAAKuD,IAAIM,GAAKK,EAClCtF,KAAK+C,OAAOuE,cAAetH,KAAKgD,OAG3BgC,EAAQC,IAETjF,KAAKgD,MAAMgB,EAAIc,EAAKO,EACpBrF,KAAKgD,MAAMkB,EAAIa,EACf/E,KAAK+C,OAAOuE,cAAetH,KAAKgD,OAEhCgC,GAAS,EAAM5D,KAAKC,IAEnB2D,EAAQ,GAAM5D,KAAKC,IAAM4D,EAAM,GAAM7D,KAAKC,KAE3CrB,KAAKgD,MAAMgB,EAAIc,EACf9E,KAAKgD,MAAMkB,EAAIa,EAAKO,EACpBtF,KAAK+C,OAAOuE,cAAetH,KAAKgD,QAE/BgC,EAAQ5D,KAAKC,IAAM4D,EAAM7D,KAAKC,KAE/BrB,KAAKgD,MAAMgB,EAAIc,EAAKO,EACpBrF,KAAKgD,MAAMkB,EAAIa,EACf/E,KAAK+C,OAAOuE,cAAetH,KAAKgD,QAE/BgC,EAAQ,IAAM5D,KAAKC,IAAM4D,EAAM,IAAM7D,KAAKC,KAE3CrB,KAAKgD,MAAMgB,EAAIc,EACf9E,KAAKgD,MAAMkB,EAAIa,EAAKO,EACpBtF,KAAK+C,OAAOuE,cAAetH,KAAKgD,SAUxChD,KAAKyF,UAAUX,EAAIC,EAAI,EAAEM,EAAO,EAAEC,EAAOC,EAAM5B,IAavDb,EAAepD,UAAU+F,UAAY,SAASC,EAASC,EAASE,EAAOC,EAAQF,EAAUjC,GACrF,IAAI4D,EAAY,GAAM1B,EAClB2B,EAAa,GAAM3B,EACvB,GAAgB,GAAZD,EACA5F,KAAKqH,SAAU3B,EAAU6B,EAAW5B,EAAU6B,GAC9CxH,KAAKqH,SAAU3B,EAAU6B,EAAW5B,EAAU6B,OAC3C,CAGH,IAAIC,EAAO,IAAI3H,UACX4H,EAAM,IAAI5H,UAGd2H,EAAKE,cAAc/B,GAEnB8B,EAAIE,gBAAgBlC,EAASC,EAAS,GACtC+B,EAAIG,SAASJ,GAEb,IAAK,IAAI3J,EAAI,EAAGA,EAAI,EAAGA,IACnBkC,KAAKgD,MAAMgB,EAAOlG,EAAE,GAAI,EAAGyJ,GAAWA,EACtCvH,KAAKgD,MAAMkB,EAAMpG,GAAG,EAAG0J,GAAYA,EACnCxH,KAAKgD,MAAM8E,aAAaJ,GACxB1H,KAAK+C,OAAOuE,cAAetH,KAAKgD,SAK5CF,EAAepD,UAAUsG,cAAgB,SAASxB,EAAIE,EAAIuB,EAAIC,EAAIC,EAAIC,EAAIzC,GACtE3D,KAAKqH,SAAU7C,EAAIE,GACnB1E,KAAKqH,SAAUpB,EAAIC,GACnBlG,KAAKqH,SAAUlB,EAAIC,I,0NCjiBvB,IAAM2B,EAAgB1H,SAASC,QAAQyH,cACjCC,EAAUD,EAAcC,QACxBC,EAAWF,EAAcE,SACzBC,EAAaH,EAAcG,WAE7BC,EAAiB,KAEf/H,EAAKC,SAASC,QAEpB,SAAS8H,EAAqBC,EAAGC,GAC7B,OAAOlH,KAAKmH,IAAIF,EAAIC,IAAMH,EAG9B,SAASK,EAA4BC,EAAIC,GACrC,OAAOtH,KAAKmH,IAAIE,EAAGzE,EAAI0E,EAAG1E,IAAMmE,GACzB/G,KAAKmH,IAAIE,EAAGvE,EAAIwE,EAAGxE,IAAMiE,GACzB/G,KAAKmH,IAAIE,EAAGxF,EAAIyF,EAAGzF,IAAMkF,EASpC,SAASQ,EAAoB3F,EAAO4F,EAAWC,GAE3C,IAEIC,EACAC,EAHAC,EAAK,IAAIlJ,MAAMmJ,QACfC,EAAK,IAAIpJ,MAAMmJ,QAyBnB,OArBAD,EAAGG,WAAWP,EAAW5F,GACzBkG,EAAGC,WAAWN,EAASD,GACvBG,EAAQC,EAAGI,IAAIF,GACfF,EAAGG,WAAWN,EAASD,IACvBG,GAASA,EAAQC,EAAGI,IAAIJ,IAEZ,EACRF,EAAW9F,EAAMqG,WAAWT,GAEvBG,EAAQ,EACbD,EAAW9F,EAAMqG,WAAWR,IAG5BG,EAAGG,WAAWnG,EAAO4F,GACrBM,EAAGC,WAAWnG,EAAO6F,GACrBG,EAAGM,MAAMJ,GACTA,EAAGC,WAAWN,EAASD,GAEvBE,EAAW1H,KAAKmI,KAAKP,EAAGI,IAAIJ,IAAO5H,KAAKmI,KAAKL,EAAGE,IAAIF,KAGjDJ,EAGX,IAAMU,EAAoB,CACtBC,QAAe,EACfC,KAAe,EACfC,YAAe,EACfC,cAAe,GAIbC,E,WACF,WAAY3C,EAAY4B,I,4FAAW,CAAD,QAE9B9I,KAAK8J,KAAON,EAAkBC,QAC9BzJ,KAAKkH,WAAaA,EAGlBlH,KAAK8I,SAAW,EAGhB9I,KAAK4I,UAAY,KACjB5I,KAAK6I,QAAY,KAGjB7I,KAAKkF,OAAS,EAGdlF,KAAK+J,QAAU,EACf/J,KAAKgK,QAAU,EAGfhK,KAAKiK,OAAS,KAGdjK,KAAKkK,WAAa,EAClBlK,KAAKmK,SAAa,E,wDAGbC,EAAIC,GAIT,OAHArK,KAAK8J,KAAON,EAAkBE,KAC9B1J,KAAK4I,UAAYwB,EAAGE,QACpBtK,KAAK6I,QAAYwB,EAAGC,QACbtK,O,sCAGKiK,EAAQ/E,EAAQF,EAAOC,GAMnC,OALAjF,KAAK8J,KAASN,EAAkBG,YAChC3J,KAAKiK,OAASA,EAAOK,QACrBtK,KAAKkF,OAASA,EACdlF,KAAKgF,MAASA,EACdhF,KAAKiF,IAASA,EACPjF,O,wCAGOiK,EAAQF,EAASC,EAAShF,EAAOC,GAO/C,OANAjF,KAAK8J,KAAON,EAAkBI,cAC9B5J,KAAKiK,OAASA,EAAOK,QACrBtK,KAAK+J,QAAUA,EACf/J,KAAKgK,QAAUA,EACfhK,KAAKgF,MAAQA,EACbhF,KAAKiF,IAAMA,EACJjF,O,+BAGS,OAAOA,KAAK8J,OAASN,EAAkBE,O,sCACvC,OAAO1J,KAAK8J,OAASN,EAAkBe,a,wCACvC,OAAOvK,KAAK8J,OAASN,EAAkBI,gB,sCAM3CY,EAAOC,GAEnB,GAAIzK,KAAK0K,UAAYF,EAAME,SAKvB,OAAOC,yBAAe3K,KAAK4I,UAAW5I,KAAK6I,QAAS2B,EAAM5B,UAAW4B,EAAM3B,SAAS,EAAO4B,Q,gCAgBjGG,EAAuB,SAACC,EAAYC,EAAgBC,GAUtD,GAHAF,EAAWG,MADQ,SAACC,EAAIC,GAAL,OAAYD,EAAGnC,SAAWoC,EAAGpC,YAI5C+B,EAAWzI,OAAS,EACpB,OAAO,KAeX,IAXA,IAAM+I,EAAS,CAEXjE,WAAY2D,EAAW,GAAG3D,WAI1BkE,UAAY,IAAItL,MAAMmJ,QAAQ,EAAG,EAAG6B,EAAe7H,IAIjDoI,EAAQR,EAAW,GAChB/M,EAAE,EAAGA,EAAE+M,EAAWzI,OAAQtE,IAAK,CACpC,IAAMwN,EAAST,EAAW/M,GAI1B,GADcuN,EAAME,gBAAgBD,EAAQH,EAAOC,WASnD,GADatL,MAAM0L,QAAQ9L,UAAU2J,WAAWpL,KAAKkN,EAAOC,UAAWN,GAC5DC,EAEP,OAAOI,EAGf,OAAO,MAWJ,SAASM,EAAQ5K,EAAQC,GAE5B,IAAI4K,EAAc,IAAIxD,EAElByD,EAAU9K,EACdb,KAAK4L,iBAAiB/K,EAAOgL,eAE7B,IACIC,EADAC,EAAWjL,GAAW,GAItBgL,EADAC,EAASC,WACA,CAAC,kBAED,CAAC,WAGd,IAEIC,GAAU,EAEVC,EAAkBC,OAAOC,UACzBC,EAAoB,KAEpBC,GAAc,EACdC,GAAc,EACdC,GAAa,EAEbC,EAAc,KAEdC,GAAe,EAEnB1M,KAAK2M,UAAY,IAAIC,mBAAiB/L,EAAQb,MAE9CA,KAAKgM,WAAaD,EAASC,WAC3BhM,KAAK6M,sBAAwBd,EAASc,sBACtC7M,KAAK8M,sBAAwBf,EAASe,sBAItC9M,KAAK+M,qBAAuBC,cAAmB,GAAK,GAOpDhN,KAAKiN,SAAW,WACZ,OAAOhB,GAGXjM,KAAKkN,SAAW,WACZ,OAAOpB,GAGX9L,KAAKmN,QAAU,WACX,OAAOrB,EAAO,IAGlB9L,KAAKoN,YAAc,WACf,OA3CY,IAoDhBpN,KAAKqN,SAAW,WACZpB,GAAU,EAELjM,KAAK2M,YACN3M,KAAK2M,UAAY,IAAIC,mBAAiB/L,EAAQb,QAWtDA,KAAKsN,WAAa,WACdrB,GAAU,EACVS,GAAe,EAEX1M,KAAK2M,YACL3M,KAAK2M,UAAUY,UACfvN,KAAK2M,UAAY,OAIzB3M,KAAKwN,YAAc,SAASC,GACxB/B,EAAYgC,OAAOD,IAGvBzN,KAAK2N,QAAU,WACX,OAAOjC,EAAYkC,UAGvB5N,KAAK6N,UAAY,WACb,OAAOnC,EAAYoC,YAGvB9N,KAAK+N,YAAc,WACf,OAAOrC,EAAYqC,eAGvB/N,KAAKgO,gBAAkB,WACnB,OAAOtC,EAAY/E,UAGvB3G,KAAKiO,kBAAoB,WACrB,OAAOvC,EAAYZ,gBASvB9K,KAAKkO,cAAgB,WACjB,OAAOxC,GAUX1L,KAAKmO,UAAY,WACb,OAAO3B,GAGXxM,KAAKoO,aAAe,WAChB1C,EAAY2C,QACZ7B,GAAa,GAGjBxM,KAAKsO,cAAgB,SAAS3K,GAC1B8I,EAAc9I,GAGlB3D,KAAKuO,eAAiB,SAASC,GAC3B9B,EAAe8B,GAOnBxO,KAAKyO,WAAa,SAAStD,GAOvB,GALAO,EAAYgD,SAAWvD,EAAOzE,KAC9BgF,EAAYZ,eAAiBK,EAAOL,eACpCY,EAAYiD,QAAUxD,EAAOyD,MAAQzD,EAAOyD,MAAMC,GAAK,KAGlD1D,EAAOyD,MAAZ,CAIA,IACIE,EADAC,EAAO5D,EAAO4D,KAMdD,EAHC3D,EAAO6D,aAAmCC,IAAzB9D,EAAO6D,OAAO5M,OAGtB+I,EAAO6D,OAFP,CAAC7D,EAAO6D,QAMtBtD,EAAYwD,YAAc/D,EAAOyD,MAAMM,cACnCxD,EAAYwD,YACZlP,KAAKmP,uBAAuBJ,EAAMD,EAAS3D,EAAOyD,OAEnD5O,KAAKoP,iBAAiBL,EAAMD,EAAS3D,EAAOyD,SAOnD5O,KAAKmP,uBAAyB,SAASJ,EAAMD,EAASF,GAG9ClD,EAAYgD,WACZI,EAAU,GAEVF,EAAMS,UAAUC,aAAaC,kBAAkB7D,EAAYgD,UAAU,SAASM,GAC1EF,EAAQU,KAAKR,MACd,IAGPtD,EAAY+D,SAAW/D,EAAYkC,SAAWlC,EAAYoC,WAAa,KACvE5B,EAAkBC,OAAOC,UAEzB,IAAK,IAAIsD,EAAK,EAAGA,EAAKZ,EAAQ1M,SAAUsN,EAAI,CAExC,IAAIV,EAASF,EAAQY,GACjBC,EAAOhE,EAAQiE,KAAKC,eAAejB,EAAOI,GAC1CzN,EAAWoO,EAAKpO,SAEhBuO,EAAYlB,EAAMmB,aAAaf,GAC/BgB,EAAWpB,EAAMqB,YAAYH,GAC7BI,EAAgBF,EAASG,MACzBC,EAAgBJ,EAASK,MAE7B,IAAK3E,EAAY+D,SAAU,CACvB/D,EAAY+D,SAAWzP,KAAKsQ,yBAAyBvB,EAAMxN,EAAU2O,EAAeP,GAEhFjE,EAAY+D,WACZ/D,EAAY+D,SAAST,OAASA,GAGlC,IAAIuB,GAAe,IAAIzQ,MAAM0Q,SAAUC,gBAAgBd,EAAKe,aAC5DhF,EAAYiF,WAAa5B,EAAK6B,OAAOC,aAAaN,GAAcO,YAKpE9Q,KAAK+Q,yBAAyBrF,EAAYZ,eAAgBvJ,EAAU6O,EAAeT,GAMvF,GAFAjE,EAAYoC,WAAa9N,KAAKgR,2BAA2BtF,EAAYkC,SAAUlC,EAAYZ,gBAEvFY,EAAY+D,SAAU,CAKtB,GAFA/D,EAAYxG,OAASlF,KAAKiR,gBAAgBvF,EAAYZ,iBAEjDiB,EAASmF,mBAAqB7E,EAAoBX,EAAYxG,SAAWwG,EAAYoC,WACtFpC,EAAY/E,SAAWsB,EAASkJ,iBAE/B,IAAKpF,EAASqF,gBAAkBlF,EAAkBR,EAAYxG,SAAWwG,EAAYkC,SAAU,CAEhG,IAAI3D,EAASjK,KAAKqR,aAAa3F,EAAYkC,UACvC3D,GACAyB,EAAY4F,kBAAoBrH,EAChCyB,EAAY6F,kBAAoBtH,EAAOZ,WAAWqC,EAAYkC,SAAS4D,SAAS,IAChF9F,EAAYkC,SAAS3D,OAASyB,EAAY4F,kBAC1C5F,EAAYkC,SAAS1I,OAASwG,EAAY6F,kBAC1C7F,EAAY/E,SAAWsB,EAASwJ,kBAE3BzR,KAAK0R,aAAahG,EAAYkC,UACnClC,EAAY/E,SAAWsB,EAAS0J,gBAGhCjG,EAAY/E,SAAWsB,EAAS2J,eAMhC5R,KAAK6R,aAAanG,EAAY+D,UAC9B/D,EAAY/E,SAAWsB,EAAS6J,gBAGhCpG,EAAY/E,SAAWsB,EAAS8J,UAKxCvF,GAAa,IAIrBxM,KAAKoP,iBAAmB,SAASL,EAAMD,EAASF,GAC3C,IAAK,IAAIc,EAAK,EAAGA,EAAKZ,EAAQ1M,SAAUsN,EAAI,CAEzC,IAAIV,EAASF,EAAQY,GACjBC,EAAOhE,EAAQiE,KAAKC,eAAejB,EAAOI,GAC1CzN,EAAWoO,EAAKpO,SAOpB,GAJIwN,aAAgBjP,MAAMkS,QACtBtG,EAAY+D,SAAWzP,KAAKiS,aAAalD,EAAMxN,IAG9CmK,EAAY+D,SAAjB,CAGA/D,EAAY+D,SAASyC,YAAYvC,EAAKe,aACtChF,EAAYkC,SAAW5N,KAAKmS,aAAazG,EAAY+D,SAAU/D,EAAYZ,gBAC3EY,EAAYoC,WAAa9N,KAAKoS,eAAe1G,EAAYkC,SAAUlC,EAAYZ,gBAE/E,IAAIyF,GAAe,IAAIzQ,MAAM0Q,SAAUC,gBAAgBd,EAAKe,aAC5DhF,EAAYiF,WAAa5B,EAAK6B,OAAOC,aAAaN,GAAcO,YAGhEpF,EAAYxG,OAASlF,KAAKiR,gBAAgBvF,EAAYZ,gBAEjDiB,EAASmF,mBAAsB7E,EAAoBX,EAAYxG,OAChEwG,EAAY/E,SAAWsB,EAASkJ,YAE3BpF,EAASqF,gBAAmBlF,EAAkBR,EAAYxG,OAC/DwG,EAAY/E,SAAWsB,EAAS2J,UAGhClG,EAAY/E,SAAWsB,EAAS8J,UAGpCvF,GAAa,EACb,SAIRxM,KAAKsQ,yBAA2B,SAASvB,EAAMxN,EAAU2O,EAAeP,GAEpE,IAAI0C,EAAK,IAAIvS,MAAMmJ,QACfqJ,EAAK,IAAIxS,MAAMmJ,QACfsJ,EAAK,IAAIzS,MAAMmJ,QAEfuJ,EAAO,IAAI1S,MAAM2S,SAEjBC,EAAanR,EAASmR,WAE1B,QAAyBzD,IAArByD,EAAWC,MAAqB,CAMhC,IAJA,IAAIC,EAAYrR,EAASC,GAAKD,EAASC,GAAKkR,EAAWG,SAASC,MAC5D7Q,EAASV,EAASC,GAAKD,EAASW,SAAW,EAGtCpE,EAAI,EAAGA,EAAIoS,EAAc9N,OAAQtE,IAAK,CAI3C,IAFA,IAAIiV,EAAY7C,EAAcpS,GAAGiV,UAC7BC,EAAS9C,EAAcpS,GAAG+Q,GACrBoE,EAAI,EAAGA,EAAIF,EAAU3Q,OAAQ6Q,GAAK,EAEvC,GAAIlE,EAAK1G,IAAM0K,EAAUE,IACrB,GAAKlE,EAAKzG,IAAMyK,EAAUE,EAAI,IAAMlE,EAAK5Q,IAAM4U,EAAUE,EAAI,IAAQlE,EAAKzG,IAAMyK,EAAUE,EAAI,IAAMlE,EAAK5Q,IAAM4U,EAAUE,EAAI,GACzH,WAGH,GAAIlE,EAAK1G,IAAM0K,EAAUE,EAAI,IAC9B,GAAKlE,EAAKzG,IAAMyK,EAAUE,IAAMlE,EAAK5Q,IAAM4U,EAAUE,EAAI,IAAQlE,EAAKzG,IAAMyK,EAAUE,EAAI,IAAMlE,EAAK5Q,IAAM4U,EAAUE,GACjH,WAGH,GAAIlE,EAAK1G,IAAM0K,EAAUE,EAAI,KACzBlE,EAAKzG,IAAMyK,EAAUE,IAAMlE,EAAK5Q,IAAM4U,EAAUE,EAAI,IAAQlE,EAAKzG,IAAMyK,EAAUE,EAAI,IAAMlE,EAAK5Q,IAAM4U,EAAUE,IACjH,MAKZ,GAAIA,EAAIF,EAAU3Q,OACd,MAIR,GAAItE,EAAIoS,EAAc9N,OAElB,IAAS6Q,EAAI,EAAGA,EAAIF,EAAU3Q,OAAQ6Q,GAAK,EAAG,CAC1CZ,EAAGa,IACCN,EAAWG,EAAUE,GAAKhR,GAC1B2Q,EAAWG,EAAUE,GAAKhR,EAAS,GACnC2Q,EAAWG,EAAUE,GAAKhR,EAAS,IAEvCqQ,EAAGY,IACCN,EAAWG,EAAUE,EAAI,GAAKhR,GAC9B2Q,EAAWG,EAAUE,EAAI,GAAKhR,EAAS,GACvC2Q,EAAWG,EAAUE,EAAI,GAAKhR,EAAS,IAE3CsQ,EAAGW,IACCN,EAAWG,EAAUE,EAAI,GAAKhR,GAC9B2Q,EAAWG,EAAUE,EAAI,GAAKhR,EAAS,GACvC2Q,EAAWG,EAAUE,EAAI,GAAKhR,EAAS,IAG3C,IAAIkR,EAASX,EAAKhB,SAASpP,OAE3BoQ,EAAKhB,SAAShC,KAAK6C,EAAG/H,SACtBkI,EAAKhB,SAAShC,KAAK8C,EAAGhI,SACtBkI,EAAKhB,SAAShC,KAAK+C,EAAGjI,SAEtBkI,EAAKrC,MAAMX,KAAK,IAAI1P,MAAMkS,MAAMmB,EAAQA,EAAS,EAAGA,EAAS,KAOzE,OAAIX,EAAKhB,SAASpP,OAAS,GAEvBoQ,EAAKQ,OAASA,EACdR,EAAKN,YAAYvC,EAAKe,aACf8B,GAIA,MAYfxS,KAAKiS,aAAe,SAASlD,EAAMxN,GAE/B,IAAI8Q,EAAK,IAAIvS,MAAMmJ,QACfqJ,EAAK,IAAIxS,MAAMmJ,QACfsJ,EAAK,IAAIzS,MAAMmJ,QAEfuJ,EAAO,IAAI1S,MAAM2S,SAIjBC,EAAanR,EAASmR,WAE1B,QAAyBzD,IAArByD,EAAWC,MAAqB,CAEhC,IAAIS,EAAUV,EAAWC,MAAMG,OAASvR,EAASS,GAC7C4Q,EAAYrR,EAASC,GAAKD,EAASC,GAAKkR,EAAWG,SAASC,MAC5D7Q,EAASV,EAASC,GAAKD,EAASW,SAAW,EAC3CmR,EAAU9R,EAAS8R,QAEjBA,GAA8B,IAAnBA,EAAQjR,SAErBiR,EAAU,CAAC,CAACrO,MAAO,EAAGsO,MAAOF,EAAQhR,OAAQuQ,MAAO,KAIxD,IAAK,IAAIY,EAAK,EAAGA,EAAKF,EAAQjR,SAAUmR,EAMpC,IAJA,IAAIvO,EAAQqO,EAAQE,GAAIvO,MACpBsO,EAAQD,EAAQE,GAAID,MACpBX,EAAQU,EAAQE,GAAIZ,MAEf7U,EAAIkH,EAAOlH,EAAIkH,EAAQsO,EAAOxV,GAAK,EAAG,CAE3C,IAAIuK,EAAIsK,EAAQS,EAAQtV,GACpBwK,EAAIqK,EAAQS,EAAQtV,EAAI,GACxBK,EAAIwU,EAAQS,EAAQtV,EAAI,GAE5BuU,EAAGa,IACCN,EAAUvK,EAAIpG,GACd2Q,EAAUvK,EAAIpG,EAAS,GACvB2Q,EAAUvK,EAAIpG,EAAS,IAE3BqQ,EAAGY,IACCN,EAAUtK,EAAIrG,GACd2Q,EAAUtK,EAAIrG,EAAS,GACvB2Q,EAAUtK,EAAIrG,EAAS,IAE3BsQ,EAAGW,IACCN,EAAUzU,EAAI8D,GACd2Q,EAAUzU,EAAI8D,EAAS,GACvB2Q,EAAUzU,EAAI8D,EAAS,IAG3B,IAAI0O,EAAa7Q,MAAM0T,SAAS5C,OAAOyB,EAAIC,EAAIC,GAE3CkB,EAAK,IAAI3T,MAAMmJ,QAOnB,GANAwK,EAAGP,IACCN,EAAW7D,EAAK1G,EAAIpG,GACpB2Q,EAAW7D,EAAK1G,EAAIpG,EAAS,GAC7B2Q,EAAW7D,EAAK1G,EAAIpG,EAAS,IAG7BuG,EAA4BmI,EAAY5B,EAAK6B,SAAWxI,EAAqBuI,EAAWvH,IAAIiJ,GAAKtD,EAAK6B,OAAOxH,IAAIqK,IACrH,CAEI,IAAIN,EAASX,EAAKhB,SAASpP,OAE3BoQ,EAAKhB,SAAShC,KAAK6C,EAAG/H,SACtBkI,EAAKhB,SAAShC,KAAK8C,EAAGhI,SACtBkI,EAAKhB,SAAShC,KAAK+C,EAAGjI,SAEtBkI,EAAKrC,MAAMX,KAAK,IAAI1P,MAAMkS,MAAMmB,EAAQA,EAAS,EAAGA,EAAS,MAO7E,OAAIX,EAAKhB,SAASpP,OAAS,EAEhBpC,KAAK0T,uBAAuBlB,EAAMzD,EAAM6D,EAAW3Q,GAInD,MAafjC,KAAK0T,uBAAyB,SAASlB,EAAMzD,EAAM6D,EAAW3Q,GAE1D,IAAI0R,GAAgB,EAChBC,EAAgBpB,EAAKhB,SAASqC,QAE9BJ,EAAK,IAAI3T,MAAMmJ,QACnBwK,EAAGP,IACCN,EAAW7D,EAAK1G,EAAIpG,GACpB2Q,EAAW7D,EAAK1G,EAAIpG,EAAS,GAC7B2Q,EAAW7D,EAAK1G,EAAIpG,EAAS,IAEjC,IAAIT,EAAK,IAAI1B,MAAMmJ,QACnBzH,EAAG0R,IACCN,EAAW7D,EAAKzG,EAAIrG,GACpB2Q,EAAW7D,EAAKzG,EAAIrG,EAAS,GAC7B2Q,EAAW7D,EAAKzG,EAAIrG,EAAS,IAEjC,IAAI6R,EAAK,IAAIhU,MAAMmJ,QACnB6K,EAAGZ,IACCN,EAAW7D,EAAK5Q,EAAI8D,GACpB2Q,EAAW7D,EAAK5Q,EAAI8D,EAAS,GAC7B2Q,EAAW7D,EAAK5Q,EAAI8D,EAAS,IAEjC,IAAI8R,EAAgB,IAAIjU,MAAM2S,SAC9BsB,EAAcvC,SAAShC,KAAKiE,GAC5BM,EAAcvC,SAAShC,KAAKhO,GAC5BuS,EAAcvC,SAAShC,KAAKsE,GAC5BC,EAAc5D,MAAMX,KAAK,IAAI1P,MAAMkS,MAAM,EAAG,EAAG,IAE/C,IAAIgC,EAAS,GAEb,EAAG,CAECA,EAAS,GAET,IAAK,IAAIf,EAAI,EAAGA,EAAIW,EAAcxR,OAAQ6Q,GAAK,EAG3C,GAAIW,EAAcX,GAAGgB,OAAOR,IAAOG,EAAcX,EAAI,GAAGgB,OAAOzS,IAAOoS,EAAcX,EAAI,GAAGgB,OAAOH,GAE9FH,GAAgB,EAChBK,EAAOxE,KAAKyD,QAIhB,IAAK,IAAIiB,EAAI,EAAGA,EAAIH,EAAcvC,SAASpP,OAAQ8R,GAAK,EAGpD,GAAIlU,KAAKmU,oBAAoBP,EAAcX,GAAIW,EAAcX,EAAI,GAAIW,EAAcX,EAAI,GAC/Ec,EAAcvC,SAAS0C,GAAIH,EAAcvC,SAAS0C,EAAI,GAAIH,EAAcvC,SAAS0C,EAAI,IAAK,CAE9F,IAAIf,EAASY,EAAcvC,SAASpP,OACpC2R,EAAcvC,SAAShC,KAAKoE,EAAcX,GAAG3I,SAC7CyJ,EAAcvC,SAAShC,KAAKoE,EAAcX,EAAI,GAAG3I,SACjDyJ,EAAcvC,SAAShC,KAAKoE,EAAcX,EAAI,GAAG3I,SACjDyJ,EAAc5D,MAAMX,KAAK,IAAI1P,MAAMkS,MAAMmB,EAAQA,EAAS,EAAGA,EAAS,IAEtEa,EAAOxE,KAAKyD,GACZ,MAKZ,IAAK,IAAImB,EAAKJ,EAAO5R,OAAS,EAAGgS,GAAM,IAAKA,EAExCR,EAAcS,OAAOL,EAAOI,GAAK,SAIhCJ,EAAO5R,OAAS,GAEzB,OAAIuR,EACOI,EAGA,MAUf/T,KAAKmU,oBAAsB,SAASG,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,GAEpD,IAAIC,GAAK,EACLC,GAAK,EACLC,GAAK,EAYT,OAVIR,EAAGL,OAAOQ,IAAOH,EAAGL,OAAOS,IAAOJ,EAAGL,OAAOU,MAC5CC,GAAK,IAELL,EAAGN,OAAOQ,IAAOF,EAAGN,OAAOS,IAAOH,EAAGN,OAAOU,MAC5CE,GAAK,IAELL,EAAGP,OAAOQ,IAAOD,EAAGP,OAAOS,IAAOF,EAAGP,OAAOU,MAC5CG,GAAK,MAGLF,EAAKC,GAAMD,EAAKE,GAAMD,EAAKC,IAOnC9U,KAAK+Q,yBAA2B,SAASjG,EAAgBvJ,EAAU6O,EAAeT,GAE9E,IACIoF,EADAC,EAAW,IAAIlV,MAAM2S,SAErBwC,EAAU9I,OAAOC,UAEjBiG,EAAK,IAAIvS,MAAMmJ,QACfqJ,EAAK,IAAIxS,MAAMmJ,QAEfyJ,EAAanR,EAASmR,WAE1B,QAAyBzD,IAArByD,EAAWC,OAAwC1D,MAAjBmB,EAA4B,CAM9D,IAJA,IAAIwC,EAAYrR,EAASC,GAAKD,EAASC,GAAKkR,EAAWG,SAASC,MAC5D7Q,EAASV,EAASC,GAAKD,EAASW,SAAW,EAGtCpE,EAAI,EAAGA,EAAIsS,EAAchO,OAAQtE,IAItC,IAFA,IAAIiV,EAAY3C,EAActS,GAAGiV,UAExBE,EAAI,EAAGA,EAAIF,EAAU3Q,OAAS,EAAG6Q,IAAK,CAC3CZ,EAAGa,IACCN,EAAWG,EAAUE,GAAKhR,GAC1B2Q,EAAWG,EAAUE,GAAKhR,EAAS,GACnC2Q,EAAWG,EAAUE,GAAKhR,EAAS,IAEvCqQ,EAAGY,IACCN,EAAWG,EAAUE,EAAI,GAAKhR,GAC9B2Q,EAAWG,EAAUE,EAAI,GAAKhR,EAAS,GACvC2Q,EAAWG,EAAUE,EAAI,GAAKhR,EAAS,IAG3CoQ,EAAGvK,aAAa6H,EAAKe,aACrB4B,EAAGxK,aAAa6H,EAAKe,aAErB,IAAIwE,EAAOvM,EAAoBmC,EAAgBuH,EAAIC,GAC/C4C,EAAOD,IACPA,EAAUC,EACVH,EAAmBjX,GAK/B,GAAIiX,EAAkB,CAClBhC,EAAY3C,EAAc2E,GAAkBhC,UAC5C,IAAK,IAAImB,EAAI,EAAGA,EAAInB,EAAU3Q,OAAS,EAAG8R,IACtCc,EAASxD,SAAShC,KAAK,IAAI1P,MAAMmJ,QAAQ2J,EAAUG,EAAUmB,GAAKjS,GAAS2Q,EAAUG,EAAUmB,GAAKjS,EAAS,GAAI2Q,EAAUG,EAAUmB,GAAKjS,EAAS,KAEnJ+S,EAASxD,SAAShC,KAAK,IAAI1P,MAAMmJ,QAAQ2J,EAAUG,EAAUmB,EAAI,GAAKjS,GAAS2Q,EAAUG,EAAUmB,EAAI,GAAKjS,EAAS,GAAI2Q,EAAUG,EAAUmB,EAAI,GAAKjS,EAAS,MAKvKiK,GAAmB+I,GAAWD,EAASxD,SAASpP,OAAS,IAEzD8J,EAAkB+I,EAClBD,EAAS9C,YAAYvC,EAAKe,aAC1BhF,EAAYkC,SAAWoH,IAY/BhV,KAAKmS,aAAe,SAASpD,EAAMjE,GAO/B,IALA,IAAIqK,EAAW,IAAIrV,MAAM2S,SACrB2C,GAAY,EACZC,GAAY,EACZC,GAAY,EAEPxX,EAAI,EAAGA,EAAIiR,EAAKyC,SAASpP,OAAQtE,GAAK,EAAG,CAE9C,IAAK,IAAImV,EAAI,EAAGA,EAAIlE,EAAKyC,SAASpP,OAAQ6Q,GAAK,EAEtCnV,IAAMmV,KAEFlE,EAAKyC,SAAS1T,GAAGmW,OAAOlF,EAAKyC,SAASyB,KAAOlE,EAAKyC,SAAS1T,GAAGmW,OAAOlF,EAAKyC,SAASyB,EAAI,KACrFlE,EAAKyC,SAAS1T,GAAGmW,OAAOlF,EAAKyC,SAASyB,EAAI,OACzClE,EAAKyC,SAAS1T,EAAI,GAAGmW,OAAOlF,EAAKyC,SAASyB,KAAOlE,EAAKyC,SAAS1T,EAAI,GAAGmW,OAAOlF,EAAKyC,SAASyB,EAAI,KAChGlE,EAAKyC,SAAS1T,EAAI,GAAGmW,OAAOlF,EAAKyC,SAASyB,EAAI,OAEjDmC,GAAY,IAIXrG,EAAKyC,SAAS1T,GAAGmW,OAAOlF,EAAKyC,SAASyB,KAAOlE,EAAKyC,SAAS1T,GAAGmW,OAAOlF,EAAKyC,SAASyB,EAAI,KACrFlE,EAAKyC,SAAS1T,GAAGmW,OAAOlF,EAAKyC,SAASyB,EAAI,OACzClE,EAAKyC,SAAS1T,EAAI,GAAGmW,OAAOlF,EAAKyC,SAASyB,KAAOlE,EAAKyC,SAAS1T,EAAI,GAAGmW,OAAOlF,EAAKyC,SAASyB,EAAI,KAChGlE,EAAKyC,SAAS1T,EAAI,GAAGmW,OAAOlF,EAAKyC,SAASyB,EAAI,OAEjDoC,GAAY,IAIXtG,EAAKyC,SAAS1T,EAAI,GAAGmW,OAAOlF,EAAKyC,SAASyB,KAAOlE,EAAKyC,SAAS1T,EAAI,GAAGmW,OAAOlF,EAAKyC,SAASyB,EAAI,KAC7FlE,EAAKyC,SAAS1T,EAAI,GAAGmW,OAAOlF,EAAKyC,SAASyB,EAAI,OAC7ClE,EAAKyC,SAAS1T,EAAI,GAAGmW,OAAOlF,EAAKyC,SAASyB,KAAOlE,EAAKyC,SAAS1T,EAAI,GAAGmW,OAAOlF,EAAKyC,SAASyB,EAAI,KAChGlE,EAAKyC,SAAS1T,EAAI,GAAGmW,OAAOlF,EAAKyC,SAASyB,EAAI,OAEjDqC,GAAY,IAMpBF,IAEAD,EAAS3D,SAAShC,KAAKT,EAAKyC,SAAS1T,GAAGwM,SACxC6K,EAAS3D,SAAShC,KAAKT,EAAKyC,SAAS1T,EAAI,GAAGwM,UAG5C+K,IAEAF,EAAS3D,SAAShC,KAAKT,EAAKyC,SAAS1T,GAAGwM,SACxC6K,EAAS3D,SAAShC,KAAKT,EAAKyC,SAAS1T,EAAI,GAAGwM,UAG5CgL,IAEAH,EAAS3D,SAAShC,KAAKT,EAAKyC,SAAS1T,EAAI,GAAGwM,SAC5C6K,EAAS3D,SAAShC,KAAKT,EAAKyC,SAAS1T,EAAI,GAAGwM,UAIhD8K,GAAY,EACZC,GAAY,EACZC,GAAY,EAUhB,IAJA,IACIC,EADAP,EAAW,IAAIlV,MAAM2S,SAErBwC,EAAU9I,OAAOC,UAEZ8H,EAAI,EAAGA,EAAIiB,EAAS3D,SAASpP,OAAQ8R,GAAK,EAAG,CAElD,IAAIgB,EAAOvM,EAAoBmC,EAAgBqK,EAAS3D,SAAS0C,GAAIiB,EAAS3D,SAAS0C,EAAI,IAEvFgB,EAAOD,IACPA,EAAUC,EACVK,EAAerB,GAYvB,OAPAc,EAASxD,SAAShC,KAAK2F,EAAS3D,SAAU+D,GAAejL,SACzD0K,EAASxD,SAAShC,KAAK2F,EAAS3D,SAAU+D,EAAe,GAAIjL,SAE7D0K,EAASxD,SAAWxR,KAAKwV,mCAAmCL,EAAUH,EAASxD,UAE/EtF,EAAkB+I,EAEXD,GAIXhV,KAAKwV,mCAAqC,SAASL,EAAUM,GAEzD,IAr8B+BhN,EAAIC,EAq8B/B8I,EAAW2D,EAAS3D,SAASqC,QAC7BJ,EAAKgC,EAAa,GAClBjU,EAAKiU,EAAa,GAElBzB,EAAS,GAEb,EAAG,CAECA,EAAS,GAET,IAAK,IAAIf,EAAI,EAAGA,EAAIzB,EAASpP,OAAQ6Q,GAAK,EAGtC,IAAIzB,EAASyB,GAAGgB,OAAOR,KAAOjC,EAASyB,EAAI,GAAGgB,OAAOzS,GAKrD,IAAK,IAAI0S,EAAI,EAAGA,EAAIuB,EAAarT,OAAQ8R,GAAK,EAG1C,GAAI1C,EAASyB,GAAGgB,OAAOwB,EAAavB,KAAO1C,EAASyB,EAAI,GAAGgB,OAAOwB,EAAavB,KAC3E1C,EAASyB,GAAGgB,OAAOwB,EAAavB,EAAI,KAAO1C,EAASyB,EAAI,GAAGgB,OAAOwB,EAAavB,EAAI,IAAK,CAExF,IAAIwB,EAAK,IAAI5V,MAAMmJ,QACf0M,EAAK,IAAI7V,MAAMmJ,QAQnB,GANAyM,EAAGvM,WAAWsM,EAAavB,GAAKuB,EAAavB,EAAI,IACjDwB,EAAG5E,YACH6E,EAAGxM,WAAWqI,EAASyB,GAAGzB,EAASyB,EAAI,IACvC0C,EAAG7E,YAGCtI,EAA4BkN,EAAIC,KAt+BrBlN,EAs+B0DiN,EAt+BtDhN,EAs+B0DiN,EAr+B1FvU,KAAKmH,IAAIE,EAAGzE,EAAI0E,EAAG1E,IAAMmE,GACzB/G,KAAKmH,IAAIE,EAAGvE,EAAIwE,EAAGxE,IAAMiE,GACzB/G,KAAKmH,IAAIE,EAAGxF,EAAIyF,EAAGzF,IAAMkF,GAo+BZ,CAEI6L,EAAOxE,KAAKyD,GACZ,OAOhB,IAAK,IAAImB,EAAKJ,EAAO5R,OAAS,EAAGgS,GAAM,IAAKA,EAExCqB,EAAajG,KAAKgC,EAAUwC,EAAOI,KACnCqB,EAAajG,KAAKgC,EAAUwC,EAAOI,GAAM,IACzC5C,EAAS6C,OAAOL,EAAOI,GAAK,SAI3BJ,EAAO5R,OAAS,GAEzB,OAAOqT,GAIXzV,KAAKgR,2BAA6B,SAAS4E,EAAM9K,GAE7C,IAAImK,EAAU9I,OAAOC,UACjBpJ,EAAQ,IAAIlD,MAAMmJ,QAEtB,GAAI2M,GAAQA,EAAKpE,SAASpP,OAAS,EAAG,CAClC,IAAIyT,EAAQ/K,EAAezB,WAAWuM,EAAKpE,SAAS,IAChDsE,EAAQhL,EAAezB,WAAWuM,EAAKpE,SAASoE,EAAKpE,SAASpP,OAAS,IAEvEyT,GAASC,GACTb,EAAUY,EACV7S,EAAQ4S,EAAKpE,SAAS,GAAGlH,UAGzB2K,EAAUa,EACV9S,EAAQ4S,EAAKpE,SAASoE,EAAKpE,SAASpP,OAAS,GAAGkI,SAMxD,OAFA+B,EAAoB4I,EAEbjS,GAUXhD,KAAKoS,eAAiB,SAASwD,EAAM9K,GAKjC,IAHA,IAAImK,EAAU9I,OAAOC,UACjBpJ,EAAQ,IAAIlD,MAAMmJ,QAEbnL,EAAI,EAAGA,EAAI8X,EAAKpE,SAASpP,SAAUtE,EAAG,CAE3C,IAAIoX,EAAOpK,EAAezB,WAAWuM,EAAKpE,SAAS1T,IAE/CoX,EAAOD,EAAU9M,IAEjB8M,EAAUC,EACVlS,EAAQ4S,EAAKpE,SAAS1T,GAAGwM,SAOjC,OAFA+B,EAAoB4I,EAEbjS,GAIXhD,KAAKqR,aAAe,SAASuE,GAEzB,IAAIpE,EAAWoE,EAAKpE,SAGpB,GAAIA,EAASpP,OAAS,EAClB,OAAO,EAGX,GAAIoP,EAAS,GAAGyC,OAAOzC,EAASA,EAASpP,OAAS,IAAK,CAGnD,IADA,IAAI6H,EAAS,IAAInK,MAAMmJ,QAAQ,EAAG,EAAG,GAC5BnL,EAAI,EAAGA,EAAI0T,EAASpP,OAAQtE,GAAK,EACtCmM,EAAO8L,IAAIvE,EAAS1T,IAExBmM,EAAO+L,aAAaxE,EAASpP,OAAS,GAEtC,IAAI8C,EAAS+E,EAAOZ,WAAWmI,EAAS,IACxC,IAAS1T,EAAI,EAAGA,EAAI0T,EAASpP,OAAQtE,GAAK,EACtC,KAAIsD,KAAKmH,IAAI0B,EAAOZ,WAAWmI,EAAS1T,IAAMoH,IAAWiD,GAIrD,OAAO,EAGf,OAAO8B,EAGP,OAAO,GAIfjK,KAAK0R,aAAe,SAAUkE,GAE1B,IAAIpE,EAAWoE,EAAKpE,SAEpB,GAAIA,EAASpP,QAAU,EACnB,OAAO,EAEN,GAAIoP,EAAS,GAAGyC,OAAOzC,EAASA,EAASpP,OAAS,IACnD,OAAO,EAGP,IAAIuT,EAAK,IAAI7V,MAAMmJ,QACnB0M,EAAGxM,WAAWqI,EAAS,GAAIA,EAAS,IAGpC,IADA,IAAIyE,EAAK,IAAInW,MAAMmJ,QACVnL,EAAI,EAAGA,EAAI0T,EAASpP,OAAQtE,GAAK,EAEtC,GADAmY,EAAG9M,WAAWqI,EAAS1T,GAAI0T,EAAS1T,EAAI,KACnC0K,EAA4BmN,EAAIM,GACjC,OAAO,EAIf,OAAO,GAIfjW,KAAK6R,aAAe,SAAU9C,GAE1B,IAAIyC,EAAWzC,EAAKyC,SAChBrB,EAAQpB,EAAKoB,MAEjB,GAAIA,EAAM/N,QAAU,EAChB,OAAO,EAMP,IAHA,IAAI8T,EAAMpW,MAAM0T,SAAS5C,OAAOY,EAASrB,EAAM,GAAG9H,GAAImJ,EAASrB,EAAM,GAAG7H,GAAIkJ,EAASrB,EAAM,GAAGhS,IAC1FgY,EAAM3E,EAASrB,EAAM,GAAG9H,GAEnBvK,EAAI,EAAGA,EAAIqS,EAAM/N,OAAQtE,IAAK,CACnC,IAAIsY,EAAMtW,MAAM0T,SAAS5C,OAAOY,EAASrB,EAAMrS,GAAGuK,GAAImJ,EAASrB,EAAMrS,GAAGwK,GAAIkJ,EAASrB,EAAMrS,GAAGK,IAC1FkY,EAAM7E,EAASrB,EAAMrS,GAAGuK,GAE5B,IAAKG,EAA4B0N,EAAKE,KAAShO,EAAqB8N,EAAI9M,IAAI+M,GAAMC,EAAIhN,IAAIiN,IACtF,OAAO,EAIf,OAAO,GAIfrW,KAAKsW,aAAe,SAASC,GAEzB,OAAIA,EAAOvS,EAAI,GAAKuS,EAAOrS,GAAK,EACrB9C,KAAKoV,KAAKD,EAAOrS,EAAIqS,EAAOvS,GAE9BuS,EAAOvS,GAAK,GAAKuS,EAAOrS,EAAI,EAC1B9C,KAAKoV,KAAKD,EAAOrS,EAAIqS,EAAOvS,GAAe,EAAV5C,KAAKC,GAExCkV,EAAOvS,EAAI,GAAKuS,EAAOrS,GAAK,EAC1B9C,KAAKoV,KAAKD,EAAOrS,EAAIqS,EAAOvS,GAAK5C,KAAKC,GAExCkV,EAAOvS,GAAK,GAAKuS,EAAOrS,EAAI,EAC1B9C,KAAKoV,KAAKD,EAAOrS,EAAIqS,EAAOvS,GAAK5C,KAAKC,GAGtC,MAmBf,SAASoV,EAAiB5V,EAAQ6V,EAASC,GACvC3W,KAAKa,OAASA,EACdb,KAAK0W,QAAUA,EAEf1W,KAAKmV,SAAW,IAAIrV,MAAM2S,SAC1BzS,KAAK4W,YAAc,KACnB5W,KAAKsR,kBACLtR,KAAKuR,kBACLvR,KAAK6W,cAAgB,KACrB7W,KAAK8W,oBAEL9W,KAAKiV,QAAU9I,OAAOC,UAEtBpM,KAAK+W,SAAW,KAChB/W,KAAKgX,aAAe,KACpBhX,KAAKiX,eAAiB,KAEtBjX,KAAKkX,aAAeP,EAIpB3W,KAAKmX,eAAiB,GAG1BV,EAAiB/W,UAAUmE,cAAgB,SAASW,EAAIE,EAAIuB,EAAIC,EAAIvC,GAChE,IAAImH,EAAiB9K,KAAK0W,QAAQzI,oBAC9BuD,EAAWxR,KAAKmV,SAAS3D,SACzB/I,EAAK,IAAI3I,MAAMmJ,QAAQzE,EAAIE,EAAIoG,EAAe7H,GAC9CyF,EAAK,IAAI5I,MAAMmJ,QAAQhD,EAAIC,EAAI4E,EAAe7H,GAG9CiS,EAAOvM,EAAoBmC,EAAgBrC,EAAIC,GAC/CwM,EAAOlV,KAAKkX,eAKhBlX,KAAKmX,eAAe3H,KAAK,IAAI3F,EAAclG,EAAMuR,GAAMkC,SAAS3O,EAAIC,IAGhEwM,EAAOlV,KAAKiV,UAEZzD,EAAS6C,OAAO,EAAG,EAAG5L,EAAIC,GAC1B1I,KAAKiV,QAAUC,EAEflV,KAAK+W,SAAWpT,KAIxB8S,EAAiB/W,UAAUmF,cAAgB,SAASC,EAAIC,EAAIC,EAAOC,EAAKC,EAAQvB,GAC5E,IAAImH,EAAiB9K,KAAK0W,QAAQzI,oBAC9BjL,EAAQ,IAAIlD,MAAM0L,QAAQV,EAAe9G,EAAG8G,EAAe5G,GAE3D+F,EAAS,IAAInK,MAAM0L,QAAQ1G,EAAIC,GACnC/B,EAAMqU,IAAIpN,GAGV,IAAMqN,EAAaC,oCAA0BzM,EAAgBb,EAAQ/E,EAAQF,EAAOC,GAC9EiQ,EAAaoC,EAAWjO,WAAWyB,GAMzC,GAHA9K,KAAKmX,eAAe3H,KAAK,IAAI3F,EAAclG,EAAMuR,GAAMsC,gBAAgBvN,EAAQ/E,EAAQF,EAAOC,MAG1FiQ,EAAOlV,KAAKkX,cAAhB,CAOA,IAAI/S,EAAQnE,KAAK0W,QAAQJ,aAAatT,GAEtC,GAAIiC,EAAMD,GAASb,GAASa,GAASb,GAASc,EAC1C,IAAIwS,EAAM,IAAI3X,MAAM4X,eAAexS,EAAQ,IAAKF,EAAOC,EAAMD,OAE5D,MAAIC,EAAMD,IAAUb,GAASa,GAASb,GAASc,IAIhD,OAHIwS,EAAM,IAAI3X,MAAM4X,eAAexS,EAAQ,IAAKF,EAAiB,EAAV5D,KAAKC,GAAS2D,EAAQC,GAKjFwS,EAAIjG,SAAS6C,OAAO,EAAG,GACvBoD,EAAIvF,aAAY,IAAIpS,MAAM6X,SAAU/P,gBAAgB9C,EAAIC,EAAI+F,EAAe7H,IAC3EjD,KAAK4W,YAAca,EACnBzX,KAAKsR,kBAAoB,IAAIxR,MAAMmJ,QAAQnE,EAAIC,EAAI+F,EAAe7H,GAClEjD,KAAKuR,kBAAoBrM,EAEzBlF,KAAKoL,UAAY,IAAItL,MAAMmJ,QAAQqO,EAAWtT,EAAGsT,EAAWpT,EAAG4G,EAAe7H,GAE9EjD,KAAKgX,aAAerT,IAGxB8S,EAAiB/W,UAAU0F,gBAAkB,SAASN,EAAIC,EAAIC,EAAOC,EAAKI,EAAOC,EAAOC,EAAM5B,GAC1F,IAAImH,EAAiB9K,KAAK0W,QAAQzI,oBAC9BjL,EAAQ,IAAIlD,MAAM0L,QAAQV,EAAe9G,EAAG8G,EAAe5G,GAE3D0T,EAASvS,EAAQrF,KAAKkX,aACtBW,EAASvS,EAAQtF,KAAKkX,aACtBY,EAASzS,EAAQrF,KAAKkX,aACtBa,EAASzS,EAAQtF,KAAKkX,aAEtBc,GAAahV,EAAMgB,EAAIc,IAAO9B,EAAMgB,EAAIc,IAAO8S,EAASA,IAAW5U,EAAMkB,EAAIa,IAAO/B,EAAMkB,EAAIa,IAAO8S,EAASA,GAC9GI,GAAajV,EAAMgB,EAAIc,IAAO9B,EAAMgB,EAAIc,IAAOgT,EAASA,IAAW9U,EAAMkB,EAAIa,IAAO/B,EAAMkB,EAAIa,IAAOgT,EAASA,GAE9G9N,EAAS,IAAInK,MAAM0L,QAAQ1G,EAAIC,GACnC/B,EAAMqU,IAAIpN,GACVjH,EAAMgB,GAAKsB,EACXtC,EAAMkB,GAAKmB,EACX,IAAIlB,EAAQnE,KAAK0W,QAAQJ,aAAatT,GAMtC,GAJIiC,EAAgB,EAAV7D,KAAKC,KACX4D,EAAgB,EAAV7D,KAAKC,IAGX2W,GAAa,GAAKC,GAAa,IAE1BhT,EAAMD,GAASb,GAASa,GAASb,GAASc,GAASA,EAAMD,IAAUb,GAASa,GAASb,GAASc,IAAM,CACrG,IAAIwS,EAjIoB,SAAC3S,EAAIC,EAAImT,EAAIC,EAAIjO,EAAYC,EAAUiO,GAEvE,IADA,IAAM7W,EAAW,IAAIzB,MAAM2S,SAClB3U,EAAE,EAAGA,EAAEsa,EAAWta,IAAK,CAC5B,IAAI8B,EAAI,IAAIE,MAAMmJ,QAAQ,EAAE,EAAE,GAC9BoP,6BAAmBvT,EAAIC,EAAImT,EAAIC,EAAIjO,EAAYC,EAAUrM,GAAGsa,EAAU,GAAIxY,GAE1E2B,EAASiQ,SAAShC,KAAK5P,GAE3B,OAAO2B,EAyHW+W,CAA4BxT,EAAIC,EAAIM,EAAOC,EAAON,EAAOC,EAAK,IACnEmD,EAAqBnD,EAAMD,EAAiB,EAAV5D,KAAKC,KAExCoW,EAAIjG,SAAS+G,MAEjBd,EAAIvF,aAAY,IAAIpS,MAAM6X,SAAU/P,gBAAgB,EAAG,EAAGkD,EAAe7H,IAIzE,IAAMuV,EAAeC,4BAA4B3N,EAAgB2M,GAC3DvC,EAAOpV,MAAM0L,QAAQ9L,UAAU2J,WAAWpL,KAAKua,EAAc1N,GAG7Db,EAAS,IAAInK,MAAM0L,QAAQ1G,EAAIC,GACrC/E,KAAKmX,eAAe3H,KAAK,IAAI3F,EAAclG,EAAMuR,GAAMwD,kBAAkBzO,EAAQ5E,EAAOC,EAAON,EAAOC,IAItGjF,KAAK6W,cAAgBY,EACrBzX,KAAK8W,oBAAsB,IAAIhX,MAAMmJ,QAAQnE,EAAIC,EAAI+F,EAAe7H,GAEpEjD,KAAKiX,eAAiBtT,IAKlC3D,KAAK2Y,WAAa,SAASxN,GAEvB,GAAKA,EAAL,CAIA,IAAIL,EAAiBK,EAAOL,eACxBgE,EAAU3D,EAAO6D,OAErB,QAAuB,IAAZF,EAAX,CAgBA,GAbU8J,MAAMC,QAAQ/J,KACpBA,EAAU,CAACA,IAGfpD,EAAYiD,QAAUxD,EAAOyD,MAAQzD,EAAOyD,MAAMC,GAAK,KACvDnD,EAAYwD,aAAc,EAC1BxD,EAAYZ,eAAiBA,EAG7BY,EAAYxG,OAASlF,KAAKiR,gBAAgBnG,KAGmB,MAAjCa,EAAQiD,MAAMkK,mBAStC,OAJAtM,GAAa,EACbd,EAAY/E,SAAWsB,EAASkJ,iBAChCzF,EAAYoC,WAAahD,GAQ7B,IAFA,IAAIiO,EAAK,IAAItC,EAAiB9K,EAAS3L,KAAM0L,EAAYxG,QAEhDwK,EAAK,EAAGA,EAAKZ,EAAQ1M,SAAUsN,EAAI,CAExC,IAAIC,EAAOhE,EAAQiE,KAAKC,eAAelE,EAAQiD,MAAOE,EAAQY,IAE9D,GAAIC,GAAQA,EAAKpO,SACH,IAAID,EAAmBqO,EAAKpO,UAClCkF,mBAAmBkF,EAAQiD,MAAMoK,eAAe7N,EAAOzE,MAAOqS,GAI1E/Y,KAAKiZ,iBAAiBF,EAAIjO,IAGtB0B,GAAcE,IACdF,GAAa,EACbd,EAAY/E,SAAWsB,EAASiR,aAChCxN,EAAYoC,WAAahD,MAajC9K,KAAKmZ,kBAAoB,SAASrO,EAAgBsO,EAAQhS,EAAQ8P,GAC9DxL,EAAYwD,aAAc,EAC1BxD,EAAYZ,eAAiBA,EAC7BY,EAAYxG,OAASgS,GAAgBlX,KAAKiR,gBAAgBnG,GAI1D,IAFA,IAAIiO,EAAK,IAAItC,EAAiB9K,EAAS3L,KAAM0L,EAAYxG,QAEhDpH,EAAE,EAAGA,EAAEsb,EAAOhX,OAAQtE,IAAK,CAEtB,IAAIwD,EADH8X,EAAOtb,GACoByD,UAClC0F,UAAUG,EAAQ2R,GAG1B/Y,KAAKiZ,iBAAiBF,EAAIjO,IAO9B9K,KAAKqZ,0BAA4B,SAASvO,EAAgBwO,GAEtD5N,EAAYwD,aAAc,EAC1BxD,EAAYZ,eAAiBA,EAC7BY,EAAYxG,OAASlF,KAAKiR,gBAAgBnG,GAE1C,IAAIiO,EAAK,IAAItC,EAAiB9K,EAAS3L,KAAM0L,EAAYxG,QAOzDoU,EAJWxO,EAAe9G,EAAI0H,EAAYxG,OAC/B4F,EAAe5G,EAAIwH,EAAYxG,OAC/B4F,EAAe9G,EAAI0H,EAAYxG,OAC/B4F,EAAe5G,EAAIwH,EAAYxG,OACL6T,GAErC/Y,KAAKiZ,iBAAiBF,EAAIjO,IAI9B9K,KAAKiZ,iBAAmB,SAASF,EAAIjO,GAGjC,GAAoB,OAAhB2B,EAAsB,CAEtBsM,EAAG5B,eAAiB4B,EAAG5B,eAAe/P,QADf,SAAAjJ,GAAC,OAAKA,EAAE+I,aAAeuF,KAKlD,IAAM8M,EAAgB3O,EAAqBmO,EAAG5B,eAAgBrM,EAAgBiO,EAAG7B,cACjF,GAAIqC,EAMA,OALA7N,EAAY8N,gBAAkBD,EAAcrS,WAC5CwE,EAAYN,UAAYmO,EAAcnO,UACtCM,EAAY/E,SAAWsB,EAASwR,kBAChC/N,EAAYoC,WAAayL,EAAcnO,eACvCoB,GAAa,GAIjB,GAAIuM,EAAGnC,YAAa,CAOhB,GALAlL,EAAY8N,gBAAkBT,EAAG/B,aAEjCtL,EAAYN,UAAY2N,EAAG3N,UAGP,OAAhBqB,GAAwBA,IAAgBf,EAAY8N,gBACpD,OAEA1O,EAAezB,WAAW0P,EAAGnC,YAAYpF,SAAS,IAAM9F,EAAYxG,QAEpEwG,EAAYoC,WAAaiL,EAAGnC,YAAYpF,SAAS,GACjD9F,EAAY/E,SAAWsB,EAASkJ,aAE3BrG,EAAezB,WAAW0P,EAAGnC,YAAYpF,SAASuH,EAAGnC,YAAYpF,SAASpP,OAAS,IAAMsJ,EAAYxG,QAE1GwG,EAAYoC,WAAaiL,EAAGnC,YAAYpF,SAASuH,EAAGnC,YAAYpF,SAASpP,OAAS,GAClFsJ,EAAY/E,SAAWsB,EAASkJ,cAIhCnR,KAAK0Z,kBAAkBX,EAAGnC,aAC1BlL,EAAYkC,SAAWmL,EAAGnC,YAC1BlL,EAAY4F,kBAAoByH,EAAGzH,kBACnC5F,EAAY6F,kBAAoBwH,EAAGxH,kBACnC7F,EAAY/E,SAAWsB,EAASwJ,kBAGpCjF,GAAa,OAIZ,GAAIuM,EAAGlC,cAAe,CAKvB,GAHAnL,EAAY8N,gBAAkBT,EAAG9B,eAGb,OAAhBxK,GAAwBA,IAAgBf,EAAY8N,gBACpD,OAEA1O,EAAezB,WAAW0P,EAAGlC,cAAcrF,SAAS,IAAM9F,EAAYxG,QAEtEwG,EAAYoC,WAAaiL,EAAGlC,cAAcrF,SAAS,GACnD9F,EAAY/E,SAAWsB,EAASkJ,aAE3BrG,EAAezB,WAAW0P,EAAGlC,cAAcrF,SAASuH,EAAGlC,cAAcrF,SAASpP,OAAS,IAAMsJ,EAAYxG,QAE9GwG,EAAYoC,WAAaiL,EAAGlC,cAAcrF,SAASuH,EAAGlC,cAAcrF,SAASpP,OAAS,GACtFsJ,EAAY/E,SAAWsB,EAASkJ,cAIhCnR,KAAK0Z,kBAAkBX,EAAGlC,eAC1BnL,EAAYkC,SAAWmL,EAAGlC,cAE1BnL,EAAY4F,kBAAoByH,EAAGjC,oBACnCpL,EAAY6F,kBAAoB,KAChC7F,EAAY/E,SAAWsB,EAASwJ,kBAGpCjF,GAAa,OAGZ,GAAIuM,EAAG5D,SAAS3D,SAASpP,OAAQ,CAKlC,GAHAsJ,EAAY8N,gBAAkBT,EAAGhC,SAGb,OAAhBtK,GAAwBA,IAAgBf,EAAY8N,gBACpD,OAMJ,GAFA9N,EAAYkC,SAAWmL,EAAG5D,SAEtBnV,KAAKgM,WAAY,CACjB,IAAIhH,EAAQ+T,EAAG5D,SAAS3D,SAAS,GAC7BvM,EAAM8T,EAAG5D,SAAS3D,SAAS,GAC3BmI,EAAM,IAAI7Z,MAAMmJ,QACpB0Q,EAAIC,WAAW5U,EAAOC,GACtB0U,EAAI3D,aAAa,GACjB,IAAI6D,EAAK/O,EAAezB,WAAWsQ,GAC/BG,EAAKhP,EAAezB,WAAWrE,GAC/B+U,EAAKjP,EAAezB,WAAWpE,GAGnCyG,EAAYkC,SAAWmL,EAAG5D,SAEtB0E,EAAKnO,EAAYxG,QACjBwG,EAAYoC,WAAa6L,EACzBjO,EAAY/E,SAAWsB,EAASkJ,aAE3B2I,EAAKpO,EAAYxG,QACtBwG,EAAYoC,WAAa9I,EACzB0G,EAAY/E,SAAWsB,EAASkJ,aAE3B4I,EAAKrO,EAAYxG,QACtBwG,EAAYoC,WAAa7I,EACzByG,EAAY/E,SAAWsB,EAASkJ,aAGhCzF,EAAY/E,SAAWsB,EAAS2J,UAIhCmH,EAAG5D,SAAS3D,SAAS,GAAGnI,WAAW0P,EAAG5D,SAAS3D,SAAS,IAAMxJ,IAC9D0D,EAAY/E,SAAWsB,EAAS+R,yBAIhClP,EAAezB,WAAW0P,EAAG5D,SAAS3D,SAAS,IAAM9F,EAAYxG,QAE7D6T,EAAG5D,SAAS3D,SAAS,GAAGnI,WAAW0P,EAAG5D,SAAS3D,SAAS,IAAMxJ,EAC9D0D,EAAY/E,SAAWsB,EAAS+R,mBAEhCtO,EAAY/E,SAAWsB,EAASkJ,YAGpCzF,EAAYoC,WAAaiL,EAAG5D,SAAS3D,SAAS,IAExCzF,EAASmF,mBAAsBpG,EAAezB,WAAW0P,EAAG5D,SAAS3D,SAAS,IAAM9F,EAAYxG,QAEtGwG,EAAYoC,WAAaiL,EAAG5D,SAAS3D,SAAS,GAC9C9F,EAAY/E,SAAWsB,EAASkJ,aAGhCzF,EAAY/E,SAAWsB,EAAS2J,UAIxCpF,GAAa,IAIrBxM,KAAKia,gBAAkB,SAAS9O,GAC5B,GAAKA,EAAL,CAIA,IAAIL,EAAiBK,EAAOL,eAC5BY,EAAYZ,eAAiBA,EAC7BY,EAAYwD,aAAc,EAG1BxD,EAAYxG,OAASlF,KAAKiR,gBAAgBnG,GAC1CY,EAAY/E,SAAWsB,EAASiR,aAChCxN,EAAYoC,WAAahD,EACzB0B,GAAa,IAGjBxM,KAAKka,aAAe,WAIhB,GAHAxO,EAAYyO,YAAa,EAGrB3N,GACId,EAAY/E,WAAasB,EAAS2J,UAAW,CAC7C,IAAIgE,EAAOlK,EAAYkC,SACnBxD,EAAKwL,EAAKpE,SAAS,GACnBnH,EAAKuL,EAAKpE,SAAS,GAEnB4I,EAAW,IAAIta,MAAMmJ,SAASmB,EAAGpG,EAAIqG,EAAGrG,GAAK,GAAIoG,EAAGlG,EAAImG,EAAGnG,GAAK,GAAIkG,EAAGnH,EAAIoH,EAAGpH,GAAK,GAEnFyI,EAAYZ,eAAezB,WAAW+Q,GAAY,EAAI1O,EAAYxG,SAClEwG,EAAYoC,WAAasM,EACzB1O,EAAY/E,SAAWsB,EAASoS,iBAMhDra,KAAKsa,iBAAmB,SAASC,GAC7B7O,EAAY6O,gBAAkBA,GAGlCva,KAAK0Z,kBAAoB,SAASlH,GAG9B,IADA,IAAIhB,EAAWgB,EAAKhB,SACX1T,EAAI0T,EAASpP,OAAS,EAAGtE,EAAI,EAAGA,IACrC0T,EAAS6C,OAAOvW,EAAG,EAAG0T,EAAS1T,KAIvCkC,KAAKiR,gBAAkB,SAASjO,GAE5B,IAAIwX,EAAS7O,EAAQ8O,WACjBC,EAASF,EAAOG,YAChB9H,EAAW2H,EAAOI,cAElBhb,EAAIoD,EAAMsH,QAEVxB,EAAW4R,EAAOG,cAAgBjb,EAAEyX,IAAIxE,GAAUzQ,SAChDoY,EAAOM,eAAe1Y,SAExB2Y,EAAMP,EAAOQ,iBACbC,EAAc,EAAMnS,EAAW1H,KAAK8Z,IAAIpb,MAAMsB,KAAK+Z,SAAe,GAANJ,IAE5DK,EAAWZ,EAAOa,oBAElBC,EADUtb,KAAKub,YACYD,kBAAoB,EAGnD,OAFatb,KAAK+M,qBAAuBkO,GAAeG,EAAStV,OAASwV,IAK9Etb,KAAKwb,iBAAmB,SAAUC,EAAOC,GAErC,OADApP,GAAc,GACP,GAGXtM,KAAK2b,eAAiB,SAAUF,EAAOC,GAEnC,OADApP,GAAc,GACP,GAGXtM,KAAK4b,gBAAkB,SAAUH,GAE7B,OAAInP,IAGJtM,KAAK6b,YAAY,CACb7X,EAAGyX,EAAMK,QACT5X,EAAGuX,EAAMM,WAGN,IAGX/b,KAAKgc,gBAAkB,SAASP,GAE5B,OAAOzb,KAAK4b,gBAAgBH,IAGhCzb,KAAKic,gBAAkB,SAAUR,GAE7B,GAAIzO,cACA,OAAQyO,EAAM3R,MAEV,IAAK,QACDyC,GAAc,EACdvM,KAAK6b,YAAY,CAAC7X,EAAGyX,EAAMK,QAAS5X,EAAGuX,EAAMM,UAC7C,MAEJ,IAAK,UACD/b,KAAK6b,YAAY,CAAC7X,EAAGyX,EAAMK,QAAS5X,EAAGuX,EAAMM,UAC7CxP,GAAc,EAI1B,OAAO,GAIXvM,KAAKkc,cAAgB,SAAUT,GAE3B,GAAIzO,eACIT,EACA,OAAQkP,EAAM3R,MAEV,IAAK,YAIL,IAAK,WACD9J,KAAK6b,YAAY,CAAC7X,EAAGyX,EAAMK,QAAS5X,EAAGuX,EAAMM,UAC7C,MAEJ,IAAK,UACD/b,KAAK6b,YAAY,CAAC7X,EAAGyX,EAAMK,QAAS5X,EAAGuX,EAAMM,UAC7CxP,GAAc,EAgB9B,OAAO,GAOXvM,KAAKmc,YAAc,SAASC,GACxB,OAAOpc,KAAK6b,YAAYO,IAO5Bpc,KAAK6b,YAAc,SAASO,GAExBpc,KAAKoO,eAEL,IAAIjD,EAASQ,EAAQiE,KAAKyM,gBAAgBD,EAAcpY,EAAGoY,EAAclY,GAAG,GAE5E,IAAIiH,GAAUuB,EAAc,CACxB,IAAI4P,EAAQ3Q,EAAQiE,KAAK2M,iBAAiBH,EAAcpY,EAAGoY,EAAclY,GAEzEiH,EAAS,CAAEL,eADCa,EAAQiE,KAAK4M,wBAAwBF,IAIrD,SAAKnR,IAAWA,EAAOL,kBAInBK,EAAO4D,KACP/O,KAAKyO,WAAWtD,GAGXA,EAAOzE,MAAwB,IAAhByE,EAAOzE,KAC3B1G,KAAK2Y,WAAWxN,GAIhBnL,KAAKia,gBAAgB9O,GAGzBnL,KAAKka,gBAEE,IAIf9Z,EAAGqc,mBAAmBxe,KAAKwN,EAAQ/L,Y,iSCnxD5B,IAAM2Y,EAAqB,SAACvT,EAAIC,EAAImT,EAAIC,EAAIjO,EAAYC,EAAUnL,EAAG0d,GAExEA,EAAYA,GAAa,IAAI5c,MAAM0L,QAEnC,IAAImR,EAAaxS,EAAWD,EAMxByS,EAAa,IAAcA,GAAwB,EAAVvb,KAAKC,IAC9Csb,EAAuB,EAAVvb,KAAKC,KAASsb,GAAwB,EAAVvb,KAAKC,IAElD,IAAI8C,EAAQ+F,EAAalL,EAAI2d,EAK7B,OAHAD,EAAU1Y,EAAIc,EAAKoT,EAAK9W,KAAKqD,IAAIN,GACjCuY,EAAUxY,EAAIa,EAAKoT,EAAK/W,KAAKuD,IAAIR,GAE1BuY,GAIEE,EAAiB,SAACzY,GAc3B,OAZAA,GAAS,EAAM/C,KAAKC,IAGpB8C,GAAS/C,KAAKyb,MAAM1Y,IAIR,IACRA,GAAS,GAIE,EAARA,EAAc/C,KAAKC,IAKjByb,EAAiB,SAAC3Y,EAAOa,EAAOC,GAOzC,OAJAd,EAAQyY,EAAezY,IACvBa,EAAQ4X,EAAe5X,KACvBC,EAAQ2X,EAAe3X,IAGZd,GAASa,GAASb,GAASc,EAM/Bd,GAASa,GAASb,GAASc,GASzBsS,EAA4B,SAAC3X,EAAGqK,EAAQ/E,EAAQgF,EAAYC,EAAU4S,GAM/E,IAAMC,GAJND,EAAWA,GAAY,IAAIjd,MAAM0L,SAIZyR,KAAKrd,GAAGyX,IAAIpN,GAAQ6G,YAGnC3M,EAAQ/C,KAAK8b,MAAMF,EAAI9Y,EAAG8Y,EAAIhZ,GAEpC,GADkB8Y,EAAe3Y,EAAO+F,EAAYC,GAOhD,OAAO6S,EAAIG,eAAejY,GAAQ6Q,IAAI9L,GAM1C,IAAMmT,EAAS/E,EAAmBpO,EAAOjG,EAAGiG,EAAO/F,EAAGgB,EAAQA,EAAQgF,EAAYC,EAAU,GACtFkT,EAAShF,EAAmBpO,EAAOjG,EAAGiG,EAAO/F,EAAGgB,EAAQA,EAAQgF,EAAYC,EAAU,GAItFmT,EAFUF,EAAOG,kBAAkB3d,IACzByd,EAAKE,kBAAkB3d,GAIvC,OADAmd,EAASE,KAAKK,EAAgBF,EAASC,GAChCN,GAWEpS,EAAiB,SAACP,EAAIC,EAAImT,EAAIC,EAAIC,EAAoBX,GAAiC,IAAvBY,EAAsB,uDAAZ,KAE7EC,GAASH,EAAGvZ,EAAIsZ,EAAGtZ,IAAMmG,EAAGrG,EAAIoG,EAAGpG,IAAMyZ,EAAGzZ,EAAIwZ,EAAGxZ,IAAMqG,EAAGnG,EAAIkG,EAAGlG,GAGzE,GAAI9C,KAAKmH,IAAIqV,GAASD,EAClB,OAAO,KAMX,IAAIE,GAAMJ,EAAGzZ,EAAIwZ,EAAGxZ,IAAMoG,EAAGlG,EAAIsZ,EAAGtZ,IAAMuZ,EAAGvZ,EAAIsZ,EAAGtZ,IAAMkG,EAAGpG,EAAIwZ,EAAGxZ,GAIpE,GAHA6Z,GAAMD,EAGFF,EAAoB,CAGpB,IAAII,GAAMzT,EAAGrG,EAAIoG,EAAGpG,IAAMoG,EAAGlG,EAAIsZ,EAAGtZ,IAAMmG,EAAGnG,EAAIkG,EAAGlG,IAAMkG,EAAGpG,EAAIwZ,EAAGxZ,GAIpE,GAHA8Z,GAAMF,EAGFC,EAAK,GAAOA,EAAK,GACjBC,EAAK,GAAOA,EAAK,EACjB,OAAO,KAQf,OAJAf,EAAWA,GAAY,IAAIjd,MAAM0L,SAExBxH,EAAIoG,EAAGpG,EAAI6Z,GAAMxT,EAAGrG,EAAIoG,EAAGpG,GACpC+Y,EAAS7Y,EAAIkG,EAAGlG,EAAI2Z,GAAMxT,EAAGnG,EAAIkG,EAAGlG,GAC7B6Y,I,gCCxJX,4DAAMhV,EAAgB1H,SAASC,QAAQyH,cACjCgW,EAAiBhW,EAAcgW,eAC/B/V,EAAUD,EAAcC,QACxBC,EAAWF,EAAcE,SAEvB+V,EAAa,EAKbC,EAAqB,iCACrBC,EAAoB,gCAKpBC,EAAS,KAETC,EAAkB,SAClBC,EAAiB,MAGd,SAASzR,EAAkB/L,EAAQ6V,GAEtC1W,KAAKa,OAASA,EACdb,KAAK0W,QAAUA,EACf1W,KAAKse,YAAcN,EACnBhe,KAAKue,uBAAyB,KAE9Bve,KAAKa,OAAO+O,KAAK4O,mBAAmBP,GACpCje,KAAKa,OAAO+O,KAAK4O,mBAAmBN,GAEpCle,KAAKye,iBAAmB,IAAI3e,MAAM4e,kBAAkB,CAChDC,MAAON,EACPO,QAASP,EACTQ,QAAS,GACTC,aAAa,EACbC,WAAW,EACXC,YAAY,EACZC,KAAMnf,MAAMof,aAGhBlf,KAAKmf,kBAAoB,IAAIrf,MAAMsf,kBAAkB,CACjDT,MAAOP,EACPQ,QAASR,EACTS,QAAS,EACTC,aAAa,EACbC,WAAW,EACXC,YAAY,EACZC,KAAMnf,MAAMof,aAIpBtS,EAAiBlN,UAAU2f,YAAczS,EACzC,IAAI0S,EAAQ1S,EAAiBlN,UAG7B4f,EAAMC,OAAS,WAEX,IAAIC,EAAaxf,KAAK0W,QAAQxI,gBAEzB6P,EAAe/d,KAAKue,uBAAwBiB,EAAW1U,eAAgB9C,IACxEhI,KAAKyf,aAAaxB,GAGtBje,KAAKyf,aAAavB,GAEdsB,EAAWE,aAGX1f,KAAK0W,QAAQ7J,uBACZ2S,EAAWtQ,aAAelP,KAAK0W,QAAQ5J,wBACxC9M,KAAK2f,eAAeH,GAExBxf,KAAK4f,gBAAgBJ,GAErBxf,KAAKue,uBAAyBiB,EAAW1U,eAAeR,UAG5DgV,EAAMO,cAAgB,SAASC,GAE3B9f,KAAKa,OAAO+O,KAAK6P,aAAaK,GAC9B9f,KAAKa,OAAO+O,KAAKmQ,mBAAmBD,IAIxCR,EAAMG,aAAe,SAASK,GAE1B9f,KAAK6f,cAAcC,GACnB9f,KAAKa,OAAO+O,KAAK4O,mBAAmBsB,IAIxCR,EAAMU,cAAgB,WAElBhgB,KAAK6f,cAAc5B,GACnBje,KAAKa,OAAO+O,KAAK4O,mBAAmBP,GAEpCje,KAAK6f,cAAc3B,GACnBle,KAAKa,OAAO+O,KAAK4O,mBAAmBN,GAEpCle,KAAKue,uBAAyB,MAIlCe,EAAMW,WAAa,SAASH,EAAanQ,GAErC3P,KAAKa,OAAO+O,KAAKqQ,WAAWH,EAAanQ,IAS7C2P,EAAMY,SAAW,SAAS1N,EAAM2N,EAAUL,GAEtC,IAAIM,EAAe,IAAItgB,MAAMugB,KAAK7N,EAAM2N,GAAU,GAE9CL,IAAgB7B,IAChBje,KAAKse,YAnHM,GAsHfte,KAAKigB,WAAWH,EAAaM,IAIjCd,EAAMgB,aAAe,SAASC,EAAQC,EAAQL,EAAUta,GAEpD,IAAI4a,GAAY,IAAI3gB,MAAMmJ,SAAUE,WAAWqX,EAAQD,GACnDG,EAAc,IAAI5gB,MAAM6X,QAC5B+I,EAAYC,OAAOJ,EAAQC,GAAQ,IAAI1gB,MAAM8gB,UAAWC,IACxDH,EAAY7Y,UAAS,IAAI/H,MAAM6X,SAAUzE,IAAI,EAAG,EAAG,EAAG,EAClD,EAAG,EAAG,EAAG,EACT,GAAIuN,EAAUre,SAAU,EAAG,EAC3B,EAAG,EAAG,EAAG,IAEbyD,EAAQA,GAAS,GACjB,IAAIib,EAAW,IAAIhhB,MAAMihB,iBAAiBlb,EAAOA,EAAO,EAAK,EAAG,GAAG,GAC/D+P,EAAO,IAAI9V,MAAMugB,KAAKS,EAAUX,GAOpC,OANAW,EAAW,KAEXlL,EAAK1D,YAAYwO,GACjB9K,EAAK/C,SAAS7O,GAAKwc,EAAOxc,EAAIuc,EAAOvc,GAAK,EAC1C4R,EAAK/C,SAAS3O,GAAKsc,EAAOtc,EAAIqc,EAAOrc,GAAK,EAC1C0R,EAAK/C,SAAS5P,GAAKud,EAAOvd,EAAIsd,EAAOtd,GAAK,EACnC2S,GAIX0J,EAAMK,eAAiB,SAASH,GAE5B,IAAIzB,EAAe/d,KAAKue,uBAAwBiB,EAAW1U,eAAgB9C,GAI3E,OAAQwX,EAAW7Y,UACf,KAAKsB,EAASkJ,YACTlJ,EAASiR,aACVlZ,KAAKghB,UAAUxB,EAAW1R,WAAY9N,KAAKye,iBAAkBR,GAC7D,MAEJ,KAAKhW,EAAS2J,UACd,KAAK3J,EAAS0J,gBACd,KAAK1J,EAASwJ,iBACd,KAAKxJ,EAASoS,cACVra,KAAKihB,SAASzB,EAAW5R,SAAU5N,KAAKye,iBA1J3B,GA0JiER,GAC9E,MAEJ,KAAKhW,EAAS8J,UACd,KAAK9J,EAAS6J,gBACV9R,KAAKkgB,SAASV,EAAW/P,SAAUzP,KAAKye,iBAAkBR,KAKtEqB,EAAM4B,sBAAwB,SAAS1B,GAEnC,IAAI2B,EAAMpZ,EAAcqZ,sBAAsB5B,EAAYxf,KAAKa,QAE3DuB,EAtKa,IAqKLpC,KAAKqhB,SAASF,GAGtBG,EAAWthB,KAAKa,OAAO4Z,WAAW8G,uBAAuBpE,eAAe/a,GACxEof,EAAQxhB,KAAKa,OAAO4Z,WAAWgH,oBAAoBtE,eAAe/a,GAElEoQ,EAAO,IAAI1S,MAAM2S,SACjB7S,EAAI,IAAIE,MAAMmJ,QAGlBrJ,EAAEga,WAAWuH,EAAKG,GAClB1hB,EAAEga,WAAWha,EAAG4hB,GAChBhP,EAAKhB,SAAS,GAAK5R,EAAE0K,QACrB1K,EAAEuJ,WAAWgY,EAAKG,GAClB1hB,EAAEga,WAAWha,EAAG4hB,GAChBhP,EAAKhB,SAAS,GAAK5R,EAAE0K,QACrBtK,KAAKihB,SAASzO,EAAMxS,KAAKmf,kBAtLH,GAsL2CjB,GAGjEte,EAAEga,WAAWuH,EAAKG,GAClB1hB,EAAEuJ,WAAWvJ,EAAG4hB,GAChBhP,EAAKhB,SAAS,GAAK5R,EAAE0K,QACrB1K,EAAEuJ,WAAWgY,EAAKG,GAClB1hB,EAAEuJ,WAAWvJ,EAAG4hB,GAChBhP,EAAKhB,SAAS,GAAK5R,EAAE0K,QACrBtK,KAAKihB,SAASzO,EAAMxS,KAAKmf,kBA/LH,GA+L2CjB,GAGjEte,EAAEuJ,WAAWgY,EAAKG,GAClB1hB,EAAEuJ,WAAWvJ,EAAG4hB,GAChBhP,EAAKhB,SAAS,GAAK5R,EAAE0K,QACrB1K,EAAEuJ,WAAWgY,EAAKG,GAClB1hB,EAAEga,WAAWha,EAAG4hB,GAChBhP,EAAKhB,SAAS,GAAK5R,EAAE0K,QACrBtK,KAAKihB,SAASzO,EAAMxS,KAAKmf,kBAxMH,GAwM2CjB,GAGjEte,EAAEga,WAAWuH,EAAKG,GAClB1hB,EAAEuJ,WAAWvJ,EAAG4hB,GAChBhP,EAAKhB,SAAS,GAAK5R,EAAE0K,QACrB1K,EAAEga,WAAWuH,EAAKG,GAClB1hB,EAAEga,WAAWha,EAAG4hB,GAChBhP,EAAKhB,SAAS,GAAK5R,EAAE0K,QACrBtK,KAAKihB,SAASzO,EAAMxS,KAAKmf,kBAjNH,GAiN2CjB,IAIrEoB,EAAMoC,wBAA0B,SAASlC,GAErC,IAAI2B,EAAM3B,EAAW1R,WAEjB1L,EAxNa,IAuNLpC,KAAKqhB,SAASF,GAGtBG,EAAWthB,KAAKa,OAAO4Z,WAAW8G,uBAAuBpE,eAAe/a,GACxEof,EAAQxhB,KAAKa,OAAO4Z,WAAWgH,oBAAoBtE,eAAe/a,GAElEoQ,EAAO,IAAI1S,MAAM2S,SACjB7S,EAAI,IAAIE,MAAMmJ,QAGlBrJ,EAAEga,WAAWuH,EAAKG,GAClB1hB,EAAEuJ,WAAWvJ,EAAG4hB,GAChBhP,EAAKhB,SAAS,GAAK5R,EAAE0K,QACrB1K,EAAEuJ,WAAWgY,EAAKG,GAClB1hB,EAAEuJ,WAAWvJ,EAAG4hB,GAChBhP,EAAKhB,SAAS,GAAK5R,EAAE0K,QACrBtK,KAAKihB,SAASzO,EAAMxS,KAAKmf,kBAxOH,GAwO2CjB,GAGjEte,EAAEuJ,WAAWgY,EAAKG,GAClB1hB,EAAEuJ,WAAWvJ,EAAG4hB,GAChBhP,EAAKhB,SAAS,GAAK5R,EAAE0K,QACrB1K,EAAEga,WAAWuH,EAAKK,GAClBhP,EAAKhB,SAAS,GAAK5R,EAAE0K,QACrBtK,KAAKihB,SAASzO,EAAMxS,KAAKmf,kBAhPH,GAgP2CjB,GAGjEte,EAAEga,WAAWuH,EAAKG,GAClB1hB,EAAEuJ,WAAWvJ,EAAG4hB,GAChBhP,EAAKhB,SAAS,GAAK5R,EAAE0K,QACrB1K,EAAEga,WAAWuH,EAAKK,GAClBhP,EAAKhB,SAAS,GAAK5R,EAAE0K,QACrBtK,KAAKihB,SAASzO,EAAMxS,KAAKmf,kBAxPH,GAwP2CjB,IAIrEoB,EAAMqC,oBAAsB,SAASnC,GAEjC,IAAI2B,EAAMpZ,EAAcqZ,sBAAsB5B,EAAYxf,KAAKa,QAE3DuB,EA/Pa,IA8PLpC,KAAKqhB,SAASF,GAGtBG,EAAWthB,KAAKa,OAAO4Z,WAAW8G,uBAAuBpE,eAAe/a,GACxEof,EAAQxhB,KAAKa,OAAO4Z,WAAWgH,oBAAoBtE,eAAe/a,GAElEoQ,EAAO,IAAI1S,MAAM2S,SACjB7S,EAAI,IAAIE,MAAMmJ,QAGlBrJ,EAAEga,WAAWuH,EAAKG,GAClB1hB,EAAEuJ,WAAWvJ,EAAG4hB,GAChBhP,EAAKhB,SAAS,GAAK5R,EAAE0K,QACrBkI,EAAKhB,SAAS,GAAK2P,EAAI7W,QACvBtK,KAAKihB,SAASzO,EAAMxS,KAAKmf,kBA7QH,GA6Q2CjB,GAGjEte,EAAEuJ,WAAWgY,EAAKG,GAClB1hB,EAAEuJ,WAAWvJ,EAAG4hB,GAChBhP,EAAKhB,SAAS,GAAK5R,EAAE0K,QACrBkI,EAAKhB,SAAS,GAAK2P,EAAI7W,QACvBtK,KAAKihB,SAASzO,EAAMxS,KAAKmf,kBApRH,GAoR2CjB,GAGjEte,EAAEga,WAAWuH,EAAKK,GAClBhP,EAAKhB,SAAS,GAAK5R,EAAE0K,QACrBkI,EAAKhB,SAAS,GAAK2P,EAAI7W,QACvBtK,KAAKihB,SAASzO,EAAMxS,KAAKmf,kBA1RH,GA0R2CjB,IAIrEoB,EAAMsC,sBAAwB,SAASpC,GAEnC,IAAI2B,EAAMpZ,EAAcqZ,sBAAsB5B,EAAYxf,KAAKa,QAC/Db,KAAK6hB,WAAWV,EAAKnhB,KAAKmf,kBAAmBjB,IAIjDoB,EAAMwC,oBAAsB,SAAStC,GAEjC,IAAI2B,EAAMpZ,EAAcqZ,sBAAsB5B,EAAYxf,KAAKa,QAE3DuB,EAxSa,IAuSLpC,KAAKqhB,SAASF,GAGtBG,EAAWthB,KAAKa,OAAO4Z,WAAW8G,uBAAuBpE,eAAe/a,GACxEof,EAAQxhB,KAAKa,OAAO4Z,WAAWgH,oBAAoBtE,eAAe/a,GAElEoQ,EAAO,IAAI1S,MAAM2S,SACjB7S,EAAI,IAAIE,MAAMmJ,QAGlBuJ,EAAKhB,SAAS,GAAK2P,EAAI7W,QACvB1K,EAAEuJ,WAAWgY,EAAKG,GAClB9O,EAAKhB,SAAS,GAAK5R,EAAE0K,QACrBtK,KAAKihB,SAASzO,EAAMxS,KAAKmf,kBArTH,GAqT2CjB,GAGjEte,EAAEga,WAAWuH,EAAKG,GAClB1hB,EAAEuJ,WAAWvJ,EAAG4hB,GAChBhP,EAAKhB,SAAS,GAAK5R,EAAE0K,QACrB1K,EAAEuJ,WAAWgY,EAAKG,GAClB1hB,EAAEuJ,WAAWvJ,EAAG4hB,GAChBhP,EAAKhB,SAAS,GAAK5R,EAAE0K,QACrBtK,KAAKihB,SAASzO,EAAMxS,KAAKmf,kBA9TH,GA8T2CjB,GAGjEte,EAAEuJ,WAAWgY,EAAKG,GAClB1hB,EAAEuJ,WAAWvJ,EAAG4hB,GAChBhP,EAAKhB,SAAS,GAAK5R,EAAE0K,QACrB1K,EAAEuJ,WAAWgY,EAAKG,GAClB1hB,EAAEga,WAAWha,EAAG4hB,GAChBhP,EAAKhB,SAAS,GAAK5R,EAAE0K,QACrBtK,KAAKihB,SAASzO,EAAMxS,KAAKmf,kBAvUH,GAuU2CjB,GAGjE1L,EAAKhB,SAAS,GAAK2P,EAAI7W,QACvB1K,EAAEuJ,WAAWgY,EAAKK,GAClBhP,EAAKhB,SAAS,GAAK5R,EAAE0K,QACrBtK,KAAKihB,SAASzO,EAAMxS,KAAKmf,kBA7UH,GA6U2CjB,IAIrEoB,EAAMyC,qBAAuB,SAASvC,GAElC,IAAI2B,EAAMpZ,EAAcqZ,sBAAsB5B,EAAYxf,KAAKa,QAE3DuB,EApVa,IAmVLpC,KAAKqhB,SAASF,GAGtBG,EAAWthB,KAAKa,OAAO4Z,WAAW8G,uBAAuBpE,eAAe/a,GACxEof,EAAQxhB,KAAKa,OAAO4Z,WAAWgH,oBAAoBtE,eAAe/a,GAElEoQ,EAAO,IAAI1S,MAAM2S,SACjB7S,EAAI,IAAIE,MAAMmJ,QAGlBrJ,EAAEuJ,WAAWgY,EAAKG,GAClB1hB,EAAEga,WAAWha,EAAE4hB,GACfhP,EAAKhB,SAAS,GAAK5R,EAAE0K,QACrBkI,EAAKhB,SAAS,GAAK2P,EAAI7W,QACvBtK,KAAKihB,SAASzO,EAAMxS,KAAKmf,kBAlWH,GAkW2CjB,GAGjEte,EAAEga,WAAWuH,EAAKG,GAClB1hB,EAAEga,WAAWha,EAAE4hB,GACfhP,EAAKhB,SAAS,GAAK5R,EAAE0K,QACrBkI,EAAKhB,SAAS,GAAK2P,EAAI7W,QACvBtK,KAAKihB,SAASzO,EAAMxS,KAAKmf,kBAzWH,GAyW2CjB,GAGjEte,EAAEga,WAAWuH,EAAKG,GAClB1hB,EAAEuJ,WAAWvJ,EAAG4hB,GAChBhP,EAAKhB,SAAS,GAAK5R,EAAE0K,QACrBkI,EAAKhB,SAAS,GAAK2P,EAAI7W,QACvBtK,KAAKihB,SAASzO,EAAMxS,KAAKmf,kBAhXH,GAgX2CjB,GAGjEte,EAAEuJ,WAAWgY,EAAKG,GAClB1hB,EAAEuJ,WAAWvJ,EAAG4hB,GAChBhP,EAAKhB,SAAS,GAAK5R,EAAE0K,QACrBkI,EAAKhB,SAAS,GAAK2P,EAAI7W,QACvBtK,KAAKihB,SAASzO,EAAMxS,KAAKmf,kBAvXH,GAuX2CjB,IAKrEoB,EAAMM,gBAAkB,SAASJ,GAE7B,GAAIA,EAAWjF,gBACXva,KAAK8hB,oBAAoBtC,QAI7B,OAAQA,EAAW7Y,UACf,KAAKsB,EAASkJ,YAId,KAAKlJ,EAASwR,kBACVzZ,KAAKkhB,sBAAsB1B,GAC3B,MAEJ,KAAKvX,EAASoS,cACVra,KAAK0hB,wBAAwBlC,GAC7B,MAEJ,KAAKvX,EAAS+R,mBACVha,KAAK4hB,sBAAsBpC,GAC3B,MAEJ,KAAKvX,EAAS2J,UACd,KAAK3J,EAAS0J,gBACV3R,KAAK2hB,oBAAoBnC,GACzB,MAEJ,KAAKvX,EAASwJ,iBACNzR,KAAKa,OAAO+N,MAAMoT,OAClBhiB,KAAKkhB,sBAAsB1B,GAE3Bxf,KAAK4hB,sBAAsBpC,GAE/B,MAEJ,KAAKvX,EAAS8J,UACd,KAAK9J,EAAS6J,gBACV9R,KAAKkhB,sBAAsB1B,GAC3B,MAEJ,KAAKvX,EAASiR,aACVlZ,KAAK+hB,qBAAqBvC,KAKtCF,EAAM2B,SAAW,SAASzO,EAAM2N,EAAUta,EAAOia,GAGzCA,IAAgB7B,IAChBje,KAAKse,YAvbM,GA0bf,IAAK,IAAIxgB,EAAI,EAAGA,EAAI0U,EAAKhB,SAASpP,OAAQtE,GAAK,EAAG,CAC9C,IAAIgjB,EAAW9gB,KAAKsgB,aAAa9N,EAAKhB,SAAS1T,GAAI0U,EAAKhB,SAAS1T,EAAI,GAAIqiB,EAAUta,GACnF7F,KAAKiiB,aAAanB,GAClB9gB,KAAKigB,WAAWH,EAAagB,KAIrCxB,EAAM0B,UAAY,SAAShe,EAAOmd,EAAUL,GAGxC,IAAI9f,KAAKa,OAAO+N,MAAMS,UAAU6S,UAAhC,CAIK/D,IACDA,EAAS,IAAIre,MAAMqiB,eAAe,IAEtC,IAAIC,EAAY,IAAItiB,MAAMugB,KAAKlC,EAAQgC,GACvCiC,EAAUvP,SAASK,IAAIlQ,EAAMgB,EAAGhB,EAAMkB,EAAGlB,EAAMC,GAE/CjD,KAAKqiB,cAAcD,GAEftC,IAAgB7B,IAChBje,KAAKse,YAhdO,GAmdhBte,KAAKigB,WAAWH,EAAasC,KAIjC9C,EAAMuC,WAAa,SAAS7e,EAAOmd,EAAUL,GAEzC,IAAIwC,EAAQ,IAAIxiB,MAAMyiB,cAldL,IADK,GAmdmD,EAAG,IACxEC,EAAY,IAAI1iB,MAAMugB,KAAKiC,EAAOnC,GACtCqC,EAAU7B,OAAO3gB,KAAKa,OAAO4Z,WAAWK,eAAehK,aACvDwR,EAAQ,KAERE,EAAU3P,SAASK,IAAIlQ,EAAMgB,EAAGhB,EAAMkB,EAAGlB,EAAMC,GAE/CjD,KAAKyiB,eAAeD,GAEpBxiB,KAAKigB,WAAWH,EAAa0C,IAIjClD,EAAM+B,SAAW,SAAUre,GAEvB,IAEIwX,EAASxa,KAAKa,OAAO4Z,WACrBC,EAASF,EAAOG,YAChB9H,EAAW2H,EAAOI,cAElBhb,EAAIoD,EAAMsH,QAEVxB,EAAW4R,EAAOG,cAAgBjb,EAAEyX,IAAIxE,GAAUzQ,SAChDoY,EAAOM,eAAe1Y,SAExB2Y,EAAMP,EAAOQ,iBAMjB,OAjBgB,GAYE,EAAMlS,EAAW1H,KAAK8Z,IAAIpb,MAAMsB,KAAK+Z,SAAe,GAANJ,KAEjDP,EAAOa,oBACyBvV,QAMnDwZ,EAAM+C,cAAgB,SAAUD,GAE5B,IAAIM,EAAQ1iB,KAAKqhB,SAASe,EAAUvP,UACpCuP,EAAUM,MAAM1e,EAAI0e,EACpBN,EAAUM,MAAMxe,EAAIwe,EACpBN,EAAUM,MAAMzf,EAAIyf,GAIxBpD,EAAMmD,eAAiB,SAAUD,GAE7B,IAAIE,EAAQ1iB,KAAKqhB,SAASmB,EAAU3P,UACpC2P,EAAUE,MAAM1e,EAAI0e,EACpBF,EAAUE,MAAMxe,EAAIwe,GAGxBpD,EAAM2C,aAAe,SAAU3B,GAE3B,IAAIoC,EAAQ1iB,KAAKqhB,SAASf,EAAazN,UACvCyN,EAAaoC,MAAM1e,EAAI0e,EACvBpC,EAAaoC,MAAMzf,EAAIyf,GAG3BpD,EAAMqD,iBAAmB,SAAS7C,GAE9B,GAthBgB,GAshBZ9f,KAAKse,YAAT,CAGA,IAAIsE,EAAU5iB,KAAKa,OAAO+O,KAAKiT,cAAc/C,GAC7C,GAAI8C,EAGA,IAFA,IAAIE,EAAQF,EAAQE,MAEXhlB,EAAI,EAAGA,EAAIglB,EAAMC,SAAS3gB,OAAQtE,IAAK,CAC5C,IAAIskB,EAAYU,EAAMC,SAASjlB,GAC3BskB,GAEApiB,KAAKqiB,cAAcD,MAMnC9C,EAAM0D,gBAAkB,SAASlD,GAE7B,GA1iBe,GA0iBX9f,KAAKse,YAAT,CAGA,IAAIsE,EAAU5iB,KAAKa,OAAO+O,KAAKiT,cAAc/C,GAC7C,GAAI8C,EAGA,IAFA,IAAIE,EAAQF,EAAQE,MAEXhlB,EAAI,EAAGA,EAAIglB,EAAMC,SAAS3gB,OAAQtE,IAAK,CAC5C,IAAIwiB,EAAewC,EAAMC,SAASjlB,GAC9BwiB,GAEAtgB,KAAKiiB,aAAa3B,MAMlChB,EAAM2D,eAAiB,WAEnBjjB,KAAK2iB,iBAAiB1E,GACtBje,KAAKgjB,gBAAgB/E,GAGjBje,KAAKuf,UAIbD,EAAM/R,QAAU,WAEZvN,KAAK6f,cAAc5B,GACnBje,KAAK6f,cAAc3B,GAEfC,IACAA,EAAO+E,UACP/E,EAAS,Q,6CCllBd,SAASgF,IACZ,MAA0B,oBAAXhjB,QAAqC,OAAXA,OAC/BA,OACiB,oBAATijB,MAAiC,OAATA,KAC5BA,KACAC,E,kCAGlB,IAAMC,EAAUH,IACVI,EAAYD,GAAWA,EAAQE,SAExBC,EAAkC,oBAAdC,UAMtBC,EAASF,KAAeC,UAAUE,UAAUC,MAAM,qBAGxC,oBAAX1jB,QAA0BwjB,GAChC,WACI,SAASG,EAAcrI,EAAOsI,GAC1BA,EAASA,GAAU,CAAEC,SAAS,EAAOC,YAAY,EAAOC,YAAQjV,GAChE,IAAIkV,EAAMZ,EAAUa,YAAa,eAEjC,OADAD,EAAIE,gBAAiB5I,EAAOsI,EAAOC,QAASD,EAAOE,WAAYF,EAAOG,QAC/DC,EAGXL,EAAYpkB,UAAY4jB,EAAQQ,YAAYpkB,UAE5C4jB,EAAQQ,YAAcA,EAV1B,GAeCQ,YAAY5kB,UAAUmU,QACvByQ,YAAY5kB,UAAUmU,MAAQ,SAAS7O,EAAOC,GAc1C,IAZKA,GAAOA,EAAMjF,KAAKukB,WACnBtf,EAAMjF,KAAKukB,WAENtf,EAAM,IACXA,EAAMjF,KAAKukB,WAAatf,GACd,IAAGA,EAAM,GAEnBD,EAAQ,IACRA,EAAQhF,KAAKukB,WAAavf,GACd,IAAGA,EAAQ,GAGvBC,GAAOD,EACP,OAAO,IAAIsf,YAOf,IAHA,IAAIE,EAAMvf,EAAMD,EACZyf,EAAO,IAAIC,WAAW1kB,KAAMgF,EAAOwf,GACnCG,EAAM,IAAID,WAAWF,GAChB1mB,EAAI,EAAGA,EAAI0mB,EAAK1mB,IACrB6mB,EAAI7mB,GAAK2mB,EAAK3mB,GAElB,OAAO6mB,EAAIljB,SAMfL,KAAKwjB,KAAOxjB,KAAKwjB,MAAQ,SAAS5gB,GAC9B,OAAO5C,KAAKyjB,IAAI7gB,GAAK5C,KAAK0jB,KAKZ,oBAAX3kB,SACPmjB,EAAQyB,YAAczB,EAAQyB,aAAezB,EAAQ0B,mBAAqB1B,EAAQ2B,gBAAkB3B,EAAQ4B,eA6EhH,IAAMC,EAAe1B,IAAc,iBAAiB2B,KAAK1B,UAAUE,UAAUyB,gBAA0C,aAAvB3B,UAAU4B,UAA2B5B,UAAU6B,eAAiB,GACzJ,SAASC,IACZ,OAAOL,EAGX,IAAMM,EAAmBhC,IAAwE,IAA1DC,UAAUE,UAAUyB,cAAcle,QAAQ,WAK1E,SAAS6F,IACZ,QAAKyW,IACE+B,KALAC,IAgHX,WACI,IAAIpC,EAASF,IACRE,EAAOqC,cACRrC,EAAOqC,YAAcC,MAH7B,GAQAxZ,OAAOyZ,UAAYzZ,OAAOyZ,WAAa,SAAS7mB,GAC5C,MAAwB,iBAAVA,GACV8mB,SAAS9mB,IACTqC,KAAK0kB,MAAM/mB,KAAWA,GAI9BgnB,OAAOrmB,UAAUsmB,OAASD,OAAOrmB,UAAUsmB,QAAU,SAAS1S,GAC1D,GAAIA,EAAQ,EAAG,MAAO,GAEtB,IADA,IAAInI,EAAS,GAAI8a,EAAUjmB,KAAKkmB,UACzB5S,EAAQ,GACC,EAARA,IAAWnI,GAAU8a,GACzB3S,IAAU,EAAG2S,GAAWA,EAE5B,OAAO9a,EAAS8a,GAKfrN,MAAMlZ,UAAUymB,MACjB3nB,OAAOC,eAAema,MAAMlZ,UAAW,OAAQ,CAC3ChB,YAAY,EACZK,MAAO,SAASA,EAAOiG,EAAOC,GAC1BD,OAAmBiK,IAAVjK,EAAuB,EAAIA,EACpCC,OAAegK,IAARhK,EAAqBjF,KAAKoC,OAAS6C,EAC1C,IAAK,IAAInH,EAAEkH,EAAOlH,EAAEmH,IAAOnH,EACvBkC,KAAKlC,GAAKiB,KAK1B8C,WAAWnC,UAAU0mB,YAAcvkB,WAAWnC,UAAU0mB,aAAe,SAASC,EAAeC,GAC3F,OAAO1N,MAAMlZ,UAAU0mB,YAAYnoB,KAAK+B,KAAMqmB,EAAeC,IAK5D1N,MAAMlZ,UAAU6mB,MACjB/nB,OAAOC,eAAema,MAAMlZ,UAAW,OAAQ,CAC3ChB,YAAY,EACZK,MAAO,SAAS6E,EAAU4iB,GAEtB,IADA,IAAIhC,EAAMxkB,KAAKoC,OACNtE,EAAE,EAAGA,EAAE0mB,IAAO1mB,EAAG,CACtB,IAAI2oB,EAAOzmB,KAAKlC,GAChB,GAAI8F,EAAS3F,KAAKuoB,EAAOC,EAAM3oB,EAAGkC,MAC9B,OAAOymB,MAQC,mBAAjBjoB,OAAOkoB,QAEdloB,OAAOC,eAAeD,OAAQ,SAAU,CACpCO,MAAO,SAAgB4nB,EAAQC,GAE3B,GAAc,MAAVD,EACA,MAAM,IAAIE,UAAU,8CAKxB,IAFA,IAAIC,EAAKtoB,OAAOmoB,GAEPhU,EAAQ,EAAGA,EAAQoU,UAAU3kB,OAAQuQ,IAAS,CACnD,IAAIqU,EAAaD,UAAUpU,GAE3B,GAAkB,MAAdqU,EACA,IAAK,IAAIC,KAAWD,EAEZxoB,OAAOkB,UAAUC,eAAe1B,KAAK+oB,EAAYC,KACjDH,EAAGG,GAAWD,EAAWC,IAKzC,OAAOH,GAEXI,UAAU,EACVC,cAAc,IAKA,oBAAXhnB,SAA2BwjB,IAAU6B,KAAmB4B,kBAAkB1nB,UAAU2nB,QAC3F7oB,OAAOC,eAAe2oB,kBAAkB1nB,UAAW,SAAU,CACzDX,MAAO,SAAU6E,EAAUkG,EAAMwd,GACjC,IAAIC,EAASvnB,KACbwnB,YAAW,WAMP,IAJA,IAAIC,EAASC,KAAMH,EAAOI,UAAU7d,EAAMwd,GAASM,MAAM,KAAK,IAC1DpD,EAAMiD,EAAOrlB,OACbylB,EAAM,IAAInD,WAAWF,GAEhB1mB,EAAI,EAAGA,EAAI0mB,EAAK1mB,IACzB+pB,EAAI/pB,GAAK2pB,EAAOK,WAAWhqB,GAG3B8F,EAAU,IAAImkB,KAAM,CAACF,GAAM,CAAC/d,KAAMA,GAAQ,qBAQjD4a,WAAWhlB,UAAUmU,QAMxB6Q,WAAWhlB,UAAUmU,MAAQ,SAASmU,EAAO/iB,GAK3C,GAHAA,OAAsB,IAARA,EAAuBA,EAAMjF,KAAKoC,OAGH,mBAAzC5D,OAAOkB,UAAUuoB,SAAShqB,KAAK+B,MACjC,OAAOkoB,OAAOjqB,KAAK+B,KAAMgoB,EAAO/iB,GAIlC,IAAInH,EACFqqB,EADKC,EAAS,GACR5D,EAAMxkB,KAAKoC,OAGf4C,EAAQgjB,GAAS,EACrBhjB,EAASA,GAAS,EAAKA,EAAQ5D,KAAKiD,IAAI,EAAGmgB,EAAMxf,GAGjD,IAAIqjB,EAAsB,iBAAPpjB,EAAmB7D,KAAKknB,IAAIrjB,EAAKuf,GAAOA,EAQ3D,GAPIvf,EAAM,IACRojB,EAAO7D,EAAMvf,IAIfkjB,EAAOE,EAAOrjB,GAEH,EAET,GADAojB,EAAS,IAAIxP,MAAMuP,GACfnoB,KAAKuoB,OACP,IAAKzqB,EAAI,EAAGA,EAAIqqB,EAAMrqB,IACpBsqB,EAAOtqB,GAAKkC,KAAKuoB,OAAOvjB,EAAQlH,QAGlC,IAAKA,EAAI,EAAGA,EAAIqqB,EAAMrqB,IACpBsqB,EAAOtqB,GAAKkC,KAAKgF,EAAQlH,GAK/B,OAAOsqB,M","file":"Snapping/Snapping.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 314);\n","module.exports = THREE;","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","\nvar av = Autodesk.Viewing;\n\n/**\n * @namespace Autodesk.Viewing.Extensions.Snapping\n */\nvar namespace = AutodeskNamespace('Autodesk.Viewing.Extensions.Snapping');\n\nfunction _export(m, ns) {\n    for (var prop in m) {\n        if (m.hasOwnProperty(prop)) {\n            //Export directly into the module (e.g. for node.js use, where LMV is used via require instead from global namespace)\n            module.exports[prop] = m[prop];\n\n            //Export into the desired viewer namespace\n            ns[prop] = m[prop];\n        }\n    }\n}\n\n_export(require(\"./SnapMath.js\"), namespace);\n_export(require(\"./Snapper.js\"), namespace);\n_export(require(\"./SnapperIndicator.js\"), namespace);\n\n\n/**\n * Utility extension that provides access to the {@link Autodesk.Viewing.Extensions.Snapping.Snapper} tool.\n * \n * The extension id is: `Autodesk.Snapping`\n * \n * @example\n *   viewer.loadExtension('Autodesk.Snapping')\n *  \n * @memberof Autodesk.Viewing.Extensions\n * @alias Autodesk.Viewing.Extensions.SnappingExtension\n * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n * @class\n*/\nclass SnappingExtension extends av.Extension {\n\n    /**\n     * @alias Autodesk.Viewing.Extensions.SnappingExtension\n     * @constructor\n     */\n    constructor(viewer, options) {\n        super(viewer, options);\n    }\n\n    /**\n     * Load the extension.\n     *\n     * @returns {Promise} that resolves when dependent extension finishes loading.\n     * \n     * @alias Autodesk.Viewing.Extensions.SnappingExtension#load\n    */\n    load() { \n        // Load the required dependency (and return the pending load as the load completion Promise)\n        return this.viewer.loadExtension('Autodesk.CompGeom');\n    }\n\n    /**\n     * Unloads the extension.\n     * It does not unload dependent extensions.\n     *\n     * @returns {boolean} Always returns true\n     * \n     * @alias Autodesk.Viewing.Extensions.SnappingExtension#unload\n    */\n    unload() { return true; }\n\n\n    /**\n     * Unused method.\n     *\n     * @returns {boolean} Always returns true\n     * \n     * @alias Autodesk.Viewing.Extensions.SnappingExtension#activate\n    */\n    activate() { return true; }\n\n    /**\n     * Unused method.\n     *\n     * @returns {boolean} Always returns false\n     * \n     * @alias Autodesk.Viewing.Extensions.SnappingExtension#deactivate\n    */\n    deactivate() { return false; }\n}\n\n// The ExtensionManager requires an extension to be registered.\nav.theExtensionManager.registerExtension('Autodesk.Snapping', SnappingExtension);\n\n","\n\"use strict\";\n\nimport * as THREE from \"three\";\n\nvar TAU = Math.PI * 2;\n\n//Constants duplicated from src/lmvtk/VertexBufferBuilder.js\nvar VBB_GT_TRIANGLE_INDEXED = 0,\n    VBB_GT_LINE_SEGMENT     = 1,\n    VBB_GT_ARC_CIRCULAR     = 2,\n    VBB_GT_ARC_ELLIPTICAL   = 3,\n    VBB_GT_TEX_QUAD         = 4,\n    VBB_GT_ONE_TRIANGLE     = 5;\n\nvar VBB_INSTANCED_FLAG  = 0, // this is intentionally 0 for the instancing case!\n    VBB_SEG_START_RIGHT = 0, // this starts intentionally at 0!\n    VBB_SEG_START_LEFT  = 1,\n    VBB_SEG_END_RIGHT   = 2,\n    VBB_SEG_END_LEFT    = 3;\n\nvar VBB_COLOR_OFFSET    = 6,\n    VBB_DBID_OFFSET     = 7,\n    VBB_FLAGS_OFFSET    = 8,\n    VBB_LAYER_VP_OFFSET = 9;\n\n/**\n * Initializes a \"view\" into a compacted interleaved vertex buffer array using our custom 2D vertex layout.\n * See src/lmvtk/VertexBufferBuilder.js for more details.\n */\nexport function VertexBufferReader(geometry)\n{\n    this.vb  = geometry.vb.buffer;\n    this.vbf = new Float32Array(this.vb);\n    this.vbi = new Int32Array(this.vb);\n    this.vbs = new Uint16Array(this.vb);\n\n    this.ib = geometry.ib;\n\n    this.stride = geometry.vbstride;\n    this.vcount = this.vbf.length / this.stride;\n\n    this.useInstancing = geometry.numInstances > 0;\n    this.useCompactBuffers = geometry.unpackXform;\n    this.texData = this.useCompactBuffers && geometry.tIdColor && geometry.tIdColor.image && geometry.tIdColor.image.data && new Uint32Array(geometry.tIdColor.image.data.buffer);\n};\n\nVertexBufferReader.prototype.getDbIdAt = function(vindex) {\n    if(this.texData) {\n        return this.texData[this.vbs[vindex*this.stride * 2 + VBB_DBID_OFFSET]];\n    }\n    return this.vbi[vindex*this.stride + VBB_DBID_OFFSET];\n};\n\nVertexBufferReader.prototype.getColorAt = function(vindex) {\n    if(this.texData) {\n        return this.texData[this.vbs[vindex*this.stride * 2 + VBB_COLOR_OFFSET]];\n    }\n    return this.vbi[vindex*this.stride + VBB_COLOR_OFFSET];\n};\n\nVertexBufferReader.prototype.getVertexFlagsAt = function(vindex) {\n    if(this.texData) {\n        return this.vbi[vindex*this.stride + 4];\n    }\n    return this.vbi[vindex*this.stride + VBB_FLAGS_OFFSET];\n};\n\nVertexBufferReader.prototype.getLayerIndexAt = function(vindex) {\n    if(this.texData) {\n        return this.vbi[vindex*this.stride + 5] & 0xffff;\n    }\n    return this.vbi[vindex*this.stride + VBB_LAYER_VP_OFFSET] & 0xffff;\n};\n\nVertexBufferReader.prototype.getViewportIndexAt = function(vindex) {\n    if(this.texData) {\n        return (this.vbi[vindex*this.stride + 5] >> 16) & 0xffff;\n    }\n    return (this.vbi[vindex*this.stride + VBB_LAYER_VP_OFFSET] >> 16) & 0xffff;\n};\n\nVertexBufferReader.prototype.decodeLineAt = function(vindex, layer, vpId, callback)\n{\n    if (!callback.onLineSegment) { return; }\n\n    if(this.useCompactBuffers) {\n        var vertexOffset = this.stride * vindex * 2;\n        var x0         = ((this.useCompactBuffers.x * this.vbs[vertexOffset]) / 65535) + this.useCompactBuffers.z;\n        var y0         = ((this.useCompactBuffers.y * this.vbs[vertexOffset+1]) / 65535) + this.useCompactBuffers.w;\n        var angle      = ((this.vbs[vertexOffset+2] / 65535) * TAU) - Math.PI;\n        var distAlong  = (this.vbs[vertexOffset+3] / 65535) * Math.max(this.useCompactBuffers.x, this.useCompactBuffers.y);\n        var lineWidth  = (((this.vbs[vertexOffset+4]) / 32767) * Math.max(this.useCompactBuffers.x, this.useCompactBuffers.y)) * 2.0;\n    } else {\n        var baseOffset = this.stride * vindex;\n        var x0         = this.vbf[baseOffset];\n        var y0         = this.vbf[baseOffset+1];\n        var angle      = this.vbf[baseOffset+2] * TAU - Math.PI; // decode angle: see VertexBufferBuilder.addVertexLine\n        var distAlong  = this.vbf[baseOffset+3];\n        var lineWidth  = this.vbf[baseOffset+4] * 2.0;\n    }\n\n    var x1 = x0 + distAlong * Math.cos(angle);\n    var y1 = y0 + distAlong * Math.sin(angle);\n\n    callback.onLineSegment(x0, y0, x1, y1, vpId, lineWidth);\n};\n\nVertexBufferReader.prototype.decodeCircularArcAt = function(vindex, layer, vpId, callback)\n{\n    if (!callback.onCircularArc) { return; }\n\n    if(this.useCompactBuffers) {\n        var vertexOffset = this.stride * vindex * 2;\n        var cx         = ((this.useCompactBuffers.x * this.vbs[vertexOffset]) / 65535) + this.useCompactBuffers.z;\n        var cy         = ((this.useCompactBuffers.y * this.vbs[vertexOffset+1]) / 65535) + this.useCompactBuffers.w;\n        var start      = (this.vbs[vertexOffset+2] / 65535) * TAU;\n        var end        = (this.vbs[vertexOffset+3] / 65535) * TAU;\n        var radius     = (this.vbs[vertexOffset+5] / 65535) * Math.max(this.useCompactBuffers.x, this.useCompactBuffers.y);\n    } else {\n        var baseOffset = this.stride * vindex;\n        var cx         = this.vbf[baseOffset];\n        var cy         = this.vbf[baseOffset+1];\n        var start      = this.vbf[baseOffset+2] * TAU;\n        var end        = this.vbf[baseOffset+3] * TAU;\n        var radius     = this.vbf[baseOffset+5];\n    }\n\n    callback.onCircularArc(cx, cy, start, end, radius, vpId);\n};\n\nVertexBufferReader.prototype.decodeEllipticalArcAt = function(vindex, layer, vpId, callback)\n{\n    if (!callback.onEllipticalArc) { return; }\n\n    // Note: compaction will not happen for the VBB_GT_ARC_ELLIPTICAL\n    var baseOffset = this.stride * vindex;\n    var cx         = this.vbf[baseOffset];\n    var cy         = this.vbf[baseOffset+1];\n    var start      = this.vbf[baseOffset+2] * TAU;\n    var end        = this.vbf[baseOffset+3] * TAU;\n    var major      = this.vbf[baseOffset+5];\n    var minor      = this.vbf[baseOffset+10];\n    var tilt       = this.vbf[baseOffset+11];\n\n    callback.onEllipticalArc(cx, cy, start, end, major, minor, tilt, vpId);\n};\n\nVertexBufferReader.prototype.decodeTexQuadAt = function(vindex, layer, vpId, callback)\n{\n    if (!callback.onTexQuad) { return; }\n\n    if(this.useCompactBuffers) {\n        var vertexOffset = this.stride * vindex * 2;\n        var centerX    = ((this.useCompactBuffers.x * this.vbs[vertexOffset]) / 65535) + this.useCompactBuffers.z;\n        var centerY    = ((this.useCompactBuffers.y * this.vbs[vertexOffset+1]) / 65535) + this.useCompactBuffers.w;\n        var rotation   = (this.vbs[vertexOffset+2] / 65535) * TAU;\n        var width      = (this.vbs[vertexOffset+3] / 65535) * Math.max(this.useCompactBuffers.x, this.useCompactBuffers.y);\n        var height     = (this.vbs[vertexOffset+4] / 65535) * Math.max(this.useCompactBuffers.x, this.useCompactBuffers.y);\n    } else {\n        var baseOffset = this.stride * vindex;\n        var centerX    = this.vbf[baseOffset];\n        var centerY    = this.vbf[baseOffset+1];\n        // yes, this is in a different order than output, following VertexBufferBuilder's order\n        var rotation   = this.vbf[baseOffset+2] * TAU;\n        var width      = this.vbf[baseOffset+3];\n        var height     = this.vbf[baseOffset+4];\n    }\n\n    callback.onTexQuad(centerX, centerY, width, height, rotation, vpId);\n};\n\nVertexBufferReader.prototype.decodeOneTriangleAt = function(vindex, layer, vpId, callback)\n{\n    if (!callback.onOneTriangle) { return; }\n\n    if(this.useCompactBuffers) {\n        var vertexOffset = this.stride * vindex * 2;\n        var x1         = ((this.useCompactBuffers.x * this.vbs[vertexOffset]) / 65535) + this.useCompactBuffers.z;\n        var y1         = ((this.useCompactBuffers.y * this.vbs[vertexOffset+1]) / 65535) + this.useCompactBuffers.w;\n        var x2         = ((this.useCompactBuffers.x * this.vbs[vertexOffset+2]) / 65535) + this.useCompactBuffers.z;\n        var y2         = ((this.useCompactBuffers.y * this.vbs[vertexOffset+3]) / 65535) + this.useCompactBuffers.w;\n        var x3         = ((this.useCompactBuffers.x * this.vbs[vertexOffset+4]) / 65535) + this.useCompactBuffers.z;\n        var y3         = ((this.useCompactBuffers.y * this.vbs[vertexOffset+5]) / 65535) + this.useCompactBuffers.w;\n    } else {\n        var baseOffset = this.stride * vindex;\n        var x1         = this.vbf[baseOffset];\n        var y1         = this.vbf[baseOffset+1];\n        var x2         = this.vbf[baseOffset+2];\n        var y2         = this.vbf[baseOffset+3];\n        var x3         = this.vbf[baseOffset+4];\n        var y3         = this.vbf[baseOffset+5];\n    }\n\n    callback.onOneTriangle(x1, y1, x2, y2, x3, y3, vpId);\n};\n\n\nVertexBufferReader.prototype.decodeTriangleIndexed = function(vi0, vi1, vi2, layer, vpId, callback)\n{\n    if (!callback.onOneTriangle) { return; }\n\n    if(this.useCompactBuffers) {\n        var vertexOffset = this.stride * vi0 * 2;\n        var x1         = ((this.useCompactBuffers.x * this.vbs[vertexOffset]) / 65535) + this.useCompactBuffers.z;\n        var y1         = ((this.useCompactBuffers.y * this.vbs[vertexOffset+1]) / 65535) + this.useCompactBuffers.w;\n\n        vertexOffset   = this.stride * vi1 * 2; \n        var x2         = ((this.useCompactBuffers.x * this.vbs[vertexOffset]) / 65535) + this.useCompactBuffers.z;\n        var y2         = ((this.useCompactBuffers.y * this.vbs[vertexOffset+1]) / 65535) + this.useCompactBuffers.w;\n\n        vertexOffset   = this.stride * vi2 * 2;\n        var x3         = ((this.useCompactBuffers.x * this.vbs[vertexOffset]) / 65535) + this.useCompactBuffers.z;\n        var y3         = ((this.useCompactBuffers.y * this.vbs[vertexOffset+1]) / 65535) + this.useCompactBuffers.w;\n    } else {\n        var baseOffset = this.stride * vi0;\n        var x1         = this.vbf[baseOffset];\n        var y1         = this.vbf[baseOffset+1];\n    \n        baseOffset     = this.stride * vi1;\n        var x2         = this.vbf[baseOffset];\n        var y2         = this.vbf[baseOffset+1];\n    \n        baseOffset     = this.stride * vi2;\n        var x3         = this.vbf[baseOffset];\n        var y3         = this.vbf[baseOffset+1];\n    }\n\n    callback.onOneTriangle(x1, y1, x2, y2, x3, y3, vpId);\n};\n\n\n// used by the snapper and by the bounds finder\nVertexBufferReader.prototype.enumGeomsForObject = function(dbId, callback)\n{\n    if (this.useInstancing) {\n\n        //When instancing is used, each geometry primitive is encoded into a single vertex\n        //and there is no index buffer.\n\n        var i = 0;\n        while (i < this.vcount) {\n            var flag = this.getVertexFlagsAt(i);\n\n            //var vertexId  = (flag >>  0) & 0xff;        //  8 bit\n            var geomType    = (flag >>  8) & 0xff;        //  8 bit\n            //var linePattern = (flag >> 16) & 0xff;      //  8 bit\n            var layerId     = this.getLayerIndexAt(i);    // 16 bit\n            var vpId        = this.getViewportIndexAt(i); // 16 bit     \n            var visible     = this.getDbIdAt(i) === dbId;\n            if (visible) {\n                switch (geomType) {\n                    case VBB_GT_LINE_SEGMENT:        this.decodeLineAt(         i, layerId, vpId, callback); break;\n                    case VBB_GT_ARC_CIRCULAR:        this.decodeCircularArcAt(  i, layerId, vpId, callback); break;\n                    case VBB_GT_ARC_ELLIPTICAL:      this.decodeEllipticalArcAt(i, layerId, vpId, callback); break; //  compaction is not performed\n                    case VBB_GT_TEX_QUAD:            this.decodeTexQuadAt(      i, layerId, vpId, callback); break;\n                    case VBB_GT_ONE_TRIANGLE:        this.decodeOneTriangleAt(  i, layerId, vpId, callback); break;\n                    default:                         break;\n                }\n            }\n\n            //In the case of instancing, there is no vertex duplication and no index buffer, we just\n            //move to the next vertex\n            i += 1;\n        }\n    } else {\n\n        var i = 0;\n        while (i < this.ib.length) {\n            var vi = this.ib[i];\n            var flag = this.getVertexFlagsAt(vi);\n\n            //var vertexId    = (flag >>  0) & 0xff;        //  8 bit\n            var geomType    = (flag >>  8) & 0xff;        //  8 bit\n            //var linePattern = (flag >> 16) & 0xff;        //  8 bit\n            var layerId     = this.getLayerIndexAt(vi);    // 16 bit\n            var vpId        = this.getViewportIndexAt(vi); // 16 bit\n\n            var visible = this.getDbIdAt(vi) === dbId;\n\n            if (geomType === VBB_GT_TRIANGLE_INDEXED) {\n\n                //Triangles are encoded in three vertices (like a simple mesh) instead of 4 like everything else\n\n                if (visible) {\n                    this.decodeTriangleIndexed(this.ib[i], this.ib[i+1], this.ib[i+2], layerId, vpId, callback);\n                }\n\n                //Advance to the next primitive\n                i += 3;\n\n            } else {\n\n                if (visible) {\n                    switch (geomType) {\n                        case VBB_GT_LINE_SEGMENT:        this.decodeLineAt(         vi, layerId, vpId, callback); break;\n                        case VBB_GT_ARC_CIRCULAR:        this.decodeCircularArcAt(  vi, layerId, vpId, callback); break;\n                        case VBB_GT_ARC_ELLIPTICAL:      this.decodeEllipticalArcAt(vi, layerId, vpId, callback); break;\n                        case VBB_GT_TEX_QUAD:            this.decodeTexQuadAt(      vi, layerId, vpId, callback); break;\n                        case VBB_GT_ONE_TRIANGLE:        this.decodeOneTriangleAt(  vi, layerId, vpId, callback); break;\n                        default:                         break;\n                    }\n                }\n\n                //Skip duplicate vertices (when not using instancing and the geometry is not a simple polytriangle,\n                //each vertex is listed four times with a different vertexId flag\n                i += 6;\n            }\n\n\n        }\n    }\n\n};\n\n\n/**\n * Used by the bounds finder.\n * @param {array[number]} layerIdsVisible - list of layer ids that are visible\n * @param {function} callback\n * @private\n */\nVertexBufferReader.prototype.enumGeomsForVisibleLayer = function(layerIdsVisible, callback)\n{\n    var filter = function(dbId, layerId, viewportId) {\n        return !layerIdsVisible || (layerId !== 0 && layerIdsVisible.indexOf(layerId) !== -1);\n    };\n    this.enumGeoms(filter, callback);\n};\n\n\n/**\n * Enumerate all geometric primitives that match the given filter.\n * @param {function} [filter] - function(dbId, layerId, viewportId): Filter function to define a subset of primitives to include. By default, all geometry is included.\n * @param {function} callback\n * @private\n */\nVertexBufferReader.prototype.enumGeoms = function(filter, callback)\n{\n    if (this.useInstancing) {\n\n        //When instancing is used, each geometry primitive is encoded into a single vertex\n        //and there is no index buffer.\n\n        var i = 0;\n        while (i < this.vcount) {\n            var flag = this.getVertexFlagsAt(i);\n\n            //var vertexId    = (flag >>  0) & 0xff;        //  8 bit\n            var geomType    = (flag >>  8) & 0xff;        //  8 bit\n            //var linePattern = (flag >> 16) & 0xff;        //  8 bit\n            var layerId     = this.getLayerIndexAt(i);    // 16 bit\n            var vpId        = this.getViewportIndexAt(i); // 16 bit\n            var dbId        = this.getDbIdAt(i);\n\n            // Get the bounds of only the visible layers. Ignore layer 0, which is always the page.\n            // If layerId visibility is not set, consider the layer visible.\n            var visible = !filter || filter(dbId, layerId, vpId);\n            if (visible) {\n                switch (geomType) {\n                    case VBB_GT_LINE_SEGMENT:        this.decodeLineAt(         i, layerId, vpId, callback); break;\n                    case VBB_GT_ARC_CIRCULAR:        this.decodeCircularArcAt(  i, layerId, vpId, callback); break;\n                    case VBB_GT_ARC_ELLIPTICAL:      this.decodeEllipticalArcAt(i, layerId, vpId, callback); break;\n                    case VBB_GT_TEX_QUAD:            this.decodeTexQuadAt(      i, layerId, vpId, callback); break;\n                    case VBB_GT_ONE_TRIANGLE:        this.decodeOneTriangleAt(  i, layerId, vpId, callback); break;\n                    default:                         break;\n                }\n            }\n\n            //In the case of instancing, there is no vertex duplication and no index buffer, we just\n            //move to the next vertex\n            i += 1;\n        }\n    } else {\n\n        var i = 0;\n        while (i < this.ib.length) {\n            var vi = this.ib[i];\n            var flag = this.getVertexFlagsAt(vi);\n\n            //var vertexId    = (flag >>  0) & 0xff;        //  8 bit\n            var geomType    = (flag >>  8) & 0xff;        //  8 bit\n            //var linePattern = (flag >> 16) & 0xff;        //  8 bit\n            var layerId     = this.getLayerIndexAt(vi);    // 16 bit\n            var vpId        = this.getViewportIndexAt(vi); // 16 bit\n            var dbId        = this.getDbIdAt(vi);\n\n            // Get the bounds of only the visible layers. Ignore layer 0, which is always the page.\n            // If layerId visibility is not set, consider the layer visible.\n            var visible = !filter || filter(dbId, layerId, vpId);\n\n            if (geomType === VBB_GT_TRIANGLE_INDEXED) {\n\n                //Triangles are encoded in three vertices (like a simple mesh) instead of 4 like everything else\n\n                if (visible) {\n                    this.decodeTriangleIndexed(this.ib[i], this.ib[i+1], this.ib[i+2], layerId, vpId, callback);\n                }\n\n                //Advance to the next primitive\n                i += 3;\n\n            } else {\n\n                if (visible) {\n                    switch (geomType) {\n                        case VBB_GT_LINE_SEGMENT:        this.decodeLineAt(         vi, layerId, vpId, callback); break;\n                        case VBB_GT_ARC_CIRCULAR:        this.decodeCircularArcAt(  vi, layerId, vpId, callback); break;\n                        case VBB_GT_ARC_ELLIPTICAL:      this.decodeEllipticalArcAt(vi, layerId, vpId, callback); break;\n                        case VBB_GT_TEX_QUAD:            this.decodeTexQuadAt(      vi, layerId, vpId, callback); break;\n                        case VBB_GT_ONE_TRIANGLE:        this.decodeOneTriangleAt(  vi, layerId, vpId, callback); break;\n                        default:                         break;\n                    }\n                }\n\n                //Skip duplicate vertices (when not using instancing and the geometry is not a simple polytriangle,\n                //each vertex is listed four times with a different vertexId flag\n                i += 6;\n            }\n\n        }\n    }\n\n};\n\n\n\n/**\n * Callback class for calculating bounds of 2D objects via VertexBufferReader\n * @private\n */\nexport function BoundsCallback(bounds) {\n    this.bounds = bounds;\n    // workspace, so we don't reallocate this each time\n    this.point = new THREE.Vector4();\n    this.point.z = 0.0;\n    this.point.w = 1.0; // it's a point, not a vector\n}\n\nBoundsCallback.prototype.onVertex = function(cx, cy, vpId) {\n    this.point.x = cx;\n    this.point.y = cy;\n    this.bounds.expandByPoint( this.point );\n};\n\nBoundsCallback.prototype.onLineSegment = function(x1, y1, x2, y2, vpId) {\n    this.onVertex( x1, y1 );\n    this.onVertex( x2, y2 );\n};\n\nBoundsCallback.prototype.onCircularArc = function(cx, cy, start, end, radius, vpId) {\n    this.onEllipticalArc(cx, cy, start, end, radius, radius, 0.0, vpId);\n};\n\nBoundsCallback.prototype.onEllipticalArc = function(cx, cy, start, end, major, minor, tilt, vpId) {\n    if ( tilt == 0.0 ) {\n        // does start and end make a full ellipse?\n        if ( (start <= 0) && (end >= 2.0 * Math.PI - 0.00001) ) {\n            // full way around, simply treat it like a rectangle\n            this.onTexQuad(cx, cy, 2*major, 2*minor, tilt, vpId);\n        } else {\n            // Not a full ellipse. We take the start and end points and also figure\n            // out the four \"compass rose\" points that are between these two locations.\n            // The start and end locations often exist as separate vertices so would\n            // already be included, but for some line types they may not exist, so we\n            // include them here.\n            this.point.x = cx + Math.cos(start)*major;\n            this.point.y = cy + Math.sin(start)*minor;\n            this.bounds.expandByPoint( this.point );\n            this.point.x = cx + Math.cos(end)*major;\n            this.point.y = cy + Math.sin(end)*minor;\n            this.bounds.expandByPoint( this.point );\n\n            // now check each NESW compass point, i.e., middle of each edge\n            if ( start > end ) {\n                // add right edge\n                this.point.x = cx + major;\n                this.point.y = cy ;\n                this.bounds.expandByPoint( this.point );\n                // make start < end for the rest of the tests\n                start -= 2.0 * Math.PI;\n            }\n            if ( start < 0.5 * Math.PI && end > 0.5 * Math.PI ) {\n                // add top edge\n                this.point.x = cx ;\n                this.point.y = cy + minor;\n                this.bounds.expandByPoint( this.point );\n            }\n            if ( start < Math.PI && end > Math.PI ) {\n                // add left edge\n                this.point.x = cx - major;\n                this.point.y = cy;\n                this.bounds.expandByPoint( this.point );\n            }\n            if ( start < 1.5 * Math.PI && end > 1.5 * Math.PI ) {\n                // add bottom edge\n                this.point.x = cx ;\n                this.point.y = cy - minor;\n                this.bounds.expandByPoint( this.point );\n            }\n        }\n    } else {\n        // Has a tilt.\n        // From what we see, you should never reach here, as tilted ellipses are actually\n        // always tessellated. So, we do a fallback: call the onTexQuad with the rotation.\n        // This call will be a pretty good approximation, putting a rotated bounding box\n        // around the whole ellipse. For more accuracy you would need to tessellate the\n        // ellipse and get its points (especially if you don't have a full ellipse).\n        this.onTexQuad(cx, cy, 2*major, 2*minor, tilt, vpId);\n\n        // does start and end make a full ellipse?\n        //if ( (start <= 0) && (end >= 2.0 * Math.PI - 0.00001) ) {\n        //}\n    }\n};\n\n// Currently this case does not actually come up, as textured quads, i.e., images, are\n// not something that can be selected, from what data I have tried. So I have not spent\n// any time on the rotated case.\n// TODO: this code is only partially tested: I had problems getting a selectable raster\n// object in a DWG convert to an F2D.\nBoundsCallback.prototype.onTexQuad = function(centerX, centerY, width, height, rotation, vpId) {\n    var halfWidth = 0.5 * width;\n    var halfHeight = 0.5 * width;\n    if (rotation == 0.0) {\n        this.onVertex( centerX - halfWidth, centerY - halfHeight );\n        this.onVertex( centerX + halfWidth, centerY + halfHeight );\n    } else {\n        // A more complex rectangle, rotated. Take the four corners and rotate each\n        // around the center.\n        var rmtx = new THREE.Matrix4();  // Matrix3() does not have enough helper methods\n        var mtx = new THREE.Matrix4();\n        // Take a rectangle centered at the origin, rotate it, translate it to the final\n        // position. Each corner is added to the bounds.\n        rmtx.makeRotationZ(rotation);\n        // put it into the final position:\n        mtx.makeTranslation(centerX, centerY, 0.0);\n        mtx.multiply(rmtx);\n\n        for (var i = 0; i < 4; i++) {\n            this.point.x = (((i%2)==1)?halfWidth:-halfWidth);\n            this.point.y = ((i>=2)?halfHeight:-halfHeight);\n            this.point.applyMatrix4(mtx);\n            this.bounds.expandByPoint( this.point );\n        }\n    }\n};\n\nBoundsCallback.prototype.onOneTriangle = function(x1, y1, x2, y2, x3, y3, vpId) {\n    this.onVertex( x1, y1 );\n    this.onVertex( x2, y2 );\n    this.onVertex( x3, y3 );\n};\n\n\n\n","\nimport { SnapperIndicator } from \"./SnapperIndicator.js\";\nimport {isMobileDevice} from \"../../src/compat.js\";\nimport { VertexBufferReader } from \"../../src/wgs/scene/VertexBufferReader.js\";\nimport { nearestPointOnCircularArc, sampleEllipsePoint, intersectLines } from \"./SnapMath.js\";\n\nconst MeasureCommon = Autodesk.Viewing.MeasureCommon;\nconst EPSILON = MeasureCommon.EPSILON;\nconst SnapType = MeasureCommon.SnapType;\nconst SnapResult = MeasureCommon.SnapResult;\n\nvar SNAP_PRECISION = 0.001;\n\nconst av = Autodesk.Viewing;\n\nfunction isEqualWithPrecision(a, b) {\n    return Math.abs(a - b) <= SNAP_PRECISION;\n}\n\nfunction isEqualVectorsWithPrecision(v1, v2) {\n    return Math.abs(v1.x - v2.x) <= SNAP_PRECISION\n        && Math.abs(v1.y - v2.y) <= SNAP_PRECISION\n        && Math.abs(v1.z - v2.z) <= SNAP_PRECISION;\n}\n\nfunction isInverseVectorsWithPrecision(v1, v2) {\n    return Math.abs(v1.x + v2.x) <= SNAP_PRECISION\n        && Math.abs(v1.y + v2.y) <= SNAP_PRECISION\n        && Math.abs(v1.z + v2.z) <= SNAP_PRECISION;\n}\n\nfunction distancePointToLine(point, lineStart, lineEnd) {\n\n    var X0 = new THREE.Vector3();\n    var X1 = new THREE.Vector3();\n    var distance;\n    var param;\n\n    X0.subVectors(lineStart, point);\n    X1.subVectors(lineEnd, lineStart);\n    param = X0.dot(X1);\n    X0.subVectors(lineEnd, lineStart);\n    param = -param / X0.dot(X0);\n\n    if (param < 0) {\n        distance = point.distanceTo(lineStart);\n    }\n    else if (param > 1) {\n        distance = point.distanceTo(lineEnd);\n    }\n    else {\n        X0.subVectors(point, lineStart);\n        X1.subVectors(point, lineEnd);\n        X0.cross(X1);\n        X1.subVectors(lineEnd, lineStart);\n\n        distance = Math.sqrt(X0.dot(X0)) / Math.sqrt(X1.dot(X1));\n    }\n\n    return distance;\n};\n\nconst SnapCandidateType = {\n    Unknown:       0,\n    Line:          1,\n    CircularArc:   2,\n    EllipticalArc: 3\n};\n\n// A SnapCandidate references a single segment (line or arc) that we could snap to.\nclass SnapCandidate {\n    constructor(viewportId, distance) {\n\n        this.type = SnapCandidateType.Unknown;\n        this.viewportId = viewportId;\n\n        // 2d distance between original (unsnapped) position and the geometry of this candidate.\n        this.distance = 0;\n\n        // {Vector2} Start/Endpoint - only for line segments\n        this.lineStart = null;\n        this.lineEnd   = null;\n\n        // Fixed radius - only for CircularArcs\n        this.radius = 0;\n        \n        // Separate radii - only for ellipse arcs\n        this.radiusX = 0; // = major radius - by convention\n        this.radiusY = 0;\n        \n        // Center point as Vector2 (for arcs)\n        this.center = null;\n\n        // Start/end angle for arcs: Ccw angle in radians. Angle 0 corresponds to direction x+.\n        this.startAngle = 0;\n        this.endAngle   = 0; \n    }\n\n    fromLine(p1, p2) {\n        this.type = SnapCandidateType.Line;\n        this.lineStart = p1.clone();\n        this.lineEnd   = p2.clone();\n        return this;\n    }\n\n    fromCircularArc(center, radius, start, end) {\n        this.type   = SnapCandidateType.CircularArc;\n        this.center = center.clone();\n        this.radius = radius;\n        this.start  = start;\n        this.end    = end;\n        return this;\n    }\n\n    fromEllipticalArc(center, radiusX, radiusY, start, end) {\n        this.type = SnapCandidateType.EllipticalArc;\n        this.center = center.clone();\n        this.radiusX = radiusX;\n        this.radiusY = radiusY;\n        this.start = start;\n        this.end = end;\n        return this;\n    }\n\n    isLine()          { return this.type === SnapCandidateType.Line; }\n    isCircularArc()   { return this.type === SnapCandidateType.CirularArc; }\n    isEllipticalArc() { return this.type === SnapCandidateType.EllipticalArc; }\n\n    // Checks if the snapGeometry of this candidate intersects with another one.\n    //  @param {SnapCandidate} other\n    //  @param {Vector2} [optionalTarget]\n    //  @returns {THREE.Vector2|null} Returns intersection point if there is one.\n    getIntersection(other, optionalTarget) {\n\n        if (this.isLine() && other.isLine()) {\n            // Note: We do the intersections on the whole line - not just the intersections.\n            // Reason is:\n            //  a) Otherwise, it would not snap if you are slightly outline of one line segment\n            //  b) By definition, we get only very close segment candidates anyway\n            return intersectLines(this.lineStart, this.lineEnd, other.lineStart, other.lineEnd, false, optionalTarget);\n        }\n        \n        // TODO: Currently, we only support snapping to line-line intersections\n    }\n};\n\n// Checks if we can snap to an intersection of two close segments (each can be a line or arcs).\n//  @param {SnapCandidate[]} candidates     - Snap candidate geometries collected in GeometryCallback. Assumed to be within snapRadius.\n//  @param {TREE.Vector3}    intersectPoint - Unsnapped original position\n//  @param {number}          snapRadius\n//  @returns {Object|null} If an intersection snap is found, the result contains:\n//                    {\n//                        viewportId  // number\n//                        snapPoint   // (THREE.Vector3)\n//                    }\nconst findIntersectionSnap = (candidates, intersectPoint, snapRadius) => {\n\n    // Sort snapping candidates by increasing distance\n    // Strictly speaking, we just need the best two ones. But the number of candidates within the snapping\n    // distance is generally small anyway - and working with a sorted array is more flexible to incrementally\n    // make the snapping smarter later.\n    const byDistance = (ca, cb) => ca.distance - cb.distance;\n    candidates.sort(byDistance);\n    \n    // Stop here if we don't have enough candidates for an intersection\n    if (candidates.length < 2) {\n        return null;\n    }\n\n    // Init result object\n    const result = {\n        // Just use the one of the first candidate. There is no unique viewportId when using an intersection.\n        viewportId: candidates[0].viewportId,\n\n        // Snapping happens in 2d - so we set z in advance and just keep the original value.\n        // Note: Snapper generally needs some revision if we use it for planes that are not perpendicular to the viewing direction.\n        snapPoint:  new THREE.Vector3(0, 0, intersectPoint.z)\n    };\n    \n    // Check for any candidate that intersects with the closest one we found\n    const first = candidates[0];\n    for (let i=1; i<candidates.length; i++) {\n        const second = candidates[i];\n\n        // Do intersection test. If found, write it to result.snapPoint\n        const found = first.getIntersection(second, result.snapPoint);\n        if (!found) {\n            continue;\n        }\n\n        // We found an intersection. Although we assume all candidates to be within\n        // snap radius already, the intersection may still be somewhere else.\n        // => Check if intersection is still within the snapRadius.\n        const dist = THREE.Vector2.prototype.distanceTo.call(result.snapPoint, intersectPoint);\n        if (dist < snapRadius) {\n            // We found a valid intersection snap\n            return result;\n        }\n    }\n    return null;\n};\n\n\n/**\n * A tool that lets users attach pointer events to vertices and edges. It supports 2D and 3D models.\n *\n * @memberof Autodesk.Viewing.Extensions.Snapping\n * @alias Autodesk.Viewing.Extensions.Snapping.Snapper\n * @constructor\n */\nexport function Snapper(viewer, options) {\n\n    var _snapResult = new SnapResult();\n\n    var _viewer = viewer;\n    this.setGlobalManager(viewer.globalManager);\n\n    var _options = options || {};\n    var _names;\n\n    if (_options.markupMode) {\n        _names = [\"snapper-markup\"];\n    } else {\n        _names = [\"snapper\"];\n    }\n\n    var _priority = 60;\n\n    var _active = false;\n\n    var _distanceToEdge = Number.MAX_VALUE;\n    var _distanceToVertex = null;\n\n    var _isDragging = false;\n    var _isPressing = false;\n    var _isSnapped = false;\n\n    var _forcedVpId = null; // the viewport index of the first selection for 2D\n\n    var _snapToPixel = false;\n\n    this.indicator = new SnapperIndicator(viewer, this);\n\n    this.markupMode = _options.markupMode;\n    this.renderSnappedGeometry = _options.renderSnappedGeometry;\n    this.renderSnappedTopology = _options.renderSnappedTopology;\n\n    //Notice: The pixelSize should correspond to the amount of pixels per line in idAtPixels, the shape of\n    //detection area is square in idAtPixels, but circle in snapper, should make their areas match roughly.\n    this.detectRadiusInPixels = isMobileDevice() ? 50 : 10;\n\n    /**\n     * @returns {boolean} true when the tool is active\n     *\n     * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#isActive\n     */\n    this.isActive = function() {\n        return _active;\n    };\n\n    this.getNames = function() {\n        return _names;\n    };\n\n    this.getName = function() {\n        return _names[0];\n    };\n\n    this.getPriority = function() {\n        return _priority;\n    };\n\n    /**\n     * Starts intercepting pointer events.\n     * Invoked automatically by the {@link ToolController}.\n     *\n     * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#activate\n     */\n    this.activate = function() {\n        _active = true;\n\n        if (!this.indicator) {\n            this.indicator = new SnapperIndicator(viewer, this);\n        }\n    };\n\n\n    /**\n     * Stops intercepting pointer events.\n     * Invoked automatically by the {@link ToolController}.\n     *\n     * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#deactivate\n     */\n    this.deactivate = function() {\n        _active = false;\n        _snapToPixel = false;\n\n        if (this.indicator) {\n            this.indicator.destroy();\n            this.indicator = null;    \n        }        \n    };\n\n    this.copyResults = function(destiny) {\n        _snapResult.copyTo(destiny);\n    };\n\n    this.getEdge = function() {\n        return _snapResult.geomEdge;\n    };\n\n    this.getVertex = function() {\n        return _snapResult.geomVertex;\n    };\n\n    this.getGeometry = function() {\n        return _snapResult.getGeometry();\n    };\n\n    this.getGeometryType = function() {\n        return _snapResult.geomType;\n    };\n\n    this.getIntersectPoint = function() {\n        return _snapResult.intersectPoint;\n    };\n\n\n    /**\n     * @returns {SnapResult} The snapping status of the last pointer event performed.\n     *\n     * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#getSnapResult\n     */\n    this.getSnapResult = function() {\n        return _snapResult;\n    };\n\n    /**\n     * Checks whether the tool's last update resulted on a snap.\n     *\n     * @returns {boolean} true when the last pointer event got snapped.\n     *\n     * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#isSnapped\n     */\n    this.isSnapped = function() {\n        return _isSnapped;\n    };\n\n    this.clearSnapped = function() {\n        _snapResult.clear();\n        _isSnapped = false;\n    };\n\n    this.setViewportId = function(vpId) {\n        _forcedVpId = vpId;\n    };\n\n    this.setSnapToPixel = function(enable) {\n        _snapToPixel = enable;\n    };\n\n    /**\n     * 3D Snapping\n     * @param result -Result of Hit Test.\n     */\n    this.snapping3D = function(result) {\n\n        _snapResult.snapNode = result.dbId;\n        _snapResult.intersectPoint = result.intersectPoint;\n        _snapResult.modelId = result.model ? result.model.id : null;\n\n        // Avoid crash if the hit test does not belong to a model. This may happen, if a 3D overlay was hit (see Viewer3DImpl.rayIntersect).\n        if (!result.model) {\n            return;\n        }\n\n        var face = result.face;\n        var fragIds;\n\n        if (!result.fragId || result.fragId.length === undefined) {\n            fragIds = [result.fragId];\n        } else {\n            fragIds = result.fragId;\n        }\n\n        // This is for Fusion model with topology data\n        _snapResult.hasTopology = result.model.hasTopology();\n        if (_snapResult.hasTopology) {\n            this.snapping3DwithTopology(face, fragIds, result.model);\n        } else {\n           this.snapping3DtoMesh(face, fragIds, result.model);\n        }\n    };\n\n    /**\n     * Snapping order is: 1st vertices, 2nd edges, 3rd and final faces.\n     */\n    this.snapping3DwithTopology = function(face, fragIds, model) {\n\n        // Because edge topology data may be in other fragments with same dbId, need to iterate all of them.\n        if (_snapResult.snapNode) {\n            fragIds = [];\n\n            model.getData().instanceTree.enumNodeFragments(_snapResult.snapNode, function(fragId) {\n                fragIds.push(fragId);\n            }, true);\n        }\n\n        _snapResult.geomFace = _snapResult.geomEdge = _snapResult.geomVertex = null;\n        _distanceToEdge = Number.MAX_VALUE;\n\n        for (var fi = 0; fi < fragIds.length; ++fi) {\n\n            var fragId = fragIds[fi];\n            var mesh = _viewer.impl.getRenderProxy(model, fragId);\n            var geometry = mesh.geometry;\n\n            var topoIndex = model.getTopoIndex(fragId);\n            var topology = model.getTopology(topoIndex);\n            var facesTopology = topology.faces;\n            var edgesTopology = topology.edges;\n\n            if (!_snapResult.geomFace) {\n                _snapResult.geomFace = this.faceSnappingWithTopology(face, geometry, facesTopology, mesh);\n\n                if (_snapResult.geomFace) {\n                    _snapResult.geomFace.fragId = fragId;\n                }\n\n                var normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);\n                _snapResult.faceNormal = face.normal.applyMatrix3(normalMatrix).normalize();\n            }\n\n            // Need to iterate all frags with same dbId, because when meshes are attached with each other, \n            // edge-topology data will only be on one mesh.\n            this.edgeSnappingWithTopology(_snapResult.intersectPoint, geometry, edgesTopology, mesh);\n\n        }\n\n        _snapResult.geomVertex = this.vertexSnappingWithTopology(_snapResult.geomEdge, _snapResult.intersectPoint);\n\n        if (_snapResult.geomFace) {\n\n            // Determine which one should be drawn: face , edge or vertex\n            _snapResult.radius = this.setDetectRadius(_snapResult.intersectPoint);\n\n            if ((_options.forceSnapVertices || _distanceToVertex < _snapResult.radius) && _snapResult.geomVertex) {\n                _snapResult.geomType = SnapType.SNAP_VERTEX;\n            }\n            else if ((_options.forceSnapEdges || _distanceToEdge < _snapResult.radius) && _snapResult.geomEdge) {\n\n                var center = this.edgeIsCircle(_snapResult.geomEdge);\n                if (center) {\n                    _snapResult.circularArcCenter = center;\n                    _snapResult.circularArcRadius = center.distanceTo(_snapResult.geomEdge.vertices[0]);\n                    _snapResult.geomEdge.center = _snapResult.circularArcCenter;\n                    _snapResult.geomEdge.radius = _snapResult.circularArcRadius;\n                    _snapResult.geomType = SnapType.SNAP_CIRCULARARC;\n                }\n                else if (this.edgeIsCurved(_snapResult.geomEdge)) {\n                    _snapResult.geomType = SnapType.SNAP_CURVEDEDGE;\n                }\n                else {\n                    _snapResult.geomType = SnapType.SNAP_EDGE;\n                }\n\n            }\n            else {\n\n                if (this.faceIsCurved(_snapResult.geomFace)) {\n                    _snapResult.geomType = SnapType.SNAP_CURVEDFACE;\n                }\n                else {\n                    _snapResult.geomType = SnapType.SNAP_FACE;\n                }\n\n            }\n            \n            _isSnapped = true;\n        }\n    };\n\n    this.snapping3DtoMesh = function(face, fragIds, model) {\n         for (var fi = 0; fi < fragIds.length; ++fi) {\n\n            var fragId = fragIds[fi];\n            var mesh = _viewer.impl.getRenderProxy(model, fragId);\n            var geometry = mesh.geometry;\n\n            // Note that face may also be a line {a, b} (see lineRayCast(..) in VBIntersector.js\n            if (face instanceof THREE.Face3) {\n                _snapResult.geomFace = this.faceSnapping(face, geometry);\n            }\n\n            if (!_snapResult.geomFace)\n                continue;\n\n            _snapResult.geomFace.applyMatrix(mesh.matrixWorld);\n            _snapResult.geomEdge = this.edgeSnapping(_snapResult.geomFace, _snapResult.intersectPoint);\n            _snapResult.geomVertex = this.vertexSnapping(_snapResult.geomEdge, _snapResult.intersectPoint);\n\n            var normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);\n            _snapResult.faceNormal = face.normal.applyMatrix3(normalMatrix).normalize();\n\n            // Determine which one should be drawn: face , edge or vertex\n            _snapResult.radius = this.setDetectRadius(_snapResult.intersectPoint);\n\n            if ((_options.forceSnapVertices || (_distanceToVertex < _snapResult.radius))) {\n                _snapResult.geomType = SnapType.SNAP_VERTEX;\n            }\n            else if (_options.forceSnapEdges || (_distanceToEdge < _snapResult.radius)) {\n                _snapResult.geomType = SnapType.SNAP_EDGE;\n            }\n            else {\n                _snapResult.geomType = SnapType.SNAP_FACE;\n            }\n\n            _isSnapped = true;\n            break;\n        }\n    };\n\n    this.faceSnappingWithTopology = function(face, geometry, facesTopology, mesh) {\n\n        var vA = new THREE.Vector3();\n        var vB = new THREE.Vector3();\n        var vC = new THREE.Vector3();\n\n        var geom = new THREE.Geometry();\n\n        var attributes = geometry.attributes;\n\n        if (attributes.index !== undefined) {\n\n            var positions = geometry.vb ? geometry.vb : attributes.position.array;\n            var stride = geometry.vb ? geometry.vbstride : 3;\n\n            // Find the index of face topology list which includes the intersect face(triangle)\n            for (var i = 0; i < facesTopology.length; i++) {\n\n                var indexList = facesTopology[i].indexList;\n                var faceId = facesTopology[i].id;\n                for (var j = 0; j < indexList.length; j += 3) {\n\n                    if (face.a === indexList[j]) {\n                        if ((face.b === indexList[j + 1] && face.c === indexList[j + 2]) || (face.b === indexList[j + 2] && face.c === indexList[j + 1])) {\n                            break;\n                        }\n                    }\n                    else if (face.a === indexList[j + 1]) {\n                        if ((face.b === indexList[j] && face.c === indexList[j + 2]) || (face.b === indexList[j + 2] && face.c === indexList[j])) {\n                            break;\n                        }\n                    }\n                    else if (face.a === indexList[j + 2]) {\n                        if ((face.b === indexList[j] && face.c === indexList[j + 1]) || (face.b === indexList[j + 1] && face.c === indexList[j])) {\n                            break;\n                        }\n                    }\n                }\n\n                if (j < indexList.length) {\n                    break;\n                }\n            }\n\n            if (i < facesTopology.length) {\n\n                for (var j = 0; j < indexList.length; j += 3) {\n                    vA.set(\n                        positions[ indexList[j] * stride ],\n                        positions[ indexList[j] * stride + 1 ],\n                        positions[ indexList[j] * stride + 2 ]\n                    );\n                    vB.set(\n                        positions[ indexList[j + 1] * stride ],\n                        positions[ indexList[j + 1] * stride + 1 ],\n                        positions[ indexList[j + 1] * stride + 2 ]\n                    );\n                    vC.set(\n                        positions[ indexList[j + 2] * stride ],\n                        positions[ indexList[j + 2] * stride + 1 ],\n                        positions[ indexList[j + 2] * stride + 2 ]\n                    );\n\n                    var vIndex = geom.vertices.length;\n\n                    geom.vertices.push(vA.clone());\n                    geom.vertices.push(vB.clone());\n                    geom.vertices.push(vC.clone());\n\n                    geom.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));\n                }\n            }\n        }\n\n        //console.log(face);\n\n        if (geom.vertices.length > 0) {\n\n            geom.faceId = faceId;\n            geom.applyMatrix(mesh.matrixWorld);\n            return geom;\n        }\n        else {\n\n            return null;\n        }\n\n    };\n\n    /**\n     * Find the closest face next to the cast ray\n     * @param {THREE.Face3} face - the intersect triangle of Hit Test.\n     * @param geometry - the geometry of mesh\n     *\n     * @private\n     */\n    this.faceSnapping = function(face, geometry) {\n\n        var vA = new THREE.Vector3();\n        var vB = new THREE.Vector3();\n        var vC = new THREE.Vector3();\n\n        var geom = new THREE.Geometry();  //Geometry which includes all the triangles on the same plane.\n\n\n\n        var attributes = geometry.attributes;\n\n        if (attributes.index !== undefined) {\n\n            var indices = attributes.index.array || geometry.ib;\n            var positions = geometry.vb ? geometry.vb : attributes.position.array;\n            var stride = geometry.vb ? geometry.vbstride : 3;\n            var offsets = geometry.offsets;\n\n            if ( !offsets || offsets.length === 0) {\n\n                offsets = [{start: 0, count: indices.length, index: 0}];\n\n            }\n\n            for (var oi = 0; oi < offsets.length; ++oi) {\n\n                var start = offsets[oi].start;\n                var count = offsets[oi].count;\n                var index = offsets[oi].index;\n\n                for (var i = start; i < start + count; i += 3) {\n\n                    var a = index + indices[i];\n                    var b = index + indices[i + 1];\n                    var c = index + indices[i + 2];\n\n                    vA.set(\n                        positions[a * stride],\n                        positions[a * stride + 1],\n                        positions[a * stride + 2]\n                    );\n                    vB.set(\n                        positions[b * stride],\n                        positions[b * stride + 1],\n                        positions[b * stride + 2]\n                    );\n                    vC.set(\n                        positions[c * stride],\n                        positions[c * stride + 1],\n                        positions[c * stride + 2]\n                    );\n\n                    var faceNormal = THREE.Triangle.normal(vA, vB, vC);\n\n                    var va = new THREE.Vector3();\n                    va.set(\n                        positions[ face.a * stride ],\n                        positions[ face.a * stride + 1 ],\n                        positions[ face.a * stride + 2 ]\n                    );\n\n                    if (isEqualVectorsWithPrecision(faceNormal, face.normal) && isEqualWithPrecision(faceNormal.dot(vA), face.normal.dot(va)))\n                    {\n\n                        var vIndex = geom.vertices.length;\n\n                        geom.vertices.push(vA.clone());\n                        geom.vertices.push(vB.clone());\n                        geom.vertices.push(vC.clone());\n\n                        geom.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));\n\n                    }\n                }\n            }\n        }\n\n        if (geom.vertices.length > 0) {\n\n            return this.getTrianglesOnSameFace(geom, face, positions, stride);\n        }\n        else {\n\n            return null;\n        }\n    };\n\n    /**\n     * Find triangles on the same face with the triangle intersected with the cast ray\n     * @param geom -Geometry which includes all the triangles on the same plane.\n     * @param face -Triangle which intersects with the cast ray.\n     * @param positions -Positions of all vertices.\n     * @param stride -Stride for the interleaved buffer.\n     *\n     * @private\n     */\n    this.getTrianglesOnSameFace = function(geom, face, positions, stride) {\n\n        var isIncludeFace = false; // Check if the intersect face is in the mesh\n        var vertexIndices = geom.vertices.slice();\n\n        var va = new THREE.Vector3();\n        va.set(\n            positions[ face.a * stride ],\n            positions[ face.a * stride + 1 ],\n            positions[ face.a * stride + 2 ]\n        );\n        var vb = new THREE.Vector3();\n        vb.set(\n            positions[ face.b * stride ],\n            positions[ face.b * stride + 1 ],\n            positions[ face.b * stride + 2 ]\n        );\n        var vc = new THREE.Vector3();\n        vc.set(\n            positions[ face.c * stride ],\n            positions[ face.c * stride + 1 ],\n            positions[ face.c * stride + 2 ]\n        );\n        var intersectFace = new THREE.Geometry();\n        intersectFace.vertices.push(va);\n        intersectFace.vertices.push(vb);\n        intersectFace.vertices.push(vc);\n        intersectFace.faces.push(new THREE.Face3(0, 1, 2));\n\n        var vCount = [];\n\n        do {\n\n            vCount = [];\n\n            for (var j = 0; j < vertexIndices.length; j += 3) {\n\n                // The triangle which is intersected with the ray\n                if (vertexIndices[j].equals(va) && vertexIndices[j + 1].equals(vb) && vertexIndices[j + 2].equals(vc)) {\n\n                    isIncludeFace = true;\n                    vCount.push(j);\n                    continue;\n                }\n\n                for (var k = 0; k < intersectFace.vertices.length; k += 3) {\n\n                    // The triangles which are on the same face with the intersected triangle\n                    if (this.trianglesSharedEdge(vertexIndices[j], vertexIndices[j + 1], vertexIndices[j + 2],\n                            intersectFace.vertices[k], intersectFace.vertices[k + 1], intersectFace.vertices[k + 2])) {\n\n                        var vIndex = intersectFace.vertices.length;\n                        intersectFace.vertices.push(vertexIndices[j].clone());\n                        intersectFace.vertices.push(vertexIndices[j + 1].clone());\n                        intersectFace.vertices.push(vertexIndices[j + 2].clone());\n                        intersectFace.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));\n\n                        vCount.push(j);\n                        break;\n                    }\n                }\n            }\n\n            for (var ci = vCount.length - 1; ci >= 0; --ci) {\n\n                vertexIndices.splice(vCount[ci], 3);\n\n            }\n\n        } while (vCount.length > 0);\n\n        if (isIncludeFace) {\n            return intersectFace;\n        }\n        else {\n            return null;\n        }\n\n    };\n\n    /**\n     * Check if the two triangle share edge, the inputs are their vertices\n     *\n     * @private\n     */\n    this.trianglesSharedEdge = function(a1, a2, a3, b1, b2, b3) {\n\n        var c1 = false;\n        var c2 = false;\n        var c3 = false;\n\n        if (a1.equals(b1) || a1.equals(b2) || a1.equals(b3)) {\n            c1 = true;\n        }\n        if (a2.equals(b1) || a2.equals(b2) || a2.equals(b3)) {\n            c2 = true;\n        }\n        if (a3.equals(b1) || a3.equals(b2) || a3.equals(b3)) {\n            c3 = true;\n        }\n\n        if (c1 & c2 || c1 & c3 || c2 & c3) {\n            return true;\n        }\n\n        return false;\n    };\n\n    this.edgeSnappingWithTopology = function(intersectPoint, geometry, edgesTopology, mesh) {\n\n        var edgeGeom = new THREE.Geometry();\n        var minDistTopoIndex;\n        var minDist = Number.MAX_VALUE;\n\n        var vA = new THREE.Vector3();\n        var vB = new THREE.Vector3();\n\n        var attributes = geometry.attributes;\n\n        if (attributes.index !== undefined && edgesTopology != undefined) {\n\n            var positions = geometry.vb ? geometry.vb : attributes.position.array;\n            var stride = geometry.vb ? geometry.vbstride : 3;\n\n            // Find the index of edge topology list which includes the nearest edge segment to the intersect point\n            for (var i = 0; i < edgesTopology.length; i++) {\n\n                var indexList = edgesTopology[i].indexList;\n                // In edges topology index list the type is LineStrip\n                for (var j = 0; j < indexList.length - 1; j++) {\n                    vA.set(\n                        positions[ indexList[j] * stride ],\n                        positions[ indexList[j] * stride + 1 ],\n                        positions[ indexList[j] * stride + 2 ]\n                    );\n                    vB.set(\n                        positions[ indexList[j + 1] * stride ],\n                        positions[ indexList[j + 1] * stride + 1 ],\n                        positions[ indexList[j + 1] * stride + 2 ]\n                    );\n\n                    vA.applyMatrix4(mesh.matrixWorld);\n                    vB.applyMatrix4(mesh.matrixWorld);\n\n                    var dist = distancePointToLine(intersectPoint, vA, vB);\n                    if (dist < minDist) {\n                        minDist = dist;\n                        minDistTopoIndex = i;\n                    }\n                }\n            }\n\n            if (minDistTopoIndex) {\n                indexList = edgesTopology[minDistTopoIndex].indexList;\n                for (var k = 0; k < indexList.length - 1; k++) {\n                    edgeGeom.vertices.push(new THREE.Vector3(positions[indexList[k] * stride], positions[indexList[k] * stride + 1], positions[indexList[k] * stride + 2]));\n                    // To make the line's type to LinePieces which is used by drawLine function\n                    edgeGeom.vertices.push(new THREE.Vector3(positions[indexList[k + 1] * stride], positions[indexList[k + 1] * stride + 1], positions[indexList[k + 1] * stride + 2]));\n                }\n            }\n        }\n\n        if (_distanceToEdge >= minDist && edgeGeom.vertices.length > 0) {\n\n            _distanceToEdge = minDist;\n            edgeGeom.applyMatrix(mesh.matrixWorld);\n            _snapResult.geomEdge = edgeGeom;\n        }\n    };\n\n    /**\n     * Find the closest edge next to the intersect point\n     * @param face -Face which is found by faceSnapping.\n     * @param intersectPoint -IntersectPoint between cast ray and face.\n     * @param mesh -The whole mesh of one fragment.\n     *\n     * @private\n     */\n    this.edgeSnapping = function(face, intersectPoint) {\n\n        var lineGeom = new THREE.Geometry();\n        var isEdge_12 = true;\n        var isEdge_13 = true;\n        var isEdge_23 = true;\n\n        for (var i = 0; i < face.vertices.length; i += 3) {\n\n            for (var j = 0; j < face.vertices.length; j += 3) {\n\n                if ( i !== j ) {\n                    // Check edge 12\n                    if ((face.vertices[i].equals(face.vertices[j]) || face.vertices[i].equals(face.vertices[j + 1])\n                        || face.vertices[i].equals(face.vertices[j + 2]))\n                        && (face.vertices[i + 1].equals(face.vertices[j]) || face.vertices[i + 1].equals(face.vertices[j + 1])\n                        || face.vertices[i + 1].equals(face.vertices[j + 2]))) {\n\n                        isEdge_12 = false;\n\n                    }\n                    // Check edge 13\n                    if ((face.vertices[i].equals(face.vertices[j]) || face.vertices[i].equals(face.vertices[j + 1])\n                        || face.vertices[i].equals(face.vertices[j + 2]))\n                        && (face.vertices[i + 2].equals(face.vertices[j]) || face.vertices[i + 2].equals(face.vertices[j + 1])\n                        || face.vertices[i + 2].equals(face.vertices[j + 2]))) {\n\n                        isEdge_13 = false;\n\n                    }\n                    // Check edge 23\n                    if ((face.vertices[i + 1].equals(face.vertices[j]) || face.vertices[i + 1].equals(face.vertices[j + 1])\n                        || face.vertices[i + 1].equals(face.vertices[j + 2]))\n                        && (face.vertices[i + 2].equals(face.vertices[j]) || face.vertices[i + 2].equals(face.vertices[j + 1])\n                        || face.vertices[i + 2].equals(face.vertices[j + 2]))) {\n\n                        isEdge_23 = false;\n\n                    }\n                }\n            }\n\n            if (isEdge_12) {\n\n                lineGeom.vertices.push(face.vertices[i].clone());\n                lineGeom.vertices.push(face.vertices[i + 1].clone());\n\n            }\n            if (isEdge_13) {\n\n                lineGeom.vertices.push(face.vertices[i].clone());\n                lineGeom.vertices.push(face.vertices[i + 2].clone());\n\n            }\n            if (isEdge_23) {\n\n                lineGeom.vertices.push(face.vertices[i + 1].clone());\n                lineGeom.vertices.push(face.vertices[i + 2].clone());\n\n            }\n\n            isEdge_12 = true;\n            isEdge_13 = true;\n            isEdge_23 = true;\n\n        }\n\n        //return lineGeom;\n\n        var edgeGeom = new THREE.Geometry();\n        var minDistIndex;\n        var minDist = Number.MAX_VALUE;\n\n        for (var k = 0; k < lineGeom.vertices.length; k += 2) {\n\n            var dist = distancePointToLine(intersectPoint, lineGeom.vertices[k], lineGeom.vertices[k + 1]);\n\n            if (dist < minDist) {\n                minDist = dist;\n                minDistIndex = k;\n            }\n\n        }\n\n        edgeGeom.vertices.push(lineGeom.vertices[ minDistIndex ].clone());\n        edgeGeom.vertices.push(lineGeom.vertices[ minDistIndex + 1 ].clone());\n\n        edgeGeom.vertices = this.getConnectedLineSegmentsOnSameLine(lineGeom, edgeGeom.vertices);\n\n        _distanceToEdge = minDist;\n\n        return edgeGeom;\n\n    };\n\n    this.getConnectedLineSegmentsOnSameLine = function(lineGeom, edgeVertices) {\n\n        var vertices = lineGeom.vertices.slice();\n        var va = edgeVertices[0];\n        var vb = edgeVertices[1];\n\n        var vCount = [];\n\n        do {\n\n            vCount = [];\n\n            for (var j = 0; j < vertices.length; j += 2) {\n\n                // The line which has min distance to intersection point\n                if (vertices[j].equals(va) && vertices[j + 1].equals(vb)) {\n\n                    continue;\n                }\n\n                for (var k = 0; k < edgeVertices.length; k += 2) {\n\n                    // The line segments which are connected on the same line\n                    if (vertices[j].equals(edgeVertices[k]) || vertices[j + 1].equals(edgeVertices[k]) ||\n                        vertices[j].equals(edgeVertices[k + 1]) || vertices[j + 1].equals(edgeVertices[k + 1])) {\n\n                        var V0 = new THREE.Vector3();\n                        var V1 = new THREE.Vector3();\n\n                        V0.subVectors(edgeVertices[k],  edgeVertices[k + 1]);\n                        V0.normalize();\n                        V1.subVectors(vertices[j],vertices[j + 1]);\n                        V1.normalize();\n\n                        //if (V0.equals(V1) || V0.equals(V1.negate())) {\n                        if (isEqualVectorsWithPrecision(V0, V1) || isInverseVectorsWithPrecision(V0, V1))\n                        {\n\n                            vCount.push(j);\n                            break;\n\n                        }\n                    }\n                }\n            }\n\n            for (var ci = vCount.length - 1; ci >= 0; --ci) {\n\n                edgeVertices.push(vertices[ vCount[ci] ]);\n                edgeVertices.push(vertices[ vCount[ci] + 1 ]);\n                vertices.splice(vCount[ci], 2);\n\n            }\n\n        } while (vCount.length > 0);\n\n        return edgeVertices;\n\n    };\n\n    this.vertexSnappingWithTopology = function(edge, intersectPoint) {\n\n        var minDist = Number.MAX_VALUE;\n        var point = new THREE.Vector3();\n\n        if (edge && edge.vertices.length > 1) {\n            var dist1 = intersectPoint.distanceTo(edge.vertices[0]);\n            var dist2 = intersectPoint.distanceTo(edge.vertices[edge.vertices.length - 1]);\n\n            if (dist1 <= dist2) {\n                minDist = dist1;\n                point = edge.vertices[0].clone();\n            }\n            else {\n                minDist = dist2;\n                point = edge.vertices[edge.vertices.length - 1].clone();\n            }\n        }\n\n        _distanceToVertex = minDist;\n\n        return point;\n    };\n\n    /**\n     * Find the closest vertex next to the intersect point\n     * @param edge -Edge which is found by edgeSnapping.\n     * @param intersectPoint -IntersectPoint between cast ray and face.\n     *\n     * @private\n     */\n    this.vertexSnapping = function(edge, intersectPoint) {\n\n        var minDist = Number.MAX_VALUE;\n        var point = new THREE.Vector3();\n\n        for (var i = 0; i < edge.vertices.length; ++i) {\n\n            var dist = intersectPoint.distanceTo(edge.vertices[i]);\n\n            if (dist < minDist - SNAP_PRECISION) {\n\n                minDist = dist;\n                point = edge.vertices[i].clone();\n\n            }\n        }\n\n        _distanceToVertex = minDist;\n\n        return point;\n    };\n\n    // This is only a workaround to detect if an edge is circle\n    this.edgeIsCircle = function(edge) {\n\n        var vertices = edge.vertices;\n\n        // Exclude squares and regular polygons\n        if (vertices.length < 8) {\n            return false;\n        }\n\n        if (vertices[0].equals(vertices[vertices.length - 1])) {\n\n            var center = new THREE.Vector3(0, 0, 0);\n            for (var i = 0; i < vertices.length; i += 2) {\n                center.add(vertices[i]);\n            }\n            center.divideScalar(vertices.length / 2.0);\n\n            var radius = center.distanceTo(vertices[0]);\n            for (var i = 0; i < vertices.length; i += 2) {\n                if (Math.abs(center.distanceTo(vertices[i]) - radius) <= SNAP_PRECISION) {\n                    continue;\n                }\n                else {\n                    return false;\n                }\n            }\n            return center;\n        }\n        else {\n            return false;\n        }\n    };\n\n    this.edgeIsCurved = function (edge) {\n\n        var vertices = edge.vertices;\n\n        if (vertices.length <= 2) {\n            return false;\n        }\n        else if (vertices[0].equals(vertices[vertices.length - 1])) {\n            return true;\n        }\n        else {\n            var V1 = new THREE.Vector3();\n            V1.subVectors(vertices[0], vertices[1]);\n\n            var V2 = new THREE.Vector3();\n            for (var i = 2; i < vertices.length; i += 2) {\n                V2.subVectors(vertices[i], vertices[i + 1]);\n                if (!isEqualVectorsWithPrecision(V1, V2)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    };\n\n    this.faceIsCurved = function (face) {\n\n        var vertices = face.vertices;\n        var faces = face.faces;\n\n        if (faces.length <= 1) {\n            return false;\n        }\n        else {\n            var fN1 = THREE.Triangle.normal(vertices[faces[0].a], vertices[faces[0].b], vertices[faces[0].c]);\n            var vA1 = vertices[faces[0].a];\n\n            for (var i = 1; i < faces.length; i++) {\n                var fN2 = THREE.Triangle.normal(vertices[faces[i].a], vertices[faces[i].b], vertices[faces[i].c]);\n                var vA2 = vertices[faces[i].a];\n\n                if (!isEqualVectorsWithPrecision(fN1, fN2) || !isEqualWithPrecision(fN1.dot(vA1), fN2.dot(vA2))) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    };\n\n    this.angleVector2 = function(vector) {\n\n        if (vector.x > 0 && vector.y >= 0) {\n            return Math.atan(vector.y / vector.x);\n        }\n        else if (vector.x >= 0 && vector.y < 0) {\n            return Math.atan(vector.y / vector.x) + Math.PI * 2;\n        }\n        else if (vector.x < 0 && vector.y <= 0) {\n            return Math.atan(vector.y / vector.x) + Math.PI;\n        }\n        else if (vector.x <= 0 && vector.y > 0) {\n            return Math.atan(vector.y / vector.x) + Math.PI;\n        }\n        else{ // x = 0, y = 0\n            return null;\n        }\n    };\n\n    // Creates a THREE.Geometry that represents an approximation of a given elliptical arc in {z=0} plane.\n    // Points are obtained by by uniform sampling of a given elliptical arc.\n    //  @param {number} numPoints - The length number of points that the output geometry will contain. segments in which we subdivide the arc. Resulting point count is numSegments+1.\n    // See sampleEllipsePoint for param details.\n    const createEllipticalArcGeometry = (cx, cy, rx, ry, startAngle, endAngle, numPoints) => {\n        const geometry = new THREE.Geometry();\n        for (let i=0; i<numPoints; i++) {\n            let p = new THREE.Vector3(0,0,0);\n            sampleEllipsePoint(cx, cy, rx, ry, startAngle, endAngle, i/(numPoints-1), p);\n\n            geometry.vertices.push(p);\n        }\n        return geometry;\n    };\n\n    function GeometryCallback(viewer, snapper, aDetectRadius) {\n        this.viewer = viewer;\n        this.snapper = snapper;\n\n        this.lineGeom = new THREE.Geometry();\n        this.circularArc = null;\n        this.circularArcCenter;\n        this.circularArcRadius;\n        this.ellipticalArc = null;\n        this.ellipticalArcCenter;\n\n        this.minDist = Number.MAX_VALUE;\n\n        this.vpIdLine = null;\n        this.vpIdCircular = null;\n        this.vpIdElliptical = null;\n\n        this.detectRadius = aDetectRadius;\n\n        // Collects candidate segments that we can snap to.\n        // This is used to allow snapping to segment intersections.\n        this.snapCandidates = []; // {SnappingCandidate[]}\n    }\n\n    GeometryCallback.prototype.onLineSegment = function(x1, y1, x2, y2, vpId) {\n        var intersectPoint = this.snapper.getIntersectPoint();\n        var vertices = this.lineGeom.vertices;\n        var v1 = new THREE.Vector3(x1, y1, intersectPoint.z);\n        var v2 = new THREE.Vector3(x2, y2, intersectPoint.z);\n\n        // Skip segments outside detectRadius\n        var dist = distancePointToLine(intersectPoint, v1, v2);\n        if (dist > this.detectRadius) {\n            return;\n        }\n\n        // Collect snap candidate\n        this.snapCandidates.push(new SnapCandidate(vpId, dist).fromLine(v1, v2));\n\n        // Track minDist and lineGeometry for best hit so far\n        if (dist < this.minDist) {\n\n            vertices.splice(0, 2, v1, v2);\n            this.minDist = dist;\n\n            this.vpIdLine = vpId;\n        }\n    };\n\n    GeometryCallback.prototype.onCircularArc = function(cx, cy, start, end, radius, vpId) {\n        var intersectPoint = this.snapper.getIntersectPoint();\n        var point = new THREE.Vector2(intersectPoint.x, intersectPoint.y);\n\n        var center = new THREE.Vector2(cx, cy);\n        point.sub(center);\n\n        // Compute closest point on arc\n        const pointOnArc = nearestPointOnCircularArc(intersectPoint, center, radius, start, end);\n        const dist       = pointOnArc.distanceTo(intersectPoint); // 2D distance\n\n        // Collect snap candidate\n        this.snapCandidates.push(new SnapCandidate(vpId, dist).fromCircularArc(center, radius, start, end));\n\n        // Skip arcs outside detectRadius\n        if (dist > this.detectRadius) {\n            return;\n        }\n\n        // TODO: get rid of the CircleGeometry stuff below, because we computed the snapPoint above already.\n        //       But this needs some refactoring, because the Geometry is passed around outside of snapper.\n\n        var angle = this.snapper.angleVector2(point);\n\n        if (end > start && angle >= start && angle <= end) {\n            var arc = new THREE.CircleGeometry(radius, 100, start, end - start);\n        }\n        else if (end < start && (angle >= start || angle <= end)) {\n            var arc = new THREE.CircleGeometry(radius, 100, start, Math.PI * 2 - start + end);\n        }\n        else {\n            return;\n        }\n        arc.vertices.splice(0, 1);\n        arc.applyMatrix(new THREE.Matrix4().makeTranslation(cx, cy, intersectPoint.z));\n        this.circularArc = arc;\n        this.circularArcCenter = new THREE.Vector3(cx, cy, intersectPoint.z);\n        this.circularArcRadius = radius;\n\n        this.snapPoint = new THREE.Vector3(pointOnArc.x, pointOnArc.y, intersectPoint.z);\n\n        this.vpIdCircular = vpId;\n    };\n\n    GeometryCallback.prototype.onEllipticalArc = function(cx, cy, start, end, major, minor, tilt, vpId) {\n        var intersectPoint = this.snapper.getIntersectPoint();\n        var point = new THREE.Vector2(intersectPoint.x, intersectPoint.y);\n\n        var major1 = major - this.detectRadius;\n        var minor1 = minor - this.detectRadius;\n        var major2 = major + this.detectRadius;\n        var minor2 = minor + this.detectRadius;\n\n        var equation1 = (point.x - cx) * (point.x - cx) / (major1 * major1) + (point.y - cy) * (point.y - cy) / (minor1 * minor1);\n        var equation2 = (point.x - cx) * (point.x - cx) / (major2 * major2) + (point.y - cy) * (point.y - cy) / (minor2 * minor2);\n\n        var center = new THREE.Vector2(cx, cy);\n        point.sub(center);\n        point.x *= minor;\n        point.y *= major;\n        var angle = this.snapper.angleVector2(point);\n\n        if (end > Math.PI * 2) {\n            end = Math.PI * 2;\n        }\n\n        if (equation1 >= 1 && equation2 <= 1) {\n\n            if ((end > start && angle >= start && angle <= end) || (end < start && (angle >= start || angle <= end))){\n                var arc = createEllipticalArcGeometry(cx, cy, major, minor, start, end, 50);\n                if (!isEqualWithPrecision(end - start, Math.PI * 2))\n                {\n                    arc.vertices.pop();\n                }\n                arc.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, intersectPoint.z));\n\n                // Compute distance between geometry and snapped point. \n                // We use the same way here as in getSnapResultPosition(). This will be replaced later by a more accurate solution.\n                const nearestPoint = nearestVertexInVertexToEdge(intersectPoint, arc);\n                const dist = THREE.Vector2.prototype.distanceTo.call(nearestPoint, intersectPoint); // only in x/y\n\n                // Collect snap candidate\n                const center = new THREE.Vector2(cx, cy)\n                this.snapCandidates.push(new SnapCandidate(vpId, dist).makeEllipticalArc(center, major, minor, start, end));\n\n                // Todo: Unlike for line-segments, arcs are currently collected by \"last one wins\" rule by the code for single-snapping. \n                //       We should consider the distance here as well.\n                this.ellipticalArc = arc;\n                this.ellipticalArcCenter = new THREE.Vector3(cx, cy, intersectPoint.z);\n\n                this.vpIdElliptical = vpId;\n            }\n        }\n    };\n\n    this.snapping2D = function(result) {\n\n        if (!result) {\n            return;\n        }\n        \n        var intersectPoint = result.intersectPoint;\n        var fragIds = result.fragId;\n\n        if (typeof fragIds === \"undefined\") {\n            return;\n        }\n        else if (!Array.isArray(fragIds)) {\n            fragIds = [fragIds];\n        }\n\n        _snapResult.modelId = result.model ? result.model.id : null;\n        _snapResult.hasTopology = false;\n        _snapResult.intersectPoint = intersectPoint;\n\n        // Determine which one should be drawn: line, circular arc or elliptical arc\n        _snapResult.radius = this.setDetectRadius(intersectPoint);\n\n        // Geometry snapping is only possible if a fragment list is available to obtain geometry per fragment.\n        var supportsGeomSnapping = (_viewer.model.getFragmentList()!=null);\n        if (!supportsGeomSnapping) {\n\n            // If no snapping is available, just accept the hitpoint as a vertex hit. This allows to measure\n            // distances between arbitrary points in rasters.\n            _isSnapped = true;\n            _snapResult.geomType = SnapType.SNAP_VERTEX;\n            _snapResult.geomVertex = intersectPoint;\n\n            return;\n        }\n\n\n        var gc = new GeometryCallback(_viewer, this, _snapResult.radius);\n\n        for (var fi = 0; fi < fragIds.length; ++fi) {\n\n            var mesh = _viewer.impl.getRenderProxy(_viewer.model, fragIds[fi]);\n\n            if (mesh && mesh.geometry) {\n                var vbr = new VertexBufferReader(mesh.geometry);\n                vbr.enumGeomsForObject(_viewer.model.reverseMapDbId(result.dbId), gc);\n            }\n        }\n\n        this.finishSnapping2D(gc, intersectPoint);\n\n        // Snap the unsnapped point only if the snapping fails\n        if(!_isSnapped && _snapToPixel) {\n            _isSnapped = true;\n            _snapResult.geomType = SnapType.RASTER_PIXEL;\n            _snapResult.geomVertex = intersectPoint;\n        }\n    };\n\n    // By default, snapper only considers model geometry that is written to ID buffer.\n    // This function performs the 2D snapping on a set of given 2D meshes instead. It works similar to snapping2D() but \n    // enumerates the given meshes instead of getting them from the fragment list.\n    //\n    //  @param {THREE.Vector3}                 intersectPoint - click position in world-coords\n    //  @param {function(dbId, layerId, vpId)} filter - Defines subset of primitives to be considered.\n    //  @param {THREE.Mesh[]}                  meshes - The triangulated 2D shapes to be checked for snapping\n    //  @param {number}                        [detectRadius] - Same coordinate system as the given geometry. Required if geometry is not in world-coords.\n\n    this.snapping2DOverlay = function(intersectPoint, meshes, filter, detectRadius) {\n        _snapResult.hasTopology = false;\n        _snapResult.intersectPoint = intersectPoint;\n        _snapResult.radius = detectRadius || this.setDetectRadius(intersectPoint);\n        \n        var gc = new GeometryCallback(_viewer, this, _snapResult.radius);\n             \n        for (var i=0; i<meshes.length; i++) {\n            var mesh = meshes[i];\n            var vbr = new VertexBufferReader(mesh.geometry);\n            vbr.enumGeoms(filter, gc);\n        }\n         \n        this.finishSnapping2D(gc, intersectPoint);\n    }\n\n    // Performs 2D snapping to segments based on an enumSegments() callback, which enumerates all segments\n    // within in a given bbox in model-space.\n    //  @param {Vector3}                          intersectPoint (3D with z=0)\n    //  @param {function(minx, miny, maxx, maxy)} enumSegments\n    this.snapping2DWithSegmentEnum = function(intersectPoint, enumSegments) {\n\n        _snapResult.hasTopology = false;\n        _snapResult.intersectPoint = intersectPoint;\n        _snapResult.radius = this.setDetectRadius(intersectPoint);\n\n        var gc = new GeometryCallback(_viewer, this, _snapResult.radius);\n\n        // enum all segments within the snapRadius around intersectPoint\n        var minx = intersectPoint.x - _snapResult.radius;\n        var miny = intersectPoint.y - _snapResult.radius;\n        var maxx = intersectPoint.x + _snapResult.radius;\n        var maxy = intersectPoint.y + _snapResult.radius;\n        enumSegments(minx, miny, maxx, maxy, gc);\n\n        this.finishSnapping2D(gc, intersectPoint);\n    }\n\n    // Finish 2D snapping operation - assuming that all candidate geometry for snapping has been processed by the geometryCallback gc already.\n    this.finishSnapping2D = function(gc, intersectPoint) {\n\n        // When restricting to a single viewport, exclude candidates of all other viewports\n        if (_forcedVpId !== null) {\n            const isSameViewport = c => (c.viewportId === _forcedVpId);\n            gc.snapCandidates = gc.snapCandidates.filter(isSameViewport);\n        }\n\n        // Check if we can snap to an intersection of two close segments\n        const intersectSnap = findIntersectionSnap(gc.snapCandidates, intersectPoint, gc.detectRadius);\n        if (intersectSnap) {\n            _snapResult.viewportIndex2d = intersectSnap.viewportId;\n            _snapResult.snapPoint = intersectSnap.snapPoint;\n            _snapResult.geomType = SnapType.SNAP_INTERSECTION;\n            _snapResult.geomVertex = intersectSnap.snapPoint;\n            _isSnapped = true;\n            return;\n        }\n\n        if (gc.circularArc) {\n\n            _snapResult.viewportIndex2d = gc.vpIdCircular;\n\n            _snapResult.snapPoint = gc.snapPoint;\n\n            // Only snap the geometries which belong to the same viewport as the first selection\n            if (_forcedVpId !== null && _forcedVpId !== _snapResult.viewportIndex2d)\n                return;\n\n            if (intersectPoint.distanceTo(gc.circularArc.vertices[0]) < _snapResult.radius) {\n\n                _snapResult.geomVertex = gc.circularArc.vertices[0];\n                _snapResult.geomType = SnapType.SNAP_VERTEX;\n            }\n            else if (intersectPoint.distanceTo(gc.circularArc.vertices[gc.circularArc.vertices.length - 1]) < _snapResult.radius) {\n\n                _snapResult.geomVertex = gc.circularArc.vertices[gc.circularArc.vertices.length - 1];\n                _snapResult.geomType = SnapType.SNAP_VERTEX;\n            }\n            else {\n\n                this.lineStripToPieces(gc.circularArc);\n                _snapResult.geomEdge = gc.circularArc;\n                _snapResult.circularArcCenter = gc.circularArcCenter;\n                _snapResult.circularArcRadius = gc.circularArcRadius;\n                _snapResult.geomType = SnapType.SNAP_CIRCULARARC;\n            }\n\n            _isSnapped = true;\n\n\n        }\n        else if (gc.ellipticalArc) {\n\n            _snapResult.viewportIndex2d = gc.vpIdElliptical;\n\n            // Only snap the geometries which belong to the same viewport as the first selection\n            if (_forcedVpId !== null && _forcedVpId !== _snapResult.viewportIndex2d)\n                return;\n\n            if (intersectPoint.distanceTo(gc.ellipticalArc.vertices[0]) < _snapResult.radius) {\n\n                _snapResult.geomVertex = gc.ellipticalArc.vertices[0];\n                _snapResult.geomType = SnapType.SNAP_VERTEX;\n            }\n            else if (intersectPoint.distanceTo(gc.ellipticalArc.vertices[gc.ellipticalArc.vertices.length - 1]) < _snapResult.radius) {\n\n                _snapResult.geomVertex = gc.ellipticalArc.vertices[gc.ellipticalArc.vertices.length - 1];\n                _snapResult.geomType = SnapType.SNAP_VERTEX;\n            }\n            else {\n\n                this.lineStripToPieces(gc.ellipticalArc);\n                _snapResult.geomEdge = gc.ellipticalArc;\n                // Before we have measure design for elliptical arc, measure the center for now\n                _snapResult.circularArcCenter = gc.ellipticalArcCenter;\n                _snapResult.circularArcRadius = null;\n                _snapResult.geomType = SnapType.SNAP_CIRCULARARC;\n            }\n\n            _isSnapped = true;\n\n        }\n        else if (gc.lineGeom.vertices.length) {\n\n            _snapResult.viewportIndex2d = gc.vpIdLine;\n\n            // Only snap the geometries which belong to the same viewport as the first selection\n            if (_forcedVpId !== null && _forcedVpId !== _snapResult.viewportIndex2d)\n                return;\n\n            // Always expose edge segment - no matter whether we snap to the edge or one of its vertices.\n            // This allows us to combine it with other snap constraints later - as done by Edit2D.\n            _snapResult.geomEdge = gc.lineGeom;\n\n            if (this.markupMode) {  // Markup mode\n                var start = gc.lineGeom.vertices[0];\n                var end = gc.lineGeom.vertices[1];\n                var mid = new THREE.Vector3();\n                mid.addVectors(start, end);\n                mid.divideScalar(2);\n                var md = intersectPoint.distanceTo(mid);\n                var sd = intersectPoint.distanceTo(start);\n                var ed = intersectPoint.distanceTo(end);\n\n                // Store it for snapping to parallel/perpendicular of underlying vectors\n                _snapResult.geomEdge = gc.lineGeom;\n\n                if (md < _snapResult.radius) {\n                    _snapResult.geomVertex = mid;\n                    _snapResult.geomType = SnapType.SNAP_VERTEX;\n                }\n                else if (sd < _snapResult.radius) {\n                    _snapResult.geomVertex = start;\n                    _snapResult.geomType = SnapType.SNAP_VERTEX;\n                }\n                else if (ed < _snapResult.radius) {\n                    _snapResult.geomVertex = end;\n                    _snapResult.geomType = SnapType.SNAP_VERTEX;\n                }\n                else {\n                    _snapResult.geomType = SnapType.SNAP_EDGE;\n                }\n\n                // Circle center\n                if (gc.lineGeom.vertices[0].distanceTo(gc.lineGeom.vertices[1]) < EPSILON) {\n                    _snapResult.geomType = SnapType.SNAP_CIRCLE_CENTER;\n                }\n            }\n            else {  // Measure mode\n                if (intersectPoint.distanceTo(gc.lineGeom.vertices[0]) < _snapResult.radius) {\n\n                    if (gc.lineGeom.vertices[0].distanceTo(gc.lineGeom.vertices[1]) < EPSILON) {\n                        _snapResult.geomType = SnapType.SNAP_CIRCLE_CENTER;\n                    } else {\n                        _snapResult.geomType = SnapType.SNAP_VERTEX;\n                    }\n\n                    _snapResult.geomVertex = gc.lineGeom.vertices[0];\n                }\n                else if ((_options.forceSnapVertices || (intersectPoint.distanceTo(gc.lineGeom.vertices[1]) < _snapResult.radius))) {\n\n                    _snapResult.geomVertex = gc.lineGeom.vertices[1];\n                    _snapResult.geomType = SnapType.SNAP_VERTEX;\n                }\n                else {\n                    _snapResult.geomType = SnapType.SNAP_EDGE;\n                }\n            }\n\n            _isSnapped = true;\n        }\n    };\n\n    this.snappingLeaflet = function(result) {\n        if (!result) {\n            return;\n        }\n        \n        var intersectPoint = result.intersectPoint;\n        _snapResult.intersectPoint = intersectPoint;\n        _snapResult.hasTopology = false;\n\n        // Determine which one should be drawn: line, circular arc or elliptical arc\n        _snapResult.radius = this.setDetectRadius(intersectPoint);\n        _snapResult.geomType = SnapType.RASTER_PIXEL;\n        _snapResult.geomVertex = intersectPoint;\n        _isSnapped = true;\n    };\n\n    this.snapMidpoint = function() {\n        _snapResult.isMidpoint = false;\n\n        // Snap midpoint for edge\n        if (_isSnapped) {\n            if (_snapResult.geomType === SnapType.SNAP_EDGE) {\n                var edge = _snapResult.geomEdge;\n                var p1 = edge.vertices[0];\n                var p2 = edge.vertices[1];\n\n                var midpoint = new THREE.Vector3((p1.x + p2.x) / 2, (p1.y + p2.y) / 2, (p1.z + p2.z) / 2);\n\n                if (_snapResult.intersectPoint.distanceTo(midpoint) < 2 * _snapResult.radius) {\n                    _snapResult.geomVertex = midpoint;\n                    _snapResult.geomType = SnapType.SNAP_MIDPOINT;\n                }\n            }\n        }\n    };\n\n    this.setPerpendicular = function(isPerpendicular) {\n        _snapResult.isPerpendicular = isPerpendicular;\n    };\n\n    this.lineStripToPieces = function(geom) {\n\n        var vertices = geom.vertices;\n        for (var i = vertices.length - 2; i > 0; i--) {\n            vertices.splice(i, 0, vertices[i]);\n        }\n    };\n\n    this.setDetectRadius = function(point) {\n\n        var navapi = _viewer.navigation;\n        var camera = navapi.getCamera();\n        var position = navapi.getPosition();\n\n        var p = point.clone();\n\n        var distance = camera.isPerspective ? p.sub(position).length()\n            : navapi.getEyeVector().length();\n\n        var fov = navapi.getVerticalFov();\n        var worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));\n\n        var viewport = navapi.getScreenViewport();\n        var _window = this.getWindow();\n        var devicePixelRatio = _window.devicePixelRatio || 1;\n        var radius = this.detectRadiusInPixels * worldHeight / (viewport.height * devicePixelRatio);\n\n        return radius;\n    };\n\n    this.handleButtonDown = function (event, button) {\n        _isDragging = true;\n        return false;\n    };\n\n    this.handleButtonUp = function (event, button) {\n        _isDragging = false;\n        return false;\n    };\n\n    this.handleMouseMove = function (event) {\n\n        if (_isDragging)\n            return false;\n\n        this.onMouseMove({ \n            x: event.canvasX, \n            y: event.canvasY \n        });\n\n        return false;\n    };\n\n    this.handleSingleTap = function(event) {\n\n        return this.handleMouseMove(event);\n    };\n\n    this.handlePressHold = function (event) {\n        \n        if (isMobileDevice()) {\n            switch( event.type )\n            {\n                case \"press\":\n                    _isPressing = true;\n                    this.onMouseMove({x: event.canvasX, y: event.canvasY});\n                    break;\n\n                case \"pressup\":\n                    this.onMouseMove({x: event.canvasX, y: event.canvasY});\n                    _isPressing = false;\n                    break;\n            }\n        }\n        return false;\n\n    };\n\n    this.handleGesture = function( event )\n    {   \n        if (isMobileDevice()) {\n            if (_isPressing) {\n                switch( event.type )\n                {\n                    case \"dragstart\":\n                        this.onMouseMove({x: event.canvasX, y: event.canvasY});\n                        break;\n\n                    case \"dragmove\":\n                        this.onMouseMove({x: event.canvasX, y: event.canvasY});\n                        break;\n\n                    case \"dragend\":\n                        this.onMouseMove({x: event.canvasX, y: event.canvasY});\n                        _isPressing = false;\n                        break;\n\n                    case \"pinchstart\":\n                        \n                        break;\n\n                    case \"pinchmove\":\n                        break;\n\n                    case \"pinchend\":\n                        break;\n                }\n            }\n        }\n\n        return false;\n    };\n\n    /**\n     * Handler to mouse move events, used to snap in markup edit mode.\n     * @private\n     */\n    this.onMouseDown = function(mousePosition) {\n        return this.onMouseMove(mousePosition);\n    };\n\n    /**\n     * Handler to mouse move events, used to snap in markup edit mode.\n     * @private\n     */\n    this.onMouseMove = function(mousePosition) {\n\n        this.clearSnapped();\n\n        var result = _viewer.impl.snappingHitTest(mousePosition.x, mousePosition.y, false);\n\n        if(!result && _snapToPixel) {\n            var vpVec = _viewer.impl.clientToViewport(mousePosition.x, mousePosition.y);\n            let point = _viewer.impl.intersectGroundViewport(vpVec);\n            result = { intersectPoint : point };\n        }\n\n        if (!result || !result.intersectPoint) \n            return false;\n\n        // 3D Snapping\n        if (result.face) {\n            this.snapping3D(result);\n        }\n        // 2D Snapping\n        else if (result.dbId || result.dbId === 0){\n            this.snapping2D(result);\n        }\n        // PDF - Leaflet Snapping\n        else {\n            this.snappingLeaflet(result);\n        }\n\n        this.snapMidpoint();\n\n        return true;\n    };\n};\n\nav.GlobalManagerMixin.call(Snapper.prototype);\n","\n// Collection of static math functions used for snapping implementation\n\n\n\n\n// Sample a single point from an ellipse with...\n//  @param {number} cx, cy               - center\n//  @param {number} rx, ry               - radii in x/y axis\n//  @param {number} startAngle, endAngle - ccw angles in radians. 0 corresponds to (xRadius, 0)\n//  @param {number} t                    - sampling position along ellipse. 0 => startAngle, 1 = endAngle\n//  @param {Vector2} [outResult]\n//  @returns {Vector2}\nexport const sampleEllipsePoint = (cx, cy, rx, ry, startAngle, endAngle, t, outResult) => {\n    \n    outResult = outResult || new THREE.Vector2();\n\n    let deltaAngle = endAngle - startAngle;\n        \n    // delta should...\n    //  - always be positive, because we want to draw counterclockwise\n    //  - always be <2Pi, because we only want to connect startAngle/endAngle - not draw the whole ellipse.\n    // This is essential if the arc passes the 2Pi boundary, e.g., starting at 350 degree and ending at 10.    \n    if (deltaAngle < 0)            deltaAngle += Math.PI * 2;\n    if (deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;\n\n    let angle = startAngle + t * deltaAngle;\n\n    outResult.x = cx + rx * Math.cos(angle);\n    outResult.y = cy + ry * Math.sin(angle);\n\n    return outResult;\n};\n\n// Force angle to be within [0, 2Pi[\nexport const normalizeAngle = (angle) => {\n    // Scale [0, 2Pi] to [0,1]\n    angle /= 2.0 * Math.PI;\n\n    // Remove integer part\n    angle -= Math.trunc(angle);\n\n    // Angle is either in [0,1] or was negative. In the latter case,\n    // it is in [-1, 0] now and we add 1 to bring it to [0,1] as well.\n    if (angle < 0) {\n        angle += 1.0;\n    }\n\n    // Scale back to [0, 2Pi] range\n    return angle * 2.0 * Math.PI;\n};\n\n// Given start/end angle of an arc, this function checks whether angle is within the arc. \n// All angles are ccw in radians. We assume the arc to be running ccw. Note that start may be > end if the arc range contains a 2*Pi mulitple.\nexport const angleInsideArc = (angle, start, end) => {\n\n    // ensure 0 <= a < 2Pi for all angles\n    angle = normalizeAngle(angle);\n    start = normalizeAngle(start);\n    end   = normalizeAngle(end);\n\n    if (start < end) {\n        return angle >= start && angle <= end;\n    }\n\n    // If start > end, we are crossing a full-circle boundary. So, the range between [start, end] is actually\n    // the circle part outside the arc.\n    // For start = end, the arc is the whole circle and the result will always be true.\n    return angle >= start || angle <= end;\n};\n\n// Find closest point to p on a circular arc. \n//  @param {Vector2} center\n//  @param {number} radius\n//  @param {number} startAngle, endAngle - ccw angles in radians. 0 means direction x+\n//  @param {Vector2} [outPoint]\n//  @param {Vector2}\nexport const nearestPointOnCircularArc = (p, center, radius, startAngle, endAngle, outPoint) => {\n\n    outPoint = outPoint || new THREE.Vector2();\n\n    // get normalized direction from circle center to p.\n    // dir = (p-center).normalized()\n    const dir = outPoint.copy(p).sub(center).normalize();\n\n    // If the point is within the arc, we are done\n    const angle = Math.atan2(dir.y, dir.x);\n    const insideArc = angleInsideArc(angle, startAngle, endAngle);\n    if (insideArc) {\n        // The ray from center towards p intersects the circle arc.\n        // So, we obtain the closest point by projecting p onto the circle.\n        //\n        // Since dir is the normalized direction from center to p, we obtain the circle projection by:\n        //  onCircleArc = center + dir * radius\n        return dir.multiplyScalar(radius).add(center);\n    }\n\n    // The closest point on the circle is not on the arc.\n    // Then the closest point must be one of the arc ends. Note that this conclusion\n    // can only be made for circles, but not for ellipses with different radii.\n    const pStart = sampleEllipsePoint(center.x, center.y, radius, radius, startAngle, endAngle, 0.0);\n    const pEnd   = sampleEllipsePoint(center.x, center.y, radius, radius, startAngle, endAngle, 1.0);\n\n    const d2Start = pStart.distanceToSquared(p);\n    const d2End   = pEnd.distanceToSquared(p);\n    const startIsCloser = d2Start <= d2End;\n\n    outPoint.copy(startIsCloser ? pStart : pEnd);\n    return outPoint;\n};\n\n// Compute intersection of two line segments\n// based on http://www.paulbourke.net/geometry/pointlineplane/\n//  @param {Vector2} p1, p2               - First line segment\n//  @param {Vector2} p3, p4               - Second line segment\n//  @param {bool}    [checkInsideSegment] - If true, we reject line intersections outside the segment ranges\n//  @param {Vector2} [outPoint]           - Optional target vector\n//  @param {number}  [epsilon]            - Nearly-zero threshold used to determine \"nearly-parallel\" resp. \"nearly-zero-length line\"\n//  @param {Vector2|null}\nexport const intersectLines = (p1, p2, p3, p4, checkInsideSegment, outPoint, epsilon = 0.00001) => {\n    \n    const denom = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);\n    \n    // Reject if lines are parallel or one of them has zero-length\n    if (Math.abs(denom) < epsilon) {\n        return null;\n    }\n\n    // ua denotes where to find the intersection point p along segment (p1, p2):\n    //   For ua = 0, we have p = p1\n    //   For ua = 1, we have p = p2\n    let ua = (p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x);\n    ua /= denom;\n    \n    // Apply segment check\n    if (checkInsideSegment) {\n\n        // ub denotes where to find the intersection point p along segment (p3, p4)\n        let ub = (p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x);\n        ub /= denom;\n\n        // Intersection is within the segments if ua and ub are both in [0,1]\n        if (ua < 0.0 || ua > 1.0 || \n            ub < 0.0 || ub > 1.0) {\n            return null;\n        }\n    }\n    \n    outPoint = outPoint || new THREE.Vector2();\n    \n    outPoint.x = p1.x + ua * (p2.x - p1.x);\n    outPoint.y = p1.y + ua * (p2.y - p1.y);\n    return outPoint;\n};\n\n\n\n","const MeasureCommon = Autodesk.Viewing.MeasureCommon;\nconst isEqualVectors = MeasureCommon.isEqualVectors;\nconst EPSILON = MeasureCommon.EPSILON;\nconst SnapType = MeasureCommon.SnapType;\n\n    var NO_OVERLAY = 0;\n    var FACE_OVERLAY = 1;\n    var EDGE_OVERLAY = 2;\n    var POINT_OVERLAY = 3;\n    \n    var GEOMETRIES_OVERLAY = 'MeasureTool-snapper-geometries';\n    var INDICATOR_OVERLAY = 'MeasureTool-snapper-indicator';\n\n    var _geometryLineWidth = 0.3;\n    var _indicatorLineWidth = 0.2;\n    var _indicatorSize = 1.2;\n    var _point = null;\n\n    var _indicatorColor = 0xff7700;\n    var _geometryColor = 0x00CC00;\n\n    // /** @constructor */\n    export function SnapperIndicator( viewer, snapper )\n    {\n        this.viewer = viewer;\n        this.snapper = snapper;\n        this.overlayType = NO_OVERLAY;\n        this.previewsIntersectPoint = null;\n\n        this.viewer.impl.createOverlayScene(GEOMETRIES_OVERLAY);\n        this.viewer.impl.createOverlayScene(INDICATOR_OVERLAY);\n\n        this.geometryMaterial = new THREE.MeshPhongMaterial({\n            color: _geometryColor,\n            ambient: _geometryColor,\n            opacity: 0.5,\n            transparent: true,\n            depthTest: false,\n            depthWrite: false,\n            side: THREE.DoubleSide\n        });\n\n        this.indicatorMaterial = new THREE.MeshBasicMaterial({\n            color: _indicatorColor,\n            ambient: _indicatorColor,\n            opacity: 1,\n            transparent: false,\n            depthTest: false,\n            depthWrite: false,\n            side: THREE.DoubleSide\n        });\n    }\n\n    SnapperIndicator.prototype.constructor = SnapperIndicator;\n    var proto = SnapperIndicator.prototype;\n\n\n    proto.render = function() {\n\n        var snapResult = this.snapper.getSnapResult();\n\n        if (!isEqualVectors(this.previewsIntersectPoint, snapResult.intersectPoint, EPSILON)) {\n            this.clearOverlay(GEOMETRIES_OVERLAY);\n        }\n        \n        this.clearOverlay(INDICATOR_OVERLAY);\n\n        if (snapResult.isEmpty())\n            return;\n\n        if (this.snapper.renderSnappedGeometry ||\n            (snapResult.hasTopology && this.snapper.renderSnappedTopology)) {\n            this.renderGeometry(snapResult);\n        }\n        this.renderIndicator(snapResult);\n\n        this.previewsIntersectPoint = snapResult.intersectPoint.clone();\n    };\n\n    proto.removeOverlay = function(overlayName) {\n        \n        this.viewer.impl.clearOverlay(overlayName);\n        this.viewer.impl.removeOverlayScene(overlayName);\n\n    };\n\n    proto.clearOverlay = function(overlayName) {\n        \n        this.removeOverlay(overlayName);\n        this.viewer.impl.createOverlayScene(overlayName);\n\n    };\n\n    proto.clearOverlays = function() {\n        \n        this.removeOverlay(GEOMETRIES_OVERLAY);\n        this.viewer.impl.createOverlayScene(GEOMETRIES_OVERLAY);\n\n        this.removeOverlay(INDICATOR_OVERLAY);\n        this.viewer.impl.createOverlayScene(INDICATOR_OVERLAY);\n\n        this.previewsIntersectPoint = null;\n\n    };\n\n    proto.addOverlay = function(overlayName, mesh) {\n\n        this.viewer.impl.addOverlay(overlayName, mesh);\n\n    };\n\n    /**\n     * Draw the planar face\n     * @param geom -Geometry which needs to be draw.\n     * @param mesh -Mesh which is loaded.\n     */\n    proto.drawFace = function(geom, material, overlayName) {\n\n        var snapperPlane = new THREE.Mesh(geom, material, true);\n\n        if (overlayName === GEOMETRIES_OVERLAY) {\n            this.overlayType = FACE_OVERLAY;\n        }\n\n        this.addOverlay(overlayName, snapperPlane);\n\n    };\n\n    proto.cylinderMesh = function(pointX, pointY, material, width) {\n\n        var direction = new THREE.Vector3().subVectors(pointY, pointX);\n        var orientation = new THREE.Matrix4();\n        orientation.lookAt(pointX, pointY, new THREE.Object3D().up);\n        orientation.multiply(new THREE.Matrix4().set(1, 0, 0, 0,\n            0, 0, 1, 0,\n            0, -direction.length(), 0, 0,\n            0, 0, 0, 1));\n\n        width = width || 0.5;\n        var cylinder = new THREE.CylinderGeometry(width, width, 1.0, 8, 1, true);\n        var edge = new THREE.Mesh(cylinder, material);\n        cylinder = null;\n\n        edge.applyMatrix(orientation);\n        edge.position.x = (pointY.x + pointX.x) / 2;\n        edge.position.y = (pointY.y + pointX.y) / 2;\n        edge.position.z = (pointY.z + pointX.z) / 2;\n        return edge;\n\n    };\n\n    proto.renderGeometry = function(snapResult) {\n\n        if (isEqualVectors(this.previewsIntersectPoint, snapResult.intersectPoint, EPSILON)){\n            return;\n        }\n\n        switch (snapResult.geomType) {\n            case SnapType.SNAP_VERTEX:\n                 SnapType.RASTER_PIXEL;\n                this.drawPoint(snapResult.geomVertex, this.geometryMaterial, GEOMETRIES_OVERLAY);\n                break;\n\n            case SnapType.SNAP_EDGE:\n            case SnapType.SNAP_CURVEDEDGE:\n            case SnapType.SNAP_CIRCULARARC:\n            case SnapType.SNAP_MIDPOINT:\n                this.drawLine(snapResult.geomEdge, this.geometryMaterial, _geometryLineWidth, GEOMETRIES_OVERLAY);\n                break;\n\n            case SnapType.SNAP_FACE:\n            case SnapType.SNAP_CURVEDFACE:\n                this.drawFace(snapResult.geomFace, this.geometryMaterial, GEOMETRIES_OVERLAY);\n                break;\n        }\n    };\n\n    proto.renderVertexIndicator = function(snapResult) {\n\n        var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n        var scale = this.setScale(pos);\n        var length = _indicatorSize * scale;\n\n        var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n        var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n        var geom = new THREE.Geometry();\n        var p = new THREE.Vector3();\n\n        // Upper line\n        p.addVectors(pos, rightVec);\n        p.addVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        p.subVectors(pos, rightVec);\n        p.addVectors(p, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Bottom line\n        p.addVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Left line\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        p.subVectors(pos, rightVec);\n        p.addVectors(p, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Right line\n        p.addVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        p.addVectors(pos, rightVec);\n        p.addVectors(p, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    };\n\n    proto.renderMidpointIndicator = function(snapResult) {\n\n        var pos = snapResult.geomVertex;\n        var scale = this.setScale(pos);\n        var length = _indicatorSize * scale;\n\n        var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n        var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n        var geom = new THREE.Geometry();\n        var p = new THREE.Vector3();\n\n        // Bottom line\n        p.addVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Left line\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        p.addVectors(pos, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Right line\n        p.addVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        p.addVectors(pos, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    };\n\n    proto.renderEdgeIndicator = function(snapResult) {\n\n        var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n        var scale = this.setScale(pos);\n        var length = _indicatorSize * scale;\n\n        var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n        var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n        var geom = new THREE.Geometry();\n        var p = new THREE.Vector3();\n\n        // Bottom line\n        p.addVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        geom.vertices[1] = pos.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Left line\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        geom.vertices[1] = pos.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Right line\n        p.addVectors(pos, upVec);\n        geom.vertices[0] = p.clone();\n        geom.vertices[1] = pos.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    };\n\n    proto.renderCircleIndicator = function(snapResult){\n\n        var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n        this.drawCircle(pos, this.indicatorMaterial, INDICATOR_OVERLAY);\n\n    };\n\n    proto.renderPerpendicular = function(snapResult) {\n\n        var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n        var scale = this.setScale(pos);\n        var length = _indicatorSize * scale;\n\n        var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n        var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n        var geom = new THREE.Geometry();\n        var p = new THREE.Vector3();\n\n        // Upper line\n        geom.vertices[0] = pos.clone();\n        p.subVectors(pos, rightVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Bottom line\n        p.addVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Left line\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        p.subVectors(pos, rightVec);\n        p.addVectors(p, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Right line\n        geom.vertices[0] = pos.clone();\n        p.subVectors(pos, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    };\n\n    proto.renderPixelIndicator = function(snapResult) {\n\n        var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n        var scale = this.setScale(pos);\n        var length = _indicatorSize * scale;\n\n        var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n        var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n        var geom = new THREE.Geometry();\n        var p = new THREE.Vector3();\n\n        // Top-left line\n        p.subVectors(pos, rightVec);\n        p.addVectors(p,upVec);\n        geom.vertices[0] = p.clone();\n        geom.vertices[1] = pos.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Top-right line\n        p.addVectors(pos, rightVec);\n        p.addVectors(p,upVec);\n        geom.vertices[0] = p.clone();\n        geom.vertices[1] = pos.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Bottom-right line\n        p.addVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        geom.vertices[1] = pos.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n        \n        // Bottom-left line\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        geom.vertices[1] = pos.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n\n    };\n\n    proto.renderIndicator = function(snapResult) {\n\n        if (snapResult.isPerpendicular) {\n            this.renderPerpendicular(snapResult);\n            return;\n        }\n\n        switch (snapResult.geomType) {\n            case SnapType.SNAP_VERTEX:            \n                this.renderVertexIndicator(snapResult);\n                break;\n\n            case SnapType.SNAP_INTERSECTION:\n                this.renderVertexIndicator(snapResult);\n                break;\n    \n            case SnapType.SNAP_MIDPOINT:\n                this.renderMidpointIndicator(snapResult);\n                break;\n\n            case SnapType.SNAP_CIRCLE_CENTER:\n                this.renderCircleIndicator(snapResult);\n                break;\n\n            case SnapType.SNAP_EDGE:\n            case SnapType.SNAP_CURVEDEDGE:\n                this.renderEdgeIndicator(snapResult);\n                break;\n\n            case SnapType.SNAP_CIRCULARARC:\n                if (this.viewer.model.is2d()) {\n                    this.renderVertexIndicator(snapResult);\n                } else {\n                    this.renderCircleIndicator(snapResult);\n                }\n                break;\n\n            case SnapType.SNAP_FACE:\n            case SnapType.SNAP_CURVEDFACE:\n                this.renderVertexIndicator(snapResult);\n                break;\n\n            case SnapType.RASTER_PIXEL:\n                this.renderPixelIndicator(snapResult);\n                break;\n        }\n    };\n\n    proto.drawLine = function(geom, material, width, overlayName) {\n\n        // Line Pieces\n        if (overlayName === GEOMETRIES_OVERLAY) {\n            this.overlayType = EDGE_OVERLAY;    \n        }\n        \n        for (var i = 0; i < geom.vertices.length; i += 2) {\n            var cylinder = this.cylinderMesh(geom.vertices[i], geom.vertices[i + 1], material, width);\n            this.setEdgeScale(cylinder);\n            this.addOverlay(overlayName, cylinder);\n        }\n    };\n\n    proto.drawPoint = function(point, material, overlayName) {\n        \n        // Because every point is snappable in PDFs, don't display the green dot for PDFs.\n        if (this.viewer.model.getData().isLeaflet) {\n            return;\n        }\n\n        if (!_point)\n            _point = new THREE.SphereGeometry(1.0);\n\n        var pointMesh = new THREE.Mesh(_point, material);\n        pointMesh.position.set(point.x, point.y, point.z);\n\n        this.setPointScale(pointMesh);\n\n        if (overlayName === GEOMETRIES_OVERLAY) {\n            this.overlayType = POINT_OVERLAY;\n        }\n\n        this.addOverlay(overlayName, pointMesh);\n\n    };\n\n    proto.drawCircle = function(point, material, overlayName) {\n\n        var torus = new THREE.TorusGeometry(_indicatorSize, _indicatorLineWidth, 2, 20);\n        var torusMesh = new THREE.Mesh(torus, material);\n        torusMesh.lookAt(this.viewer.navigation.getEyeVector().normalize());\n        torus = null;\n\n        torusMesh.position.set(point.x, point.y, point.z);\n\n        this.setCircleScale(torusMesh);\n\n        this.addOverlay(overlayName, torusMesh);\n\n    };\n\n    proto.setScale = function (point) {\n\n        var pixelSize = 5;\n\n        var navapi = this.viewer.navigation;\n        var camera = navapi.getCamera();\n        var position = navapi.getPosition();\n\n        var p = point.clone();\n\n        var distance = camera.isPerspective ? p.sub(position).length()\n            : navapi.getEyeVector().length();\n\n        var fov = navapi.getVerticalFov();\n        var worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));\n\n        var viewport = navapi.getScreenViewport();\n        var scale = pixelSize * worldHeight / viewport.height;\n\n        return scale;\n\n    };\n\n    proto.setPointScale = function (pointMesh) {\n\n        var scale = this.setScale(pointMesh.position);\n        pointMesh.scale.x = scale;\n        pointMesh.scale.y = scale;\n        pointMesh.scale.z = scale;\n\n    };\n\n    proto.setCircleScale = function (torusMesh) {\n\n        var scale = this.setScale(torusMesh.position);\n        torusMesh.scale.x = scale;\n        torusMesh.scale.y = scale;\n    };\n\n    proto.setEdgeScale = function (cylinderMesh) {\n\n        var scale = this.setScale(cylinderMesh.position);\n        cylinderMesh.scale.x = scale;\n        cylinderMesh.scale.z = scale;\n    };\n\n    proto.updatePointScale = function(overlayName) {\n\n        if (this.overlayType != POINT_OVERLAY)\n            return;\n\n        var overlay = this.viewer.impl.overlayScenes[overlayName];\n        if (overlay) {\n            var scene = overlay.scene;\n\n            for (var i = 0; i < scene.children.length; i++) {\n                var pointMesh = scene.children[i];\n                if (pointMesh) {\n\n                    this.setPointScale(pointMesh);\n                }\n            }\n        }\n    };\n\n    proto.updateEdgeScale = function(overlayName) {\n\n        if (this.overlayType != EDGE_OVERLAY)\n            return;\n\n        var overlay = this.viewer.impl.overlayScenes[overlayName];\n        if (overlay) {\n            var scene = overlay.scene;\n\n            for (var i = 0; i < scene.children.length; i++) {\n                var cylinderMesh = scene.children[i];\n                if (cylinderMesh) {\n\n                    this.setEdgeScale(cylinderMesh);\n                }\n            }\n        }\n    };\n\n    proto.onCameraChange = function () {\n\n        this.updatePointScale(GEOMETRIES_OVERLAY);\n        this.updateEdgeScale(GEOMETRIES_OVERLAY);\n\n        // if (!this.snapper.markupMode) {\n            this.render();\n        // }\n    };\n\n    proto.destroy = function() {\n\n        this.removeOverlay(GEOMETRIES_OVERLAY);\n        this.removeOverlay(INDICATOR_OVERLAY);\n\n        if (_point) {\n            _point.dispose();\n            _point = null;\n        }\n    };\n\n","\nexport function getGlobal() {\n    return (typeof window !== \"undefined\" && window !== null)\n            ? window\n            : (typeof self !== \"undefined\" && self !== null)\n                ? self\n                : global;\n}\n\nconst _window = getGlobal();\nconst _document = _window && _window.document;\n\nexport const isBrowser = (typeof navigator !== \"undefined\");\n\nexport const isNodeJS = function() {\n    return !isBrowser;\n};\n\nexport let isIE11 = isBrowser && !!navigator.userAgent.match(/Edge|Trident\\/7\\./);\n\n// fix IE events\nif(typeof window !== \"undefined\" && isIE11){\n    (function () {\n        function CustomEvent ( event, params ) {\n            params = params || { bubbles: false, cancelable: false, detail: undefined };\n            var evt = _document.createEvent( 'CustomEvent' );\n            evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );\n            return evt;\n        }\n\n        CustomEvent.prototype = _window.CustomEvent.prototype;\n\n        _window.CustomEvent = CustomEvent;\n    })();\n}\n\n// IE does not implement ArrayBuffer slice. Handy!\nif (!ArrayBuffer.prototype.slice) {\n    ArrayBuffer.prototype.slice = function(start, end) {\n        // Normalize start/end values\n        if (!end || end > this.byteLength) {\n            end = this.byteLength;\n        }\n        else if (end < 0) {\n            end = this.byteLength + end;\n            if (end < 0) end = 0;\n        }\n        if (start < 0) {\n            start = this.byteLength + start;\n            if (start < 0) start = 0;\n        }\n\n        if (end <= start) {\n            return new ArrayBuffer();\n        }\n\n        // Bytewise copy- this will not be fast, but what choice do we have?\n        var len = end - start;\n        var view = new Uint8Array(this, start, len);\n        var out = new Uint8Array(len);\n        for (var i = 0; i < len; i++) {\n            out[i] = view[i];\n        }\n        return out.buffer;\n    };\n}\n\n// IE doesn't implement Math.log2\n(function(){\n    Math.log2 = Math.log2 || function(x) {\n        return Math.log(x) / Math.LN2;\n    };\n})();\n\n//The BlobBuilder object\nif (typeof window !== \"undefined\")\n    _window.BlobBuilder = _window.BlobBuilder || _window.WebKitBlobBuilder || _window.MozBlobBuilder || _window.MSBlobBuilder;\n\n\n// Launch full screen on the given element with the available method\nexport function launchFullscreen(element, options) {\n    if (element.requestFullscreen) {\n        element.requestFullscreen(options);\n    } else if (element.mozRequestFullScreen) {\n        element.mozRequestFullScreen(options);\n    } else if (element.webkitRequestFullscreen) {\n        element.webkitRequestFullscreen(options);\n    } else if (element.msRequestFullscreen) {\n        element.msRequestFullscreen(options);\n    }\n};\n\n// Exit full screen with the available method\nexport function exitFullscreen(_document) {\n    if (!inFullscreen(_document)) {\n        return;\n    }\n    if (_document.exitFullscreen) {\n        _document.exitFullscreen();\n    } else if (_document.mozCancelFullScreen) {\n        _document.mozCancelFullScreen();\n    } else if (_document.webkitExitFullscreen) {\n        _document.webkitExitFullscreen();\n    } else if (_document.msExitFullscreen) {\n        _document.msExitFullscreen();\n    }\n};\n\n// Determines if the browser is in full screen\nexport function inFullscreen(_document){\n\n    // Special case for Ms-Edge that has webkitIsFullScreen with correct value\n    // and fullscreenEnabled with wrong value (thanks MS)\n\n    if (\"webkitIsFullScreen\" in _document) return !!(_document.webkitIsFullScreen);\n    if (\"fullscreenElement\" in _document) return !!(_document.fullscreenElement);\n    if (\"mozFullScreenElement\" in _document) return !!(_document.mozFullScreenElement);\n    if (\"msFullscreenElement\" in _document) return !!(_document.msFullscreenElement);\n\n    return !!(_document.querySelector(\".viewer-fill-browser\")); // Fallback for iPad\n};\n\nexport function fullscreenElement(_document) {\n    return _document.fullscreenElement || _document.mozFullScreenElement || _document.webkitFullscreenElement || _document.msFullscreenElement;\n};\n\nexport function isFullscreenAvailable(element) {\n    return element.requestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen || element.msRequestFullscreen;\n};\n\n// Get the version of the android device through user agent.\n// Return the version string of android device, e.g. 4.4, 5.0...\nexport function getAndroidVersion(ua) {\n    ua = ua || navigator.userAgent;\n    var match = ua.match(/Android\\s([0-9\\.]*)/);\n    return match ? match[1] : false;\n};\n\n// Determine if this is a touch or notouch device.\nexport function isTouchDevice() {\n    /*\n    // Temporarily disable touch support through hammer on Android 5, to debug\n    // some specific gesture issue with Chromium WebView when loading viewer3D.js.\n    if (parseInt(getAndroidVersion()) == 5) {\n        return false;\n    }\n    */\n\n    return (typeof window !== 'undefined' && ('ontouchstart' in window || navigator.maxTouchPoints > 0));\n};\n\n// Since iOS 13, the iPad identifies itself as a desktop, so the only way to reliably detect is to search for multitouch capabilities\n// (insofar as no other Apple device implements it)\nconst _isIOSDevice = isBrowser && (/ip(ad|hone|od)/.test(navigator.userAgent.toLowerCase()) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1));\nexport function isIOSDevice() {\n    return _isIOSDevice;\n}\n\nconst _isAndroidDevice = isBrowser && (navigator.userAgent.toLowerCase().indexOf('android') !== -1);\nexport function isAndroidDevice() {\n    return _isAndroidDevice;\n}\n\nexport function isMobileDevice() {\n    if (!isBrowser) return false;\n    return isIOSDevice() || isAndroidDevice();\n};\n\nexport function isSafari() {\n    if (!isBrowser) return false;\n    var _ua = navigator.userAgent.toLowerCase();\n    return (_ua.indexOf(\"safari\") !== -1) && (_ua.indexOf(\"chrome\") === -1);\n};\n\nexport function isFirefox() {\n    if (!isBrowser) return false;\n    var _ua = navigator.userAgent.toLowerCase();\n    return (_ua.indexOf(\"firefox\") !== -1);\n};\n\nexport function isChrome() {\n    if (!isBrowser) return false;\n    var _ua = navigator.userAgent.toLowerCase();\n    return (_ua.indexOf(\"chrome\") !== -1);\n};\n\nexport function isMac() {\n    if (!isBrowser) return false;\n    var _ua = navigator.userAgent.toLowerCase();\n    return  (_ua.indexOf(\"mac os\") !== -1);\n};\n\nexport function isWindows() {\n    if (!isBrowser) return false;\n    var _ua = navigator.userAgent.toLowerCase();\n    return  (_ua.indexOf(\"win32\") !== -1 || _ua.indexOf(\"windows\") !== -1);\n};\n\nexport function ObjectAssign(des, src) {\n    for (var key in src) {\n        if (src.hasOwnProperty(key))\n            des[key] = src[key];\n    }\n    return des;\n};\n\n\n// Hack to work around Safari's use of pinch and pan inside the viewer canvas.\nfunction disableTouchSafari(event) {\n    var xOff = _window.hasOwnProperty(\"pageXOffset\") ? _window.pageXOffset : _document.documentElement.scrollLeft;\n    var yOff = _window.hasOwnProperty(\"pageYOffset\") ? _window.pageYOffset : _document.documentElement.scrollTop;\n\n    // event.pageX and event.pageY returned undefined through Chrome console device mode\n    var pageX = typeof event.pageX === \"undefined\" ? event.changedTouches[0].pageX : event.pageX;\n    var pageY = typeof event.pageY === \"undefined\" ? event.changedTouches[0].pageY : event.pageY;\n\n    // If we aren't inside the canvas, then allow default propagation of the event\n    var element = _document.elementFromPoint(pageX - xOff, pageY - yOff);\n    if (!element || element.nodeName !== 'CANVAS')\n        return true;\n    // If it's a CANVAS, check that it's owned by us\n    if (element.getAttribute('data-viewer-canvas' !== 'true'))\n        return true;\n    // Inside the canvas, prevent the event from propagating to Safari'safely\n    // standard handlers, which will pan and zoom the page.\n    event.preventDefault();\n    return false;\n};\n\n// Hack to work around Safari's use of pinch and pan inside the viewer canvas.\nexport function disableDocumentTouchSafari() {\n    if (isMobileDevice() && isSafari()) {\n        // Safari mobile disable default touch handling inside viewer canvas\n        // Use capture to make sure Safari doesn't capture the touches and prevent\n        // us from disabling them.\n        _document.documentElement.addEventListener('touchstart', disableTouchSafari, true);\n        _document.documentElement.addEventListener('touchmove', disableTouchSafari, true);\n        _document.documentElement.addEventListener('touchcanceled', disableTouchSafari, true);\n        _document.documentElement.addEventListener('touchend', disableTouchSafari, true);\n    }\n};\n\n// Hack to work around Safari's use of pinch and pan inside the viewer canvas.\n// This method is not being invoked explicitly.\nexport function enableDocumentTouchSafari() {\n    if (isMobileDevice() && isSafari()) {\n        // Safari mobile disable default touch handling inside viewer canvas\n        // Use capture to make sure Safari doesn't capture the touches and prevent\n        // us from disabling them.\n        _document.documentElement.removeEventListener('touchstart', disableTouchSafari, true);\n        _document.documentElement.removeEventListener('touchmove', disableTouchSafari, true);\n        _document.documentElement.removeEventListener('touchcanceled', disableTouchSafari, true);\n        _document.documentElement.removeEventListener('touchend', disableTouchSafari, true);\n    }\n};\n\n\n// Convert touchstart event to click to remove the delay between the touch and\n// the click event which is sent after touchstart with about 300ms deley.\n// Should be used in UI elements on touch devices.\nexport function touchStartToClick(e) {\n    // Buttons that activate fullscreen are a special case. The HTML5 fullscreen spec\n    // requires the original user gesture signal to avoid a security issue.  See LMV-2396 and LMV-2326\n    if ((e.target.className.indexOf(\"fullscreen\")>-1) || (e.target.className.indexOf(\"webvr\")>-1))\n        return;\n    e.preventDefault();  // Stops the firing of delayed click event.\n    e.stopPropagation();\n    e.target.click();    // Maps to immediate click.\n};\n\n//Safari doesn't have the Performance object\n//We only need the now() function, so that's easy to emulate.\n(function() {\n    var global = getGlobal();\n    if (!global.performance)\n        global.performance = Date;\n})();\n\n// Polyfill for IE and Safari\n// https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\nNumber.isInteger = Number.isInteger || function(value) {\n    return typeof value === \"number\" &&\n        isFinite(value) &&\n        Math.floor(value) === value;\n};\n\n// Polyfill for IE\nString.prototype.repeat = String.prototype.repeat || function(count) {\n    if (count < 1) return '';\n    var result = '', pattern = this.valueOf();\n    while (count > 1) {\n        if (count & 1) result += pattern;\n        count >>= 1, pattern += pattern;\n    }\n    return result + pattern;\n};\n\n// Polyfill for IE\n// It doesn't support negative values for start and end; it complicates the code using this function.\nif (!Array.prototype.fill) {\n    Object.defineProperty(Array.prototype, \"fill\", {\n        enumerable: false,\n        value: function(value, start, end) {\n            start = (start === undefined) ? 0 : start;\n            end = (end === undefined) ? this.length : end;\n            for (var i=start; i<end; ++i) \n                this[i] = value;\n        }\n    });\n}\n// Polyfill for IE\nInt32Array.prototype.lastIndexOf = Int32Array.prototype.lastIndexOf || function(searchElement, fromIndex) {\n    return Array.prototype.lastIndexOf.call(this, searchElement, fromIndex);\n};\n\n// Polyfill for IE\n// It doesn't support negative values for start and end; it complicates the code using this function.\nif (!Array.prototype.find) {\n    Object.defineProperty(Array.prototype, \"find\", {\n        enumerable: false,\n        value: function(callback, _this) {\n            var len = this.length;\n            for (var i=0; i<len; ++i) {\n                var item = this[i];\n                if (callback.call(_this, item, i, this))\n                    return item;\n            }\n            return undefined;\n        }\n    });\n}\n\n// Polyfill for IE\nif (typeof Object.assign != 'function') {\n    // Must be writable: true, enumerable: false, configurable: true\n    Object.defineProperty(Object, \"assign\", {\n        value: function assign(target, varArgs) { // .length of function is 2\n            'use strict';\n            if (target == null) { // TypeError if undefined or null\n                throw new TypeError('Cannot convert undefined or null to object');\n            }\n\n            var to = Object(target);\n\n            for (var index = 1; index < arguments.length; index++) {\n                var nextSource = arguments[index];\n\n                if (nextSource != null) { // Skip over if undefined or null\n                    for (var nextKey in nextSource) {\n                        // Avoid bugs when hasOwnProperty is shadowed\n                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                            to[nextKey] = nextSource[nextKey];\n                        }\n                    }\n                }\n            }\n            return to;\n        },\n        writable: true,\n        configurable: true\n    });\n}\n\n// Polyfill for IE and iOS devices\nif (typeof window !== \"undefined\" && (isIE11 || isIOSDevice()) && !HTMLCanvasElement.prototype.toBlob) {\n    Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {\n        value: function (callback, type, quality) {\n        var canvas = this;\n        setTimeout(function() {\n    \n            var binStr = atob( canvas.toDataURL(type, quality).split(',')[1] ),\n                len = binStr.length,\n                arr = new Uint8Array(len);\n    \n            for (var i = 0; i < len; i++ ) {\n            arr[i] = binStr.charCodeAt(i);\n            }\n    \n            callback( new Blob( [arr], {type: type || 'image/png'} ) );\n    \n        });\n        }\n    });\n}\n\n// Polyfill for IE (LMV-3823)\nif (!Uint8Array.prototype.slice) {\n\n  // This will work for genuine arrays, array-like objects, \n  // NamedNodeMap (attributes, entities, notations),\n  // NodeList (e.g., getElementsByTagName), HTMLCollection (e.g., childNodes),\n  // and will not fail on other DOM objects (as do DOM elements in IE < 9)\n  Uint8Array.prototype.slice = function(begin, end) {\n    // IE < 9 gets unhappy with an undefined end argument\n    end = (typeof end !== 'undefined') ? end : this.length;\n\n    // For native Array objects, we use the native slice function\n    if (Object.prototype.toString.call(this) === '[object Array]'){\n      return _slice.call(this, begin, end); \n    }\n\n    // For array like object we handle it ourselves.\n    var i, cloned = [],\n      size, len = this.length;\n\n    // Handle negative value for \"begin\"\n    var start = begin || 0;\n    start = (start >= 0) ? start : Math.max(0, len + start);\n\n    // Handle negative value for \"end\"\n    var upTo = (typeof end == 'number') ? Math.min(end, len) : len;\n    if (end < 0) {\n      upTo = len + end;\n    }\n\n    // Actual expected size of the slice\n    size = upTo - start;\n\n    if (size > 0) {\n      cloned = new Array(size);\n      if (this.charAt) {\n        for (i = 0; i < size; i++) {\n          cloned[i] = this.charAt(start + i);\n        }\n      } else {\n        for (i = 0; i < size; i++) {\n          cloned[i] = this[start + i];\n        }\n      }\n    }\n\n    return cloned;\n  }\n}\n    "],"sourceRoot":""}