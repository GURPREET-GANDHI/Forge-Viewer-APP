/*!
 * LMV v7.11.0
 * 
 * Copyright 2020 Autodesk, Inc.
 * All rights reserved.
 * 
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 * 
 * Autodesk Forge Viewer Usage Limitations:
 * 
 * The Autodesk Forge viewer can only be used to view files generated by
 * Autodesk Forge services. The Autodesk Forge Viewer JavaScript must be
 * delivered from an Autodesk hosted URL.
 */
Autodesk.Extensions.Snapping =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./extensions/Snapping/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./extensions/Snapping/SnapMath.js":
/*!*****************************************!*\
  !*** ./extensions/Snapping/SnapMath.js ***!
  \*****************************************/
/*! exports provided: sampleEllipsePoint, normalizeAngle, angleInsideArc, nearestPointOnCircularArc, intersectLines */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sampleEllipsePoint", function() { return sampleEllipsePoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeAngle", function() { return normalizeAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angleInsideArc", function() { return angleInsideArc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nearestPointOnCircularArc", function() { return nearestPointOnCircularArc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersectLines", function() { return intersectLines; });

// Collection of static math functions used for snapping implementation




// Sample a single point from an ellipse with...
//  @param {number} cx, cy               - center
//  @param {number} rx, ry               - radii in x/y axis
//  @param {number} startAngle, endAngle - ccw angles in radians. 0 corresponds to (xRadius, 0)
//  @param {number} t                    - sampling position along ellipse. 0 => startAngle, 1 = endAngle
//  @param {Vector2} [outResult]
//  @returns {Vector2}
var sampleEllipsePoint = function sampleEllipsePoint(cx, cy, rx, ry, startAngle, endAngle, t, outResult) {

  outResult = outResult || new THREE.Vector2();

  var deltaAngle = endAngle - startAngle;

  // delta should...
  //  - always be positive, because we want to draw counterclockwise
  //  - always be <2Pi, because we only want to connect startAngle/endAngle - not draw the whole ellipse.
  // This is essential if the arc passes the 2Pi boundary, e.g., starting at 350 degree and ending at 10.    
  if (deltaAngle < 0) deltaAngle += Math.PI * 2;
  if (deltaAngle > Math.PI * 2) deltaAngle -= Math.PI * 2;

  var angle = startAngle + t * deltaAngle;

  outResult.x = cx + rx * Math.cos(angle);
  outResult.y = cy + ry * Math.sin(angle);

  return outResult;
};

// Force angle to be within [0, 2Pi[
var normalizeAngle = function normalizeAngle(angle) {
  // Scale [0, 2Pi] to [0,1]
  angle /= 2.0 * Math.PI;

  // Remove integer part
  angle -= Math.trunc(angle);

  // Angle is either in [0,1] or was negative. In the latter case,
  // it is in [-1, 0] now and we add 1 to bring it to [0,1] as well.
  if (angle < 0) {
    angle += 1.0;
  }

  // Scale back to [0, 2Pi] range
  return angle * 2.0 * Math.PI;
};

// Given start/end angle of an arc, this function checks whether angle is within the arc. 
// All angles are ccw in radians. We assume the arc to be running ccw. Note that start may be > end if the arc range contains a 2*Pi mulitple.
var angleInsideArc = function angleInsideArc(angle, start, end) {

  // ensure 0 <= a < 2Pi for all angles
  angle = normalizeAngle(angle);
  start = normalizeAngle(start);
  end = normalizeAngle(end);

  if (start < end) {
    return angle >= start && angle <= end;
  }

  // If start > end, we are crossing a full-circle boundary. So, the range between [start, end] is actually
  // the circle part outside the arc.
  // For start = end, the arc is the whole circle and the result will always be true.
  return angle >= start || angle <= end;
};

// Find closest point to p on a circular arc. 
//  @param {Vector2} center
//  @param {number} radius
//  @param {number} startAngle, endAngle - ccw angles in radians. 0 means direction x+
//  @param {Vector2} [outPoint]
//  @param {Vector2}
var nearestPointOnCircularArc = function nearestPointOnCircularArc(p, center, radius, startAngle, endAngle, outPoint) {

  outPoint = outPoint || new THREE.Vector2();

  // get normalized direction from circle center to p.
  // dir = (p-center).normalized()
  var dir = outPoint.copy(p).sub(center).normalize();

  // If the point is within the arc, we are done
  var angle = Math.atan2(dir.y, dir.x);
  var insideArc = angleInsideArc(angle, startAngle, endAngle);
  if (insideArc) {
    // The ray from center towards p intersects the circle arc.
    // So, we obtain the closest point by projecting p onto the circle.
    //
    // Since dir is the normalized direction from center to p, we obtain the circle projection by:
    //  onCircleArc = center + dir * radius
    return dir.multiplyScalar(radius).add(center);
  }

  // The closest point on the circle is not on the arc.
  // Then the closest point must be one of the arc ends. Note that this conclusion
  // can only be made for circles, but not for ellipses with different radii.
  var pStart = sampleEllipsePoint(center.x, center.y, radius, radius, startAngle, endAngle, 0.0);
  var pEnd = sampleEllipsePoint(center.x, center.y, radius, radius, startAngle, endAngle, 1.0);

  var d2Start = pStart.distanceToSquared(p);
  var d2End = pEnd.distanceToSquared(p);
  var startIsCloser = d2Start <= d2End;

  outPoint.copy(startIsCloser ? pStart : pEnd);
  return outPoint;
};

// Compute intersection of two line segments
// based on http://www.paulbourke.net/geometry/pointlineplane/
//  @param {Vector2} p1, p2               - First line segment
//  @param {Vector2} p3, p4               - Second line segment
//  @param {bool}    [checkInsideSegment] - If true, we reject line intersections outside the segment ranges
//  @param {Vector2} [outPoint]           - Optional target vector
//  @param {number}  [epsilon]            - Nearly-zero threshold used to determine "nearly-parallel" resp. "nearly-zero-length line"
//  @param {Vector2|null}
var intersectLines = function intersectLines(p1, p2, p3, p4, checkInsideSegment, outPoint) {var epsilon = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0.00001;

  var denom = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);

  // Reject if lines are parallel or one of them has zero-length
  if (Math.abs(denom) < epsilon) {
    return null;
  }

  // ua denotes where to find the intersection point p along segment (p1, p2):
  //   For ua = 0, we have p = p1
  //   For ua = 1, we have p = p2
  var ua = (p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x);
  ua /= denom;

  // Apply segment check
  if (checkInsideSegment) {

    // ub denotes where to find the intersection point p along segment (p3, p4)
    var ub = (p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x);
    ub /= denom;

    // Intersection is within the segments if ua and ub are both in [0,1]
    if (ua < 0.0 || ua > 1.0 ||
    ub < 0.0 || ub > 1.0) {
      return null;
    }
  }

  outPoint = outPoint || new THREE.Vector2();

  outPoint.x = p1.x + ua * (p2.x - p1.x);
  outPoint.y = p1.y + ua * (p2.y - p1.y);
  return outPoint;
};

/***/ }),

/***/ "./extensions/Snapping/Snapper.js":
/*!****************************************!*\
  !*** ./extensions/Snapping/Snapper.js ***!
  \****************************************/
/*! exports provided: Snapper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Snapper", function() { return Snapper; });
/* harmony import */ var _SnapperIndicator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SnapperIndicator.js */ "./extensions/Snapping/SnapperIndicator.js");
/* harmony import */ var _src_compat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/compat.js */ "./src/compat.js");
/* harmony import */ var _src_wgs_scene_VertexBufferReader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../src/wgs/scene/VertexBufferReader.js */ "./src/wgs/scene/VertexBufferReader.js");
/* harmony import */ var _SnapMath_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SnapMath.js */ "./extensions/Snapping/SnapMath.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}





var MeasureCommon = Autodesk.Viewing.MeasureCommon;
var EPSILON = MeasureCommon.EPSILON;
var SnapType = MeasureCommon.SnapType;
var SnapResult = MeasureCommon.SnapResult;

var SNAP_PRECISION = 0.001;

var av = Autodesk.Viewing;

function isEqualWithPrecision(a, b) {
  return Math.abs(a - b) <= SNAP_PRECISION;
}

function isEqualVectorsWithPrecision(v1, v2) {
  return Math.abs(v1.x - v2.x) <= SNAP_PRECISION &&
  Math.abs(v1.y - v2.y) <= SNAP_PRECISION &&
  Math.abs(v1.z - v2.z) <= SNAP_PRECISION;
}

function isInverseVectorsWithPrecision(v1, v2) {
  return Math.abs(v1.x + v2.x) <= SNAP_PRECISION &&
  Math.abs(v1.y + v2.y) <= SNAP_PRECISION &&
  Math.abs(v1.z + v2.z) <= SNAP_PRECISION;
}

function distancePointToLine(point, lineStart, lineEnd) {

  var X0 = new THREE.Vector3();
  var X1 = new THREE.Vector3();
  var distance;
  var param;

  X0.subVectors(lineStart, point);
  X1.subVectors(lineEnd, lineStart);
  param = X0.dot(X1);
  X0.subVectors(lineEnd, lineStart);
  param = -param / X0.dot(X0);

  if (param < 0) {
    distance = point.distanceTo(lineStart);
  } else
  if (param > 1) {
    distance = point.distanceTo(lineEnd);
  } else
  {
    X0.subVectors(point, lineStart);
    X1.subVectors(point, lineEnd);
    X0.cross(X1);
    X1.subVectors(lineEnd, lineStart);

    distance = Math.sqrt(X0.dot(X0)) / Math.sqrt(X1.dot(X1));
  }

  return distance;
};

var SnapCandidateType = {
  Unknown: 0,
  Line: 1,
  CircularArc: 2,
  EllipticalArc: 3 };


// A SnapCandidate references a single segment (line or arc) that we could snap to.
var SnapCandidate = /*#__PURE__*/function () {
  function SnapCandidate(viewportId, distance) {_classCallCheck(this, SnapCandidate);

    this.type = SnapCandidateType.Unknown;
    this.viewportId = viewportId;

    // 2d distance between original (unsnapped) position and the geometry of this candidate.
    this.distance = 0;

    // {Vector2} Start/Endpoint - only for line segments
    this.lineStart = null;
    this.lineEnd = null;

    // Fixed radius - only for CircularArcs
    this.radius = 0;

    // Separate radii - only for ellipse arcs
    this.radiusX = 0; // = major radius - by convention
    this.radiusY = 0;

    // Center point as Vector2 (for arcs)
    this.center = null;

    // Start/end angle for arcs: Ccw angle in radians. Angle 0 corresponds to direction x+.
    this.startAngle = 0;
    this.endAngle = 0;
  }_createClass(SnapCandidate, [{ key: "fromLine", value: function fromLine(

    p1, p2) {
      this.type = SnapCandidateType.Line;
      this.lineStart = p1.clone();
      this.lineEnd = p2.clone();
      return this;
    } }, { key: "fromCircularArc", value: function fromCircularArc(

    center, radius, start, end) {
      this.type = SnapCandidateType.CircularArc;
      this.center = center.clone();
      this.radius = radius;
      this.start = start;
      this.end = end;
      return this;
    } }, { key: "fromEllipticalArc", value: function fromEllipticalArc(

    center, radiusX, radiusY, start, end) {
      this.type = SnapCandidateType.EllipticalArc;
      this.center = center.clone();
      this.radiusX = radiusX;
      this.radiusY = radiusY;
      this.start = start;
      this.end = end;
      return this;
    } }, { key: "isLine", value: function isLine()

    {return this.type === SnapCandidateType.Line;} }, { key: "isCircularArc", value: function isCircularArc()
    {return this.type === SnapCandidateType.CirularArc;} }, { key: "isEllipticalArc", value: function isEllipticalArc()
    {return this.type === SnapCandidateType.EllipticalArc;}

    // Checks if the snapGeometry of this candidate intersects with another one.
    //  @param {SnapCandidate} other
    //  @param {Vector2} [optionalTarget]
    //  @returns {THREE.Vector2|null} Returns intersection point if there is one.
  }, { key: "getIntersection", value: function getIntersection(other, optionalTarget) {

      if (this.isLine() && other.isLine()) {
        // Note: We do the intersections on the whole line - not just the intersections.
        // Reason is:
        //  a) Otherwise, it would not snap if you are slightly outline of one line segment
        //  b) By definition, we get only very close segment candidates anyway
        return Object(_SnapMath_js__WEBPACK_IMPORTED_MODULE_3__["intersectLines"])(this.lineStart, this.lineEnd, other.lineStart, other.lineEnd, false, optionalTarget);
      }

      // TODO: Currently, we only support snapping to line-line intersections
    } }]);return SnapCandidate;}();
;

// Checks if we can snap to an intersection of two close segments (each can be a line or arcs).
//  @param {SnapCandidate[]} candidates     - Snap candidate geometries collected in GeometryCallback. Assumed to be within snapRadius.
//  @param {TREE.Vector3}    intersectPoint - Unsnapped original position
//  @param {number}          snapRadius
//  @returns {Object|null} If an intersection snap is found, the result contains:
//                    {
//                        viewportId  // number
//                        snapPoint   // (THREE.Vector3)
//                    }
var findIntersectionSnap = function findIntersectionSnap(candidates, intersectPoint, snapRadius) {

  // Sort snapping candidates by increasing distance
  // Strictly speaking, we just need the best two ones. But the number of candidates within the snapping
  // distance is generally small anyway - and working with a sorted array is more flexible to incrementally
  // make the snapping smarter later.
  var byDistance = function byDistance(ca, cb) {return ca.distance - cb.distance;};
  candidates.sort(byDistance);

  // Stop here if we don't have enough candidates for an intersection
  if (candidates.length < 2) {
    return null;
  }

  // Init result object
  var result = {
    // Just use the one of the first candidate. There is no unique viewportId when using an intersection.
    viewportId: candidates[0].viewportId,

    // Snapping happens in 2d - so we set z in advance and just keep the original value.
    // Note: Snapper generally needs some revision if we use it for planes that are not perpendicular to the viewing direction.
    snapPoint: new THREE.Vector3(0, 0, intersectPoint.z) };


  // Check for any candidate that intersects with the closest one we found
  var first = candidates[0];
  for (var i = 1; i < candidates.length; i++) {
    var second = candidates[i];

    // Do intersection test. If found, write it to result.snapPoint
    var found = first.getIntersection(second, result.snapPoint);
    if (!found) {
      continue;
    }

    // We found an intersection. Although we assume all candidates to be within
    // snap radius already, the intersection may still be somewhere else.
    // => Check if intersection is still within the snapRadius.
    var dist = THREE.Vector2.prototype.distanceTo.call(result.snapPoint, intersectPoint);
    if (dist < snapRadius) {
      // We found a valid intersection snap
      return result;
    }
  }
  return null;
};


/**
    * A tool that lets users attach pointer events to vertices and edges. It supports 2D and 3D models.
    *
    * @memberof Autodesk.Viewing.Extensions.Snapping
    * @alias Autodesk.Viewing.Extensions.Snapping.Snapper
    * @constructor
    */
function Snapper(viewer, options) {

  var _snapResult = new SnapResult();

  var _viewer = viewer;
  this.setGlobalManager(viewer.globalManager);

  var _options = options || {};
  var _names;

  if (_options.markupMode) {
    _names = ["snapper-markup"];
  } else {
    _names = ["snapper"];
  }

  var _priority = 60;

  var _active = false;

  var _distanceToEdge = Number.MAX_VALUE;
  var _distanceToVertex = null;

  var _isDragging = false;
  var _isPressing = false;
  var _isSnapped = false;

  var _forcedVpId = null; // the viewport index of the first selection for 2D

  var _snapToPixel = false;

  this.indicator = new _SnapperIndicator_js__WEBPACK_IMPORTED_MODULE_0__["SnapperIndicator"](viewer, this);

  this.markupMode = _options.markupMode;
  this.renderSnappedGeometry = _options.renderSnappedGeometry;
  this.renderSnappedTopology = _options.renderSnappedTopology;

  //Notice: The pixelSize should correspond to the amount of pixels per line in idAtPixels, the shape of
  //detection area is square in idAtPixels, but circle in snapper, should make their areas match roughly.
  this.detectRadiusInPixels = Object(_src_compat_js__WEBPACK_IMPORTED_MODULE_1__["isMobileDevice"])() ? 50 : 10;

  /**
                                                           * @returns {boolean} true when the tool is active
                                                           *
                                                           * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#isActive
                                                           */
  this.isActive = function () {
    return _active;
  };

  this.getNames = function () {
    return _names;
  };

  this.getName = function () {
    return _names[0];
  };

  this.getPriority = function () {
    return _priority;
  };

  /**
      * Starts intercepting pointer events.
      * Invoked automatically by the {@link ToolController}.
      *
      * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#activate
      */
  this.activate = function () {
    _active = true;

    if (!this.indicator) {
      this.indicator = new _SnapperIndicator_js__WEBPACK_IMPORTED_MODULE_0__["SnapperIndicator"](viewer, this);
    }
  };


  /**
      * Stops intercepting pointer events.
      * Invoked automatically by the {@link ToolController}.
      *
      * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#deactivate
      */
  this.deactivate = function () {
    _active = false;
    _snapToPixel = false;

    if (this.indicator) {
      this.indicator.destroy();
      this.indicator = null;
    }
  };

  this.copyResults = function (destiny) {
    _snapResult.copyTo(destiny);
  };

  this.getEdge = function () {
    return _snapResult.geomEdge;
  };

  this.getVertex = function () {
    return _snapResult.geomVertex;
  };

  this.getGeometry = function () {
    return _snapResult.getGeometry();
  };

  this.getGeometryType = function () {
    return _snapResult.geomType;
  };

  this.getIntersectPoint = function () {
    return _snapResult.intersectPoint;
  };


  /**
      * @returns {SnapResult} The snapping status of the last pointer event performed.
      *
      * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#getSnapResult
      */
  this.getSnapResult = function () {
    return _snapResult;
  };

  /**
      * Checks whether the tool's last update resulted on a snap.
      *
      * @returns {boolean} true when the last pointer event got snapped.
      *
      * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#isSnapped
      */
  this.isSnapped = function () {
    return _isSnapped;
  };

  this.clearSnapped = function () {
    _snapResult.clear();
    _isSnapped = false;
  };

  this.setViewportId = function (vpId) {
    _forcedVpId = vpId;
  };

  this.setSnapToPixel = function (enable) {
    _snapToPixel = enable;
  };

  /**
      * 3D Snapping
      * @param result -Result of Hit Test.
      */
  this.snapping3D = function (result) {

    _snapResult.snapNode = result.dbId;
    _snapResult.intersectPoint = result.intersectPoint;
    _snapResult.modelId = result.model ? result.model.id : null;

    // Avoid crash if the hit test does not belong to a model. This may happen, if a 3D overlay was hit (see Viewer3DImpl.rayIntersect).
    if (!result.model) {
      return;
    }

    var face = result.face;
    var fragIds;

    if (!result.fragId || result.fragId.length === undefined) {
      fragIds = [result.fragId];
    } else {
      fragIds = result.fragId;
    }

    // This is for Fusion model with topology data
    _snapResult.hasTopology = result.model.hasTopology();
    if (_snapResult.hasTopology) {
      this.snapping3DwithTopology(face, fragIds, result.model);
    } else {
      this.snapping3DtoMesh(face, fragIds, result.model);
    }
  };

  /**
      * Snapping order is: 1st vertices, 2nd edges, 3rd and final faces.
      */
  this.snapping3DwithTopology = function (face, fragIds, model) {

    // Because edge topology data may be in other fragments with same dbId, need to iterate all of them.
    if (_snapResult.snapNode) {
      fragIds = [];

      model.getData().instanceTree.enumNodeFragments(_snapResult.snapNode, function (fragId) {
        fragIds.push(fragId);
      }, true);
    }

    _snapResult.geomFace = _snapResult.geomEdge = _snapResult.geomVertex = null;
    _distanceToEdge = Number.MAX_VALUE;

    for (var fi = 0; fi < fragIds.length; ++fi) {

      var fragId = fragIds[fi];
      var mesh = _viewer.impl.getRenderProxy(model, fragId);
      var geometry = mesh.geometry;

      var topoIndex = model.getTopoIndex(fragId);
      var topology = model.getTopology(topoIndex);
      var facesTopology = topology.faces;
      var edgesTopology = topology.edges;

      if (!_snapResult.geomFace) {
        _snapResult.geomFace = this.faceSnappingWithTopology(face, geometry, facesTopology, mesh);

        if (_snapResult.geomFace) {
          _snapResult.geomFace.fragId = fragId;
        }

        var normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);
        _snapResult.faceNormal = face.normal.applyMatrix3(normalMatrix).normalize();
      }

      // Need to iterate all frags with same dbId, because when meshes are attached with each other, 
      // edge-topology data will only be on one mesh.
      this.edgeSnappingWithTopology(_snapResult.intersectPoint, geometry, edgesTopology, mesh);

    }

    _snapResult.geomVertex = this.vertexSnappingWithTopology(_snapResult.geomEdge, _snapResult.intersectPoint);

    if (_snapResult.geomFace) {

      // Determine which one should be drawn: face , edge or vertex
      _snapResult.radius = this.setDetectRadius(_snapResult.intersectPoint);

      if ((_options.forceSnapVertices || _distanceToVertex < _snapResult.radius) && _snapResult.geomVertex) {
        _snapResult.geomType = SnapType.SNAP_VERTEX;
      } else
      if ((_options.forceSnapEdges || _distanceToEdge < _snapResult.radius) && _snapResult.geomEdge) {

        var center = this.edgeIsCircle(_snapResult.geomEdge);
        if (center) {
          _snapResult.circularArcCenter = center;
          _snapResult.circularArcRadius = center.distanceTo(_snapResult.geomEdge.vertices[0]);
          _snapResult.geomEdge.center = _snapResult.circularArcCenter;
          _snapResult.geomEdge.radius = _snapResult.circularArcRadius;
          _snapResult.geomType = SnapType.SNAP_CIRCULARARC;
        } else
        if (this.edgeIsCurved(_snapResult.geomEdge)) {
          _snapResult.geomType = SnapType.SNAP_CURVEDEDGE;
        } else
        {
          _snapResult.geomType = SnapType.SNAP_EDGE;
        }

      } else
      {

        if (this.faceIsCurved(_snapResult.geomFace)) {
          _snapResult.geomType = SnapType.SNAP_CURVEDFACE;
        } else
        {
          _snapResult.geomType = SnapType.SNAP_FACE;
        }

      }

      _isSnapped = true;
    }
  };

  this.snapping3DtoMesh = function (face, fragIds, model) {
    for (var fi = 0; fi < fragIds.length; ++fi) {

      var fragId = fragIds[fi];
      var mesh = _viewer.impl.getRenderProxy(model, fragId);
      var geometry = mesh.geometry;

      // Note that face may also be a line {a, b} (see lineRayCast(..) in VBIntersector.js
      if (face instanceof THREE.Face3) {
        _snapResult.geomFace = this.faceSnapping(face, geometry);
      }

      if (!_snapResult.geomFace)
      continue;

      _snapResult.geomFace.applyMatrix(mesh.matrixWorld);
      _snapResult.geomEdge = this.edgeSnapping(_snapResult.geomFace, _snapResult.intersectPoint);
      _snapResult.geomVertex = this.vertexSnapping(_snapResult.geomEdge, _snapResult.intersectPoint);

      var normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);
      _snapResult.faceNormal = face.normal.applyMatrix3(normalMatrix).normalize();

      // Determine which one should be drawn: face , edge or vertex
      _snapResult.radius = this.setDetectRadius(_snapResult.intersectPoint);

      if (_options.forceSnapVertices || _distanceToVertex < _snapResult.radius) {
        _snapResult.geomType = SnapType.SNAP_VERTEX;
      } else
      if (_options.forceSnapEdges || _distanceToEdge < _snapResult.radius) {
        _snapResult.geomType = SnapType.SNAP_EDGE;
      } else
      {
        _snapResult.geomType = SnapType.SNAP_FACE;
      }

      _isSnapped = true;
      break;
    }
  };

  this.faceSnappingWithTopology = function (face, geometry, facesTopology, mesh) {

    var vA = new THREE.Vector3();
    var vB = new THREE.Vector3();
    var vC = new THREE.Vector3();

    var geom = new THREE.Geometry();

    var attributes = geometry.attributes;

    if (attributes.index !== undefined) {

      var positions = geometry.vb ? geometry.vb : attributes.position.array;
      var stride = geometry.vb ? geometry.vbstride : 3;

      // Find the index of face topology list which includes the intersect face(triangle)
      for (var i = 0; i < facesTopology.length; i++) {

        var indexList = facesTopology[i].indexList;
        var faceId = facesTopology[i].id;
        for (var j = 0; j < indexList.length; j += 3) {

          if (face.a === indexList[j]) {
            if (face.b === indexList[j + 1] && face.c === indexList[j + 2] || face.b === indexList[j + 2] && face.c === indexList[j + 1]) {
              break;
            }
          } else
          if (face.a === indexList[j + 1]) {
            if (face.b === indexList[j] && face.c === indexList[j + 2] || face.b === indexList[j + 2] && face.c === indexList[j]) {
              break;
            }
          } else
          if (face.a === indexList[j + 2]) {
            if (face.b === indexList[j] && face.c === indexList[j + 1] || face.b === indexList[j + 1] && face.c === indexList[j]) {
              break;
            }
          }
        }

        if (j < indexList.length) {
          break;
        }
      }

      if (i < facesTopology.length) {

        for (var j = 0; j < indexList.length; j += 3) {
          vA.set(
          positions[indexList[j] * stride],
          positions[indexList[j] * stride + 1],
          positions[indexList[j] * stride + 2]);

          vB.set(
          positions[indexList[j + 1] * stride],
          positions[indexList[j + 1] * stride + 1],
          positions[indexList[j + 1] * stride + 2]);

          vC.set(
          positions[indexList[j + 2] * stride],
          positions[indexList[j + 2] * stride + 1],
          positions[indexList[j + 2] * stride + 2]);


          var vIndex = geom.vertices.length;

          geom.vertices.push(vA.clone());
          geom.vertices.push(vB.clone());
          geom.vertices.push(vC.clone());

          geom.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));
        }
      }
    }

    //console.log(face);

    if (geom.vertices.length > 0) {

      geom.faceId = faceId;
      geom.applyMatrix(mesh.matrixWorld);
      return geom;
    } else
    {

      return null;
    }

  };

  /**
      * Find the closest face next to the cast ray
      * @param {THREE.Face3} face - the intersect triangle of Hit Test.
      * @param geometry - the geometry of mesh
      *
      * @private
      */
  this.faceSnapping = function (face, geometry) {

    var vA = new THREE.Vector3();
    var vB = new THREE.Vector3();
    var vC = new THREE.Vector3();

    var geom = new THREE.Geometry(); //Geometry which includes all the triangles on the same plane.



    var attributes = geometry.attributes;

    if (attributes.index !== undefined) {

      var indices = attributes.index.array || geometry.ib;
      var positions = geometry.vb ? geometry.vb : attributes.position.array;
      var stride = geometry.vb ? geometry.vbstride : 3;
      var offsets = geometry.offsets;

      if (!offsets || offsets.length === 0) {

        offsets = [{ start: 0, count: indices.length, index: 0 }];

      }

      for (var oi = 0; oi < offsets.length; ++oi) {

        var start = offsets[oi].start;
        var count = offsets[oi].count;
        var index = offsets[oi].index;

        for (var i = start; i < start + count; i += 3) {

          var a = index + indices[i];
          var b = index + indices[i + 1];
          var c = index + indices[i + 2];

          vA.set(
          positions[a * stride],
          positions[a * stride + 1],
          positions[a * stride + 2]);

          vB.set(
          positions[b * stride],
          positions[b * stride + 1],
          positions[b * stride + 2]);

          vC.set(
          positions[c * stride],
          positions[c * stride + 1],
          positions[c * stride + 2]);


          var faceNormal = THREE.Triangle.normal(vA, vB, vC);

          var va = new THREE.Vector3();
          va.set(
          positions[face.a * stride],
          positions[face.a * stride + 1],
          positions[face.a * stride + 2]);


          if (isEqualVectorsWithPrecision(faceNormal, face.normal) && isEqualWithPrecision(faceNormal.dot(vA), face.normal.dot(va)))
          {

            var vIndex = geom.vertices.length;

            geom.vertices.push(vA.clone());
            geom.vertices.push(vB.clone());
            geom.vertices.push(vC.clone());

            geom.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));

          }
        }
      }
    }

    if (geom.vertices.length > 0) {

      return this.getTrianglesOnSameFace(geom, face, positions, stride);
    } else
    {

      return null;
    }
  };

  /**
      * Find triangles on the same face with the triangle intersected with the cast ray
      * @param geom -Geometry which includes all the triangles on the same plane.
      * @param face -Triangle which intersects with the cast ray.
      * @param positions -Positions of all vertices.
      * @param stride -Stride for the interleaved buffer.
      *
      * @private
      */
  this.getTrianglesOnSameFace = function (geom, face, positions, stride) {

    var isIncludeFace = false; // Check if the intersect face is in the mesh
    var vertexIndices = geom.vertices.slice();

    var va = new THREE.Vector3();
    va.set(
    positions[face.a * stride],
    positions[face.a * stride + 1],
    positions[face.a * stride + 2]);

    var vb = new THREE.Vector3();
    vb.set(
    positions[face.b * stride],
    positions[face.b * stride + 1],
    positions[face.b * stride + 2]);

    var vc = new THREE.Vector3();
    vc.set(
    positions[face.c * stride],
    positions[face.c * stride + 1],
    positions[face.c * stride + 2]);

    var intersectFace = new THREE.Geometry();
    intersectFace.vertices.push(va);
    intersectFace.vertices.push(vb);
    intersectFace.vertices.push(vc);
    intersectFace.faces.push(new THREE.Face3(0, 1, 2));

    var vCount = [];

    do {

      vCount = [];

      for (var j = 0; j < vertexIndices.length; j += 3) {

        // The triangle which is intersected with the ray
        if (vertexIndices[j].equals(va) && vertexIndices[j + 1].equals(vb) && vertexIndices[j + 2].equals(vc)) {

          isIncludeFace = true;
          vCount.push(j);
          continue;
        }

        for (var k = 0; k < intersectFace.vertices.length; k += 3) {

          // The triangles which are on the same face with the intersected triangle
          if (this.trianglesSharedEdge(vertexIndices[j], vertexIndices[j + 1], vertexIndices[j + 2],
          intersectFace.vertices[k], intersectFace.vertices[k + 1], intersectFace.vertices[k + 2])) {

            var vIndex = intersectFace.vertices.length;
            intersectFace.vertices.push(vertexIndices[j].clone());
            intersectFace.vertices.push(vertexIndices[j + 1].clone());
            intersectFace.vertices.push(vertexIndices[j + 2].clone());
            intersectFace.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));

            vCount.push(j);
            break;
          }
        }
      }

      for (var ci = vCount.length - 1; ci >= 0; --ci) {

        vertexIndices.splice(vCount[ci], 3);

      }

    } while (vCount.length > 0);

    if (isIncludeFace) {
      return intersectFace;
    } else
    {
      return null;
    }

  };

  /**
      * Check if the two triangle share edge, the inputs are their vertices
      *
      * @private
      */
  this.trianglesSharedEdge = function (a1, a2, a3, b1, b2, b3) {

    var c1 = false;
    var c2 = false;
    var c3 = false;

    if (a1.equals(b1) || a1.equals(b2) || a1.equals(b3)) {
      c1 = true;
    }
    if (a2.equals(b1) || a2.equals(b2) || a2.equals(b3)) {
      c2 = true;
    }
    if (a3.equals(b1) || a3.equals(b2) || a3.equals(b3)) {
      c3 = true;
    }

    if (c1 & c2 || c1 & c3 || c2 & c3) {
      return true;
    }

    return false;
  };

  this.edgeSnappingWithTopology = function (intersectPoint, geometry, edgesTopology, mesh) {

    var edgeGeom = new THREE.Geometry();
    var minDistTopoIndex;
    var minDist = Number.MAX_VALUE;

    var vA = new THREE.Vector3();
    var vB = new THREE.Vector3();

    var attributes = geometry.attributes;

    if (attributes.index !== undefined && edgesTopology != undefined) {

      var positions = geometry.vb ? geometry.vb : attributes.position.array;
      var stride = geometry.vb ? geometry.vbstride : 3;

      // Find the index of edge topology list which includes the nearest edge segment to the intersect point
      for (var i = 0; i < edgesTopology.length; i++) {

        var indexList = edgesTopology[i].indexList;
        // In edges topology index list the type is LineStrip
        for (var j = 0; j < indexList.length - 1; j++) {
          vA.set(
          positions[indexList[j] * stride],
          positions[indexList[j] * stride + 1],
          positions[indexList[j] * stride + 2]);

          vB.set(
          positions[indexList[j + 1] * stride],
          positions[indexList[j + 1] * stride + 1],
          positions[indexList[j + 1] * stride + 2]);


          vA.applyMatrix4(mesh.matrixWorld);
          vB.applyMatrix4(mesh.matrixWorld);

          var dist = distancePointToLine(intersectPoint, vA, vB);
          if (dist < minDist) {
            minDist = dist;
            minDistTopoIndex = i;
          }
        }
      }

      if (minDistTopoIndex) {
        indexList = edgesTopology[minDistTopoIndex].indexList;
        for (var k = 0; k < indexList.length - 1; k++) {
          edgeGeom.vertices.push(new THREE.Vector3(positions[indexList[k] * stride], positions[indexList[k] * stride + 1], positions[indexList[k] * stride + 2]));
          // To make the line's type to LinePieces which is used by drawLine function
          edgeGeom.vertices.push(new THREE.Vector3(positions[indexList[k + 1] * stride], positions[indexList[k + 1] * stride + 1], positions[indexList[k + 1] * stride + 2]));
        }
      }
    }

    if (_distanceToEdge >= minDist && edgeGeom.vertices.length > 0) {

      _distanceToEdge = minDist;
      edgeGeom.applyMatrix(mesh.matrixWorld);
      _snapResult.geomEdge = edgeGeom;
    }
  };

  /**
      * Find the closest edge next to the intersect point
      * @param face -Face which is found by faceSnapping.
      * @param intersectPoint -IntersectPoint between cast ray and face.
      * @param mesh -The whole mesh of one fragment.
      *
      * @private
      */
  this.edgeSnapping = function (face, intersectPoint) {

    var lineGeom = new THREE.Geometry();
    var isEdge_12 = true;
    var isEdge_13 = true;
    var isEdge_23 = true;

    for (var i = 0; i < face.vertices.length; i += 3) {

      for (var j = 0; j < face.vertices.length; j += 3) {

        if (i !== j) {
          // Check edge 12
          if ((face.vertices[i].equals(face.vertices[j]) || face.vertices[i].equals(face.vertices[j + 1]) ||
          face.vertices[i].equals(face.vertices[j + 2])) && (
          face.vertices[i + 1].equals(face.vertices[j]) || face.vertices[i + 1].equals(face.vertices[j + 1]) ||
          face.vertices[i + 1].equals(face.vertices[j + 2]))) {

            isEdge_12 = false;

          }
          // Check edge 13
          if ((face.vertices[i].equals(face.vertices[j]) || face.vertices[i].equals(face.vertices[j + 1]) ||
          face.vertices[i].equals(face.vertices[j + 2])) && (
          face.vertices[i + 2].equals(face.vertices[j]) || face.vertices[i + 2].equals(face.vertices[j + 1]) ||
          face.vertices[i + 2].equals(face.vertices[j + 2]))) {

            isEdge_13 = false;

          }
          // Check edge 23
          if ((face.vertices[i + 1].equals(face.vertices[j]) || face.vertices[i + 1].equals(face.vertices[j + 1]) ||
          face.vertices[i + 1].equals(face.vertices[j + 2])) && (
          face.vertices[i + 2].equals(face.vertices[j]) || face.vertices[i + 2].equals(face.vertices[j + 1]) ||
          face.vertices[i + 2].equals(face.vertices[j + 2]))) {

            isEdge_23 = false;

          }
        }
      }

      if (isEdge_12) {

        lineGeom.vertices.push(face.vertices[i].clone());
        lineGeom.vertices.push(face.vertices[i + 1].clone());

      }
      if (isEdge_13) {

        lineGeom.vertices.push(face.vertices[i].clone());
        lineGeom.vertices.push(face.vertices[i + 2].clone());

      }
      if (isEdge_23) {

        lineGeom.vertices.push(face.vertices[i + 1].clone());
        lineGeom.vertices.push(face.vertices[i + 2].clone());

      }

      isEdge_12 = true;
      isEdge_13 = true;
      isEdge_23 = true;

    }

    //return lineGeom;

    var edgeGeom = new THREE.Geometry();
    var minDistIndex;
    var minDist = Number.MAX_VALUE;

    for (var k = 0; k < lineGeom.vertices.length; k += 2) {

      var dist = distancePointToLine(intersectPoint, lineGeom.vertices[k], lineGeom.vertices[k + 1]);

      if (dist < minDist) {
        minDist = dist;
        minDistIndex = k;
      }

    }

    edgeGeom.vertices.push(lineGeom.vertices[minDistIndex].clone());
    edgeGeom.vertices.push(lineGeom.vertices[minDistIndex + 1].clone());

    edgeGeom.vertices = this.getConnectedLineSegmentsOnSameLine(lineGeom, edgeGeom.vertices);

    _distanceToEdge = minDist;

    return edgeGeom;

  };

  this.getConnectedLineSegmentsOnSameLine = function (lineGeom, edgeVertices) {

    var vertices = lineGeom.vertices.slice();
    var va = edgeVertices[0];
    var vb = edgeVertices[1];

    var vCount = [];

    do {

      vCount = [];

      for (var j = 0; j < vertices.length; j += 2) {

        // The line which has min distance to intersection point
        if (vertices[j].equals(va) && vertices[j + 1].equals(vb)) {

          continue;
        }

        for (var k = 0; k < edgeVertices.length; k += 2) {

          // The line segments which are connected on the same line
          if (vertices[j].equals(edgeVertices[k]) || vertices[j + 1].equals(edgeVertices[k]) ||
          vertices[j].equals(edgeVertices[k + 1]) || vertices[j + 1].equals(edgeVertices[k + 1])) {

            var V0 = new THREE.Vector3();
            var V1 = new THREE.Vector3();

            V0.subVectors(edgeVertices[k], edgeVertices[k + 1]);
            V0.normalize();
            V1.subVectors(vertices[j], vertices[j + 1]);
            V1.normalize();

            //if (V0.equals(V1) || V0.equals(V1.negate())) {
            if (isEqualVectorsWithPrecision(V0, V1) || isInverseVectorsWithPrecision(V0, V1))
            {

              vCount.push(j);
              break;

            }
          }
        }
      }

      for (var ci = vCount.length - 1; ci >= 0; --ci) {

        edgeVertices.push(vertices[vCount[ci]]);
        edgeVertices.push(vertices[vCount[ci] + 1]);
        vertices.splice(vCount[ci], 2);

      }

    } while (vCount.length > 0);

    return edgeVertices;

  };

  this.vertexSnappingWithTopology = function (edge, intersectPoint) {

    var minDist = Number.MAX_VALUE;
    var point = new THREE.Vector3();

    if (edge && edge.vertices.length > 1) {
      var dist1 = intersectPoint.distanceTo(edge.vertices[0]);
      var dist2 = intersectPoint.distanceTo(edge.vertices[edge.vertices.length - 1]);

      if (dist1 <= dist2) {
        minDist = dist1;
        point = edge.vertices[0].clone();
      } else
      {
        minDist = dist2;
        point = edge.vertices[edge.vertices.length - 1].clone();
      }
    }

    _distanceToVertex = minDist;

    return point;
  };

  /**
      * Find the closest vertex next to the intersect point
      * @param edge -Edge which is found by edgeSnapping.
      * @param intersectPoint -IntersectPoint between cast ray and face.
      *
      * @private
      */
  this.vertexSnapping = function (edge, intersectPoint) {

    var minDist = Number.MAX_VALUE;
    var point = new THREE.Vector3();

    for (var i = 0; i < edge.vertices.length; ++i) {

      var dist = intersectPoint.distanceTo(edge.vertices[i]);

      if (dist < minDist - SNAP_PRECISION) {

        minDist = dist;
        point = edge.vertices[i].clone();

      }
    }

    _distanceToVertex = minDist;

    return point;
  };

  // This is only a workaround to detect if an edge is circle
  this.edgeIsCircle = function (edge) {

    var vertices = edge.vertices;

    // Exclude squares and regular polygons
    if (vertices.length < 8) {
      return false;
    }

    if (vertices[0].equals(vertices[vertices.length - 1])) {

      var center = new THREE.Vector3(0, 0, 0);
      for (var i = 0; i < vertices.length; i += 2) {
        center.add(vertices[i]);
      }
      center.divideScalar(vertices.length / 2.0);

      var radius = center.distanceTo(vertices[0]);
      for (var i = 0; i < vertices.length; i += 2) {
        if (Math.abs(center.distanceTo(vertices[i]) - radius) <= SNAP_PRECISION) {
          continue;
        } else
        {
          return false;
        }
      }
      return center;
    } else
    {
      return false;
    }
  };

  this.edgeIsCurved = function (edge) {

    var vertices = edge.vertices;

    if (vertices.length <= 2) {
      return false;
    } else
    if (vertices[0].equals(vertices[vertices.length - 1])) {
      return true;
    } else
    {
      var V1 = new THREE.Vector3();
      V1.subVectors(vertices[0], vertices[1]);

      var V2 = new THREE.Vector3();
      for (var i = 2; i < vertices.length; i += 2) {
        V2.subVectors(vertices[i], vertices[i + 1]);
        if (!isEqualVectorsWithPrecision(V1, V2)) {
          return true;
        }
      }

      return false;
    }
  };

  this.faceIsCurved = function (face) {

    var vertices = face.vertices;
    var faces = face.faces;

    if (faces.length <= 1) {
      return false;
    } else
    {
      var fN1 = THREE.Triangle.normal(vertices[faces[0].a], vertices[faces[0].b], vertices[faces[0].c]);
      var vA1 = vertices[faces[0].a];

      for (var i = 1; i < faces.length; i++) {
        var fN2 = THREE.Triangle.normal(vertices[faces[i].a], vertices[faces[i].b], vertices[faces[i].c]);
        var vA2 = vertices[faces[i].a];

        if (!isEqualVectorsWithPrecision(fN1, fN2) || !isEqualWithPrecision(fN1.dot(vA1), fN2.dot(vA2))) {
          return true;
        }
      }

      return false;
    }
  };

  this.angleVector2 = function (vector) {

    if (vector.x > 0 && vector.y >= 0) {
      return Math.atan(vector.y / vector.x);
    } else
    if (vector.x >= 0 && vector.y < 0) {
      return Math.atan(vector.y / vector.x) + Math.PI * 2;
    } else
    if (vector.x < 0 && vector.y <= 0) {
      return Math.atan(vector.y / vector.x) + Math.PI;
    } else
    if (vector.x <= 0 && vector.y > 0) {
      return Math.atan(vector.y / vector.x) + Math.PI;
    } else
    {// x = 0, y = 0
      return null;
    }
  };

  // Creates a THREE.Geometry that represents an approximation of a given elliptical arc in {z=0} plane.
  // Points are obtained by by uniform sampling of a given elliptical arc.
  //  @param {number} numPoints - The length number of points that the output geometry will contain. segments in which we subdivide the arc. Resulting point count is numSegments+1.
  // See sampleEllipsePoint for param details.
  var createEllipticalArcGeometry = function createEllipticalArcGeometry(cx, cy, rx, ry, startAngle, endAngle, numPoints) {
    var geometry = new THREE.Geometry();
    for (var i = 0; i < numPoints; i++) {
      var p = new THREE.Vector3(0, 0, 0);
      Object(_SnapMath_js__WEBPACK_IMPORTED_MODULE_3__["sampleEllipsePoint"])(cx, cy, rx, ry, startAngle, endAngle, i / (numPoints - 1), p);

      geometry.vertices.push(p);
    }
    return geometry;
  };

  function GeometryCallback(viewer, snapper, aDetectRadius) {
    this.viewer = viewer;
    this.snapper = snapper;

    this.lineGeom = new THREE.Geometry();
    this.circularArc = null;
    this.circularArcCenter;
    this.circularArcRadius;
    this.ellipticalArc = null;
    this.ellipticalArcCenter;

    this.minDist = Number.MAX_VALUE;

    this.vpIdLine = null;
    this.vpIdCircular = null;
    this.vpIdElliptical = null;

    this.detectRadius = aDetectRadius;

    // Collects candidate segments that we can snap to.
    // This is used to allow snapping to segment intersections.
    this.snapCandidates = []; // {SnappingCandidate[]}
  }

  GeometryCallback.prototype.onLineSegment = function (x1, y1, x2, y2, vpId) {
    var intersectPoint = this.snapper.getIntersectPoint();
    var vertices = this.lineGeom.vertices;
    var v1 = new THREE.Vector3(x1, y1, intersectPoint.z);
    var v2 = new THREE.Vector3(x2, y2, intersectPoint.z);

    // Skip segments outside detectRadius
    var dist = distancePointToLine(intersectPoint, v1, v2);
    if (dist > this.detectRadius) {
      return;
    }

    // Collect snap candidate
    this.snapCandidates.push(new SnapCandidate(vpId, dist).fromLine(v1, v2));

    // Track minDist and lineGeometry for best hit so far
    if (dist < this.minDist) {

      vertices.splice(0, 2, v1, v2);
      this.minDist = dist;

      this.vpIdLine = vpId;
    }
  };

  GeometryCallback.prototype.onCircularArc = function (cx, cy, start, end, radius, vpId) {
    var intersectPoint = this.snapper.getIntersectPoint();
    var point = new THREE.Vector2(intersectPoint.x, intersectPoint.y);

    var center = new THREE.Vector2(cx, cy);
    point.sub(center);

    // Compute closest point on arc
    var pointOnArc = Object(_SnapMath_js__WEBPACK_IMPORTED_MODULE_3__["nearestPointOnCircularArc"])(intersectPoint, center, radius, start, end);
    var dist = pointOnArc.distanceTo(intersectPoint); // 2D distance

    // Collect snap candidate
    this.snapCandidates.push(new SnapCandidate(vpId, dist).fromCircularArc(center, radius, start, end));

    // Skip arcs outside detectRadius
    if (dist > this.detectRadius) {
      return;
    }

    // TODO: get rid of the CircleGeometry stuff below, because we computed the snapPoint above already.
    //       But this needs some refactoring, because the Geometry is passed around outside of snapper.

    var angle = this.snapper.angleVector2(point);

    if (end > start && angle >= start && angle <= end) {
      var arc = new THREE.CircleGeometry(radius, 100, start, end - start);
    } else
    if (end < start && (angle >= start || angle <= end)) {
      var arc = new THREE.CircleGeometry(radius, 100, start, Math.PI * 2 - start + end);
    } else
    {
      return;
    }
    arc.vertices.splice(0, 1);
    arc.applyMatrix(new THREE.Matrix4().makeTranslation(cx, cy, intersectPoint.z));
    this.circularArc = arc;
    this.circularArcCenter = new THREE.Vector3(cx, cy, intersectPoint.z);
    this.circularArcRadius = radius;

    this.snapPoint = new THREE.Vector3(pointOnArc.x, pointOnArc.y, intersectPoint.z);

    this.vpIdCircular = vpId;
  };

  GeometryCallback.prototype.onEllipticalArc = function (cx, cy, start, end, major, minor, tilt, vpId) {
    var intersectPoint = this.snapper.getIntersectPoint();
    var point = new THREE.Vector2(intersectPoint.x, intersectPoint.y);

    var major1 = major - this.detectRadius;
    var minor1 = minor - this.detectRadius;
    var major2 = major + this.detectRadius;
    var minor2 = minor + this.detectRadius;

    var equation1 = (point.x - cx) * (point.x - cx) / (major1 * major1) + (point.y - cy) * (point.y - cy) / (minor1 * minor1);
    var equation2 = (point.x - cx) * (point.x - cx) / (major2 * major2) + (point.y - cy) * (point.y - cy) / (minor2 * minor2);

    var center = new THREE.Vector2(cx, cy);
    point.sub(center);
    point.x *= minor;
    point.y *= major;
    var angle = this.snapper.angleVector2(point);

    if (end > Math.PI * 2) {
      end = Math.PI * 2;
    }

    if (equation1 >= 1 && equation2 <= 1) {

      if (end > start && angle >= start && angle <= end || end < start && (angle >= start || angle <= end)) {
        var arc = createEllipticalArcGeometry(cx, cy, major, minor, start, end, 50);
        if (!isEqualWithPrecision(end - start, Math.PI * 2))
        {
          arc.vertices.pop();
        }
        arc.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, intersectPoint.z));

        // Compute distance between geometry and snapped point. 
        // We use the same way here as in getSnapResultPosition(). This will be replaced later by a more accurate solution.
        var nearestPoint = nearestVertexInVertexToEdge(intersectPoint, arc);
        var dist = THREE.Vector2.prototype.distanceTo.call(nearestPoint, intersectPoint); // only in x/y

        // Collect snap candidate
        var _center = new THREE.Vector2(cx, cy);
        this.snapCandidates.push(new SnapCandidate(vpId, dist).makeEllipticalArc(_center, major, minor, start, end));

        // Todo: Unlike for line-segments, arcs are currently collected by "last one wins" rule by the code for single-snapping. 
        //       We should consider the distance here as well.
        this.ellipticalArc = arc;
        this.ellipticalArcCenter = new THREE.Vector3(cx, cy, intersectPoint.z);

        this.vpIdElliptical = vpId;
      }
    }
  };

  this.snapping2D = function (result) {

    if (!result) {
      return;
    }

    var intersectPoint = result.intersectPoint;
    var fragIds = result.fragId;

    if (typeof fragIds === "undefined") {
      return;
    } else
    if (!Array.isArray(fragIds)) {
      fragIds = [fragIds];
    }

    _snapResult.modelId = result.model ? result.model.id : null;
    _snapResult.hasTopology = false;
    _snapResult.intersectPoint = intersectPoint;

    // Determine which one should be drawn: line, circular arc or elliptical arc
    _snapResult.radius = this.setDetectRadius(intersectPoint);

    // Geometry snapping is only possible if a fragment list is available to obtain geometry per fragment.
    var supportsGeomSnapping = _viewer.model.getFragmentList() != null;
    if (!supportsGeomSnapping) {

      // If no snapping is available, just accept the hitpoint as a vertex hit. This allows to measure
      // distances between arbitrary points in rasters.
      _isSnapped = true;
      _snapResult.geomType = SnapType.SNAP_VERTEX;
      _snapResult.geomVertex = intersectPoint;

      return;
    }


    var gc = new GeometryCallback(_viewer, this, _snapResult.radius);

    for (var fi = 0; fi < fragIds.length; ++fi) {

      var mesh = _viewer.impl.getRenderProxy(_viewer.model, fragIds[fi]);

      if (mesh && mesh.geometry) {
        var vbr = new _src_wgs_scene_VertexBufferReader_js__WEBPACK_IMPORTED_MODULE_2__["VertexBufferReader"](mesh.geometry);
        vbr.enumGeomsForObject(_viewer.model.reverseMapDbId(result.dbId), gc);
      }
    }

    this.finishSnapping2D(gc, intersectPoint);

    // Snap the unsnapped point only if the snapping fails
    if (!_isSnapped && _snapToPixel) {
      _isSnapped = true;
      _snapResult.geomType = SnapType.RASTER_PIXEL;
      _snapResult.geomVertex = intersectPoint;
    }
  };

  // By default, snapper only considers model geometry that is written to ID buffer.
  // This function performs the 2D snapping on a set of given 2D meshes instead. It works similar to snapping2D() but 
  // enumerates the given meshes instead of getting them from the fragment list.
  //
  //  @param {THREE.Vector3}                 intersectPoint - click position in world-coords
  //  @param {function(dbId, layerId, vpId)} filter - Defines subset of primitives to be considered.
  //  @param {THREE.Mesh[]}                  meshes - The triangulated 2D shapes to be checked for snapping
  //  @param {number}                        [detectRadius] - Same coordinate system as the given geometry. Required if geometry is not in world-coords.

  this.snapping2DOverlay = function (intersectPoint, meshes, filter, detectRadius) {
    _snapResult.hasTopology = false;
    _snapResult.intersectPoint = intersectPoint;
    _snapResult.radius = detectRadius || this.setDetectRadius(intersectPoint);

    var gc = new GeometryCallback(_viewer, this, _snapResult.radius);

    for (var i = 0; i < meshes.length; i++) {
      var mesh = meshes[i];
      var vbr = new _src_wgs_scene_VertexBufferReader_js__WEBPACK_IMPORTED_MODULE_2__["VertexBufferReader"](mesh.geometry);
      vbr.enumGeoms(filter, gc);
    }

    this.finishSnapping2D(gc, intersectPoint);
  };

  // Performs 2D snapping to segments based on an enumSegments() callback, which enumerates all segments
  // within in a given bbox in model-space.
  //  @param {Vector3}                          intersectPoint (3D with z=0)
  //  @param {function(minx, miny, maxx, maxy)} enumSegments
  this.snapping2DWithSegmentEnum = function (intersectPoint, enumSegments) {

    _snapResult.hasTopology = false;
    _snapResult.intersectPoint = intersectPoint;
    _snapResult.radius = this.setDetectRadius(intersectPoint);

    var gc = new GeometryCallback(_viewer, this, _snapResult.radius);

    // enum all segments within the snapRadius around intersectPoint
    var minx = intersectPoint.x - _snapResult.radius;
    var miny = intersectPoint.y - _snapResult.radius;
    var maxx = intersectPoint.x + _snapResult.radius;
    var maxy = intersectPoint.y + _snapResult.radius;
    enumSegments(minx, miny, maxx, maxy, gc);

    this.finishSnapping2D(gc, intersectPoint);
  };

  // Finish 2D snapping operation - assuming that all candidate geometry for snapping has been processed by the geometryCallback gc already.
  this.finishSnapping2D = function (gc, intersectPoint) {

    // When restricting to a single viewport, exclude candidates of all other viewports
    if (_forcedVpId !== null) {
      var isSameViewport = function isSameViewport(c) {return c.viewportId === _forcedVpId;};
      gc.snapCandidates = gc.snapCandidates.filter(isSameViewport);
    }

    // Check if we can snap to an intersection of two close segments
    var intersectSnap = findIntersectionSnap(gc.snapCandidates, intersectPoint, gc.detectRadius);
    if (intersectSnap) {
      _snapResult.viewportIndex2d = intersectSnap.viewportId;
      _snapResult.snapPoint = intersectSnap.snapPoint;
      _snapResult.geomType = SnapType.SNAP_INTERSECTION;
      _snapResult.geomVertex = intersectSnap.snapPoint;
      _isSnapped = true;
      return;
    }

    if (gc.circularArc) {

      _snapResult.viewportIndex2d = gc.vpIdCircular;

      _snapResult.snapPoint = gc.snapPoint;

      // Only snap the geometries which belong to the same viewport as the first selection
      if (_forcedVpId !== null && _forcedVpId !== _snapResult.viewportIndex2d)
      return;

      if (intersectPoint.distanceTo(gc.circularArc.vertices[0]) < _snapResult.radius) {

        _snapResult.geomVertex = gc.circularArc.vertices[0];
        _snapResult.geomType = SnapType.SNAP_VERTEX;
      } else
      if (intersectPoint.distanceTo(gc.circularArc.vertices[gc.circularArc.vertices.length - 1]) < _snapResult.radius) {

        _snapResult.geomVertex = gc.circularArc.vertices[gc.circularArc.vertices.length - 1];
        _snapResult.geomType = SnapType.SNAP_VERTEX;
      } else
      {

        this.lineStripToPieces(gc.circularArc);
        _snapResult.geomEdge = gc.circularArc;
        _snapResult.circularArcCenter = gc.circularArcCenter;
        _snapResult.circularArcRadius = gc.circularArcRadius;
        _snapResult.geomType = SnapType.SNAP_CIRCULARARC;
      }

      _isSnapped = true;


    } else
    if (gc.ellipticalArc) {

      _snapResult.viewportIndex2d = gc.vpIdElliptical;

      // Only snap the geometries which belong to the same viewport as the first selection
      if (_forcedVpId !== null && _forcedVpId !== _snapResult.viewportIndex2d)
      return;

      if (intersectPoint.distanceTo(gc.ellipticalArc.vertices[0]) < _snapResult.radius) {

        _snapResult.geomVertex = gc.ellipticalArc.vertices[0];
        _snapResult.geomType = SnapType.SNAP_VERTEX;
      } else
      if (intersectPoint.distanceTo(gc.ellipticalArc.vertices[gc.ellipticalArc.vertices.length - 1]) < _snapResult.radius) {

        _snapResult.geomVertex = gc.ellipticalArc.vertices[gc.ellipticalArc.vertices.length - 1];
        _snapResult.geomType = SnapType.SNAP_VERTEX;
      } else
      {

        this.lineStripToPieces(gc.ellipticalArc);
        _snapResult.geomEdge = gc.ellipticalArc;
        // Before we have measure design for elliptical arc, measure the center for now
        _snapResult.circularArcCenter = gc.ellipticalArcCenter;
        _snapResult.circularArcRadius = null;
        _snapResult.geomType = SnapType.SNAP_CIRCULARARC;
      }

      _isSnapped = true;

    } else
    if (gc.lineGeom.vertices.length) {

      _snapResult.viewportIndex2d = gc.vpIdLine;

      // Only snap the geometries which belong to the same viewport as the first selection
      if (_forcedVpId !== null && _forcedVpId !== _snapResult.viewportIndex2d)
      return;

      // Always expose edge segment - no matter whether we snap to the edge or one of its vertices.
      // This allows us to combine it with other snap constraints later - as done by Edit2D.
      _snapResult.geomEdge = gc.lineGeom;

      if (this.markupMode) {// Markup mode
        var start = gc.lineGeom.vertices[0];
        var end = gc.lineGeom.vertices[1];
        var mid = new THREE.Vector3();
        mid.addVectors(start, end);
        mid.divideScalar(2);
        var md = intersectPoint.distanceTo(mid);
        var sd = intersectPoint.distanceTo(start);
        var ed = intersectPoint.distanceTo(end);

        // Store it for snapping to parallel/perpendicular of underlying vectors
        _snapResult.geomEdge = gc.lineGeom;

        if (md < _snapResult.radius) {
          _snapResult.geomVertex = mid;
          _snapResult.geomType = SnapType.SNAP_VERTEX;
        } else
        if (sd < _snapResult.radius) {
          _snapResult.geomVertex = start;
          _snapResult.geomType = SnapType.SNAP_VERTEX;
        } else
        if (ed < _snapResult.radius) {
          _snapResult.geomVertex = end;
          _snapResult.geomType = SnapType.SNAP_VERTEX;
        } else
        {
          _snapResult.geomType = SnapType.SNAP_EDGE;
        }

        // Circle center
        if (gc.lineGeom.vertices[0].distanceTo(gc.lineGeom.vertices[1]) < EPSILON) {
          _snapResult.geomType = SnapType.SNAP_CIRCLE_CENTER;
        }
      } else
      {// Measure mode
        if (intersectPoint.distanceTo(gc.lineGeom.vertices[0]) < _snapResult.radius) {

          if (gc.lineGeom.vertices[0].distanceTo(gc.lineGeom.vertices[1]) < EPSILON) {
            _snapResult.geomType = SnapType.SNAP_CIRCLE_CENTER;
          } else {
            _snapResult.geomType = SnapType.SNAP_VERTEX;
          }

          _snapResult.geomVertex = gc.lineGeom.vertices[0];
        } else
        if (_options.forceSnapVertices || intersectPoint.distanceTo(gc.lineGeom.vertices[1]) < _snapResult.radius) {

          _snapResult.geomVertex = gc.lineGeom.vertices[1];
          _snapResult.geomType = SnapType.SNAP_VERTEX;
        } else
        {
          _snapResult.geomType = SnapType.SNAP_EDGE;
        }
      }

      _isSnapped = true;
    }
  };

  this.snappingLeaflet = function (result) {
    if (!result) {
      return;
    }

    var intersectPoint = result.intersectPoint;
    _snapResult.intersectPoint = intersectPoint;
    _snapResult.hasTopology = false;

    // Determine which one should be drawn: line, circular arc or elliptical arc
    _snapResult.radius = this.setDetectRadius(intersectPoint);
    _snapResult.geomType = SnapType.RASTER_PIXEL;
    _snapResult.geomVertex = intersectPoint;
    _isSnapped = true;
  };

  this.snapMidpoint = function () {
    _snapResult.isMidpoint = false;

    // Snap midpoint for edge
    if (_isSnapped) {
      if (_snapResult.geomType === SnapType.SNAP_EDGE) {
        var edge = _snapResult.geomEdge;
        var p1 = edge.vertices[0];
        var p2 = edge.vertices[1];

        var midpoint = new THREE.Vector3((p1.x + p2.x) / 2, (p1.y + p2.y) / 2, (p1.z + p2.z) / 2);

        if (_snapResult.intersectPoint.distanceTo(midpoint) < 2 * _snapResult.radius) {
          _snapResult.geomVertex = midpoint;
          _snapResult.geomType = SnapType.SNAP_MIDPOINT;
        }
      }
    }
  };

  this.setPerpendicular = function (isPerpendicular) {
    _snapResult.isPerpendicular = isPerpendicular;
  };

  this.lineStripToPieces = function (geom) {

    var vertices = geom.vertices;
    for (var i = vertices.length - 2; i > 0; i--) {
      vertices.splice(i, 0, vertices[i]);
    }
  };

  this.setDetectRadius = function (point) {

    var navapi = _viewer.navigation;
    var camera = navapi.getCamera();
    var position = navapi.getPosition();

    var p = point.clone();

    var distance = camera.isPerspective ? p.sub(position).length() :
    navapi.getEyeVector().length();

    var fov = navapi.getVerticalFov();
    var worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));

    var viewport = navapi.getScreenViewport();
    var _window = this.getWindow();
    var devicePixelRatio = _window.devicePixelRatio || 1;
    var radius = this.detectRadiusInPixels * worldHeight / (viewport.height * devicePixelRatio);

    return radius;
  };

  this.handleButtonDown = function (event, button) {
    _isDragging = true;
    return false;
  };

  this.handleButtonUp = function (event, button) {
    _isDragging = false;
    return false;
  };

  this.handleMouseMove = function (event) {

    if (_isDragging)
    return false;

    this.onMouseMove({
      x: event.canvasX,
      y: event.canvasY });


    return false;
  };

  this.handleSingleTap = function (event) {

    return this.handleMouseMove(event);
  };

  this.handlePressHold = function (event) {

    if (Object(_src_compat_js__WEBPACK_IMPORTED_MODULE_1__["isMobileDevice"])()) {
      switch (event.type) {

        case "press":
          _isPressing = true;
          this.onMouseMove({ x: event.canvasX, y: event.canvasY });
          break;

        case "pressup":
          this.onMouseMove({ x: event.canvasX, y: event.canvasY });
          _isPressing = false;
          break;}

    }
    return false;

  };

  this.handleGesture = function (event)
  {
    if (Object(_src_compat_js__WEBPACK_IMPORTED_MODULE_1__["isMobileDevice"])()) {
      if (_isPressing) {
        switch (event.type) {

          case "dragstart":
            this.onMouseMove({ x: event.canvasX, y: event.canvasY });
            break;

          case "dragmove":
            this.onMouseMove({ x: event.canvasX, y: event.canvasY });
            break;

          case "dragend":
            this.onMouseMove({ x: event.canvasX, y: event.canvasY });
            _isPressing = false;
            break;

          case "pinchstart":

            break;

          case "pinchmove":
            break;

          case "pinchend":
            break;}

      }
    }

    return false;
  };

  /**
      * Handler to mouse move events, used to snap in markup edit mode.
      * @private
      */
  this.onMouseDown = function (mousePosition) {
    return this.onMouseMove(mousePosition);
  };

  /**
      * Handler to mouse move events, used to snap in markup edit mode.
      * @private
      */
  this.onMouseMove = function (mousePosition) {

    this.clearSnapped();

    var result = _viewer.impl.snappingHitTest(mousePosition.x, mousePosition.y, false);

    if (!result && _snapToPixel) {
      var vpVec = _viewer.impl.clientToViewport(mousePosition.x, mousePosition.y);
      var point = _viewer.impl.intersectGroundViewport(vpVec);
      result = { intersectPoint: point };
    }

    if (!result || !result.intersectPoint)
    return false;

    // 3D Snapping
    if (result.face) {
      this.snapping3D(result);
    }
    // 2D Snapping
    else if (result.dbId || result.dbId === 0) {
        this.snapping2D(result);
      }
      // PDF - Leaflet Snapping
      else {
          this.snappingLeaflet(result);
        }

    this.snapMidpoint();

    return true;
  };
};

av.GlobalManagerMixin.call(Snapper.prototype);

/***/ }),

/***/ "./extensions/Snapping/SnapperIndicator.js":
/*!*************************************************!*\
  !*** ./extensions/Snapping/SnapperIndicator.js ***!
  \*************************************************/
/*! exports provided: SnapperIndicator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SnapperIndicator", function() { return SnapperIndicator; });
var MeasureCommon = Autodesk.Viewing.MeasureCommon;
var isEqualVectors = MeasureCommon.isEqualVectors;
var EPSILON = MeasureCommon.EPSILON;
var SnapType = MeasureCommon.SnapType;

var NO_OVERLAY = 0;
var FACE_OVERLAY = 1;
var EDGE_OVERLAY = 2;
var POINT_OVERLAY = 3;

var GEOMETRIES_OVERLAY = 'MeasureTool-snapper-geometries';
var INDICATOR_OVERLAY = 'MeasureTool-snapper-indicator';

var _geometryLineWidth = 0.3;
var _indicatorLineWidth = 0.2;
var _indicatorSize = 1.2;
var _point = null;

var _indicatorColor = 0xff7700;
var _geometryColor = 0x00CC00;

// /** @constructor */
function SnapperIndicator(viewer, snapper)
{
  this.viewer = viewer;
  this.snapper = snapper;
  this.overlayType = NO_OVERLAY;
  this.previewsIntersectPoint = null;

  this.viewer.impl.createOverlayScene(GEOMETRIES_OVERLAY);
  this.viewer.impl.createOverlayScene(INDICATOR_OVERLAY);

  this.geometryMaterial = new THREE.MeshPhongMaterial({
    color: _geometryColor,
    ambient: _geometryColor,
    opacity: 0.5,
    transparent: true,
    depthTest: false,
    depthWrite: false,
    side: THREE.DoubleSide });


  this.indicatorMaterial = new THREE.MeshBasicMaterial({
    color: _indicatorColor,
    ambient: _indicatorColor,
    opacity: 1,
    transparent: false,
    depthTest: false,
    depthWrite: false,
    side: THREE.DoubleSide });

}

SnapperIndicator.prototype.constructor = SnapperIndicator;
var proto = SnapperIndicator.prototype;


proto.render = function () {

  var snapResult = this.snapper.getSnapResult();

  if (!isEqualVectors(this.previewsIntersectPoint, snapResult.intersectPoint, EPSILON)) {
    this.clearOverlay(GEOMETRIES_OVERLAY);
  }

  this.clearOverlay(INDICATOR_OVERLAY);

  if (snapResult.isEmpty())
  return;

  if (this.snapper.renderSnappedGeometry ||
  snapResult.hasTopology && this.snapper.renderSnappedTopology) {
    this.renderGeometry(snapResult);
  }
  this.renderIndicator(snapResult);

  this.previewsIntersectPoint = snapResult.intersectPoint.clone();
};

proto.removeOverlay = function (overlayName) {

  this.viewer.impl.clearOverlay(overlayName);
  this.viewer.impl.removeOverlayScene(overlayName);

};

proto.clearOverlay = function (overlayName) {

  this.removeOverlay(overlayName);
  this.viewer.impl.createOverlayScene(overlayName);

};

proto.clearOverlays = function () {

  this.removeOverlay(GEOMETRIES_OVERLAY);
  this.viewer.impl.createOverlayScene(GEOMETRIES_OVERLAY);

  this.removeOverlay(INDICATOR_OVERLAY);
  this.viewer.impl.createOverlayScene(INDICATOR_OVERLAY);

  this.previewsIntersectPoint = null;

};

proto.addOverlay = function (overlayName, mesh) {

  this.viewer.impl.addOverlay(overlayName, mesh);

};

/**
    * Draw the planar face
    * @param geom -Geometry which needs to be draw.
    * @param mesh -Mesh which is loaded.
    */
proto.drawFace = function (geom, material, overlayName) {

  var snapperPlane = new THREE.Mesh(geom, material, true);

  if (overlayName === GEOMETRIES_OVERLAY) {
    this.overlayType = FACE_OVERLAY;
  }

  this.addOverlay(overlayName, snapperPlane);

};

proto.cylinderMesh = function (pointX, pointY, material, width) {

  var direction = new THREE.Vector3().subVectors(pointY, pointX);
  var orientation = new THREE.Matrix4();
  orientation.lookAt(pointX, pointY, new THREE.Object3D().up);
  orientation.multiply(new THREE.Matrix4().set(1, 0, 0, 0,
  0, 0, 1, 0,
  0, -direction.length(), 0, 0,
  0, 0, 0, 1));

  width = width || 0.5;
  var cylinder = new THREE.CylinderGeometry(width, width, 1.0, 8, 1, true);
  var edge = new THREE.Mesh(cylinder, material);
  cylinder = null;

  edge.applyMatrix(orientation);
  edge.position.x = (pointY.x + pointX.x) / 2;
  edge.position.y = (pointY.y + pointX.y) / 2;
  edge.position.z = (pointY.z + pointX.z) / 2;
  return edge;

};

proto.renderGeometry = function (snapResult) {

  if (isEqualVectors(this.previewsIntersectPoint, snapResult.intersectPoint, EPSILON)) {
    return;
  }

  switch (snapResult.geomType) {
    case SnapType.SNAP_VERTEX:
      SnapType.RASTER_PIXEL;
      this.drawPoint(snapResult.geomVertex, this.geometryMaterial, GEOMETRIES_OVERLAY);
      break;

    case SnapType.SNAP_EDGE:
    case SnapType.SNAP_CURVEDEDGE:
    case SnapType.SNAP_CIRCULARARC:
    case SnapType.SNAP_MIDPOINT:
      this.drawLine(snapResult.geomEdge, this.geometryMaterial, _geometryLineWidth, GEOMETRIES_OVERLAY);
      break;

    case SnapType.SNAP_FACE:
    case SnapType.SNAP_CURVEDFACE:
      this.drawFace(snapResult.geomFace, this.geometryMaterial, GEOMETRIES_OVERLAY);
      break;}

};

proto.renderVertexIndicator = function (snapResult) {

  var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);
  var scale = this.setScale(pos);
  var length = _indicatorSize * scale;

  var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);
  var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);

  var geom = new THREE.Geometry();
  var p = new THREE.Vector3();

  // Upper line
  p.addVectors(pos, rightVec);
  p.addVectors(p, upVec);
  geom.vertices[0] = p.clone();
  p.subVectors(pos, rightVec);
  p.addVectors(p, upVec);
  geom.vertices[1] = p.clone();
  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);

  // Bottom line
  p.addVectors(pos, rightVec);
  p.subVectors(p, upVec);
  geom.vertices[0] = p.clone();
  p.subVectors(pos, rightVec);
  p.subVectors(p, upVec);
  geom.vertices[1] = p.clone();
  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);

  // Left line
  p.subVectors(pos, rightVec);
  p.subVectors(p, upVec);
  geom.vertices[0] = p.clone();
  p.subVectors(pos, rightVec);
  p.addVectors(p, upVec);
  geom.vertices[1] = p.clone();
  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);

  // Right line
  p.addVectors(pos, rightVec);
  p.subVectors(p, upVec);
  geom.vertices[0] = p.clone();
  p.addVectors(pos, rightVec);
  p.addVectors(p, upVec);
  geom.vertices[1] = p.clone();
  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);

};

proto.renderMidpointIndicator = function (snapResult) {

  var pos = snapResult.geomVertex;
  var scale = this.setScale(pos);
  var length = _indicatorSize * scale;

  var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);
  var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);

  var geom = new THREE.Geometry();
  var p = new THREE.Vector3();

  // Bottom line
  p.addVectors(pos, rightVec);
  p.subVectors(p, upVec);
  geom.vertices[0] = p.clone();
  p.subVectors(pos, rightVec);
  p.subVectors(p, upVec);
  geom.vertices[1] = p.clone();
  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);

  // Left line
  p.subVectors(pos, rightVec);
  p.subVectors(p, upVec);
  geom.vertices[0] = p.clone();
  p.addVectors(pos, upVec);
  geom.vertices[1] = p.clone();
  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);

  // Right line
  p.addVectors(pos, rightVec);
  p.subVectors(p, upVec);
  geom.vertices[0] = p.clone();
  p.addVectors(pos, upVec);
  geom.vertices[1] = p.clone();
  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);

};

proto.renderEdgeIndicator = function (snapResult) {

  var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);
  var scale = this.setScale(pos);
  var length = _indicatorSize * scale;

  var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);
  var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);

  var geom = new THREE.Geometry();
  var p = new THREE.Vector3();

  // Bottom line
  p.addVectors(pos, rightVec);
  p.subVectors(p, upVec);
  geom.vertices[0] = p.clone();
  geom.vertices[1] = pos.clone();
  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);

  // Left line
  p.subVectors(pos, rightVec);
  p.subVectors(p, upVec);
  geom.vertices[0] = p.clone();
  geom.vertices[1] = pos.clone();
  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);

  // Right line
  p.addVectors(pos, upVec);
  geom.vertices[0] = p.clone();
  geom.vertices[1] = pos.clone();
  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);

};

proto.renderCircleIndicator = function (snapResult) {

  var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);
  this.drawCircle(pos, this.indicatorMaterial, INDICATOR_OVERLAY);

};

proto.renderPerpendicular = function (snapResult) {

  var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);
  var scale = this.setScale(pos);
  var length = _indicatorSize * scale;

  var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);
  var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);

  var geom = new THREE.Geometry();
  var p = new THREE.Vector3();

  // Upper line
  geom.vertices[0] = pos.clone();
  p.subVectors(pos, rightVec);
  geom.vertices[1] = p.clone();
  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);

  // Bottom line
  p.addVectors(pos, rightVec);
  p.subVectors(p, upVec);
  geom.vertices[0] = p.clone();
  p.subVectors(pos, rightVec);
  p.subVectors(p, upVec);
  geom.vertices[1] = p.clone();
  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);

  // Left line
  p.subVectors(pos, rightVec);
  p.subVectors(p, upVec);
  geom.vertices[0] = p.clone();
  p.subVectors(pos, rightVec);
  p.addVectors(p, upVec);
  geom.vertices[1] = p.clone();
  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);

  // Right line
  geom.vertices[0] = pos.clone();
  p.subVectors(pos, upVec);
  geom.vertices[1] = p.clone();
  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);

};

proto.renderPixelIndicator = function (snapResult) {

  var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);
  var scale = this.setScale(pos);
  var length = _indicatorSize * scale;

  var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);
  var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);

  var geom = new THREE.Geometry();
  var p = new THREE.Vector3();

  // Top-left line
  p.subVectors(pos, rightVec);
  p.addVectors(p, upVec);
  geom.vertices[0] = p.clone();
  geom.vertices[1] = pos.clone();
  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);

  // Top-right line
  p.addVectors(pos, rightVec);
  p.addVectors(p, upVec);
  geom.vertices[0] = p.clone();
  geom.vertices[1] = pos.clone();
  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);

  // Bottom-right line
  p.addVectors(pos, rightVec);
  p.subVectors(p, upVec);
  geom.vertices[0] = p.clone();
  geom.vertices[1] = pos.clone();
  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);

  // Bottom-left line
  p.subVectors(pos, rightVec);
  p.subVectors(p, upVec);
  geom.vertices[0] = p.clone();
  geom.vertices[1] = pos.clone();
  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);


};

proto.renderIndicator = function (snapResult) {

  if (snapResult.isPerpendicular) {
    this.renderPerpendicular(snapResult);
    return;
  }

  switch (snapResult.geomType) {
    case SnapType.SNAP_VERTEX:
      this.renderVertexIndicator(snapResult);
      break;

    case SnapType.SNAP_INTERSECTION:
      this.renderVertexIndicator(snapResult);
      break;

    case SnapType.SNAP_MIDPOINT:
      this.renderMidpointIndicator(snapResult);
      break;

    case SnapType.SNAP_CIRCLE_CENTER:
      this.renderCircleIndicator(snapResult);
      break;

    case SnapType.SNAP_EDGE:
    case SnapType.SNAP_CURVEDEDGE:
      this.renderEdgeIndicator(snapResult);
      break;

    case SnapType.SNAP_CIRCULARARC:
      if (this.viewer.model.is2d()) {
        this.renderVertexIndicator(snapResult);
      } else {
        this.renderCircleIndicator(snapResult);
      }
      break;

    case SnapType.SNAP_FACE:
    case SnapType.SNAP_CURVEDFACE:
      this.renderVertexIndicator(snapResult);
      break;

    case SnapType.RASTER_PIXEL:
      this.renderPixelIndicator(snapResult);
      break;}

};

proto.drawLine = function (geom, material, width, overlayName) {

  // Line Pieces
  if (overlayName === GEOMETRIES_OVERLAY) {
    this.overlayType = EDGE_OVERLAY;
  }

  for (var i = 0; i < geom.vertices.length; i += 2) {
    var cylinder = this.cylinderMesh(geom.vertices[i], geom.vertices[i + 1], material, width);
    this.setEdgeScale(cylinder);
    this.addOverlay(overlayName, cylinder);
  }
};

proto.drawPoint = function (point, material, overlayName) {

  // Because every point is snappable in PDFs, don't display the green dot for PDFs.
  if (this.viewer.model.getData().isLeaflet) {
    return;
  }

  if (!_point)
  _point = new THREE.SphereGeometry(1.0);

  var pointMesh = new THREE.Mesh(_point, material);
  pointMesh.position.set(point.x, point.y, point.z);

  this.setPointScale(pointMesh);

  if (overlayName === GEOMETRIES_OVERLAY) {
    this.overlayType = POINT_OVERLAY;
  }

  this.addOverlay(overlayName, pointMesh);

};

proto.drawCircle = function (point, material, overlayName) {

  var torus = new THREE.TorusGeometry(_indicatorSize, _indicatorLineWidth, 2, 20);
  var torusMesh = new THREE.Mesh(torus, material);
  torusMesh.lookAt(this.viewer.navigation.getEyeVector().normalize());
  torus = null;

  torusMesh.position.set(point.x, point.y, point.z);

  this.setCircleScale(torusMesh);

  this.addOverlay(overlayName, torusMesh);

};

proto.setScale = function (point) {

  var pixelSize = 5;

  var navapi = this.viewer.navigation;
  var camera = navapi.getCamera();
  var position = navapi.getPosition();

  var p = point.clone();

  var distance = camera.isPerspective ? p.sub(position).length() :
  navapi.getEyeVector().length();

  var fov = navapi.getVerticalFov();
  var worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));

  var viewport = navapi.getScreenViewport();
  var scale = pixelSize * worldHeight / viewport.height;

  return scale;

};

proto.setPointScale = function (pointMesh) {

  var scale = this.setScale(pointMesh.position);
  pointMesh.scale.x = scale;
  pointMesh.scale.y = scale;
  pointMesh.scale.z = scale;

};

proto.setCircleScale = function (torusMesh) {

  var scale = this.setScale(torusMesh.position);
  torusMesh.scale.x = scale;
  torusMesh.scale.y = scale;
};

proto.setEdgeScale = function (cylinderMesh) {

  var scale = this.setScale(cylinderMesh.position);
  cylinderMesh.scale.x = scale;
  cylinderMesh.scale.z = scale;
};

proto.updatePointScale = function (overlayName) {

  if (this.overlayType != POINT_OVERLAY)
  return;

  var overlay = this.viewer.impl.overlayScenes[overlayName];
  if (overlay) {
    var scene = overlay.scene;

    for (var i = 0; i < scene.children.length; i++) {
      var pointMesh = scene.children[i];
      if (pointMesh) {

        this.setPointScale(pointMesh);
      }
    }
  }
};

proto.updateEdgeScale = function (overlayName) {

  if (this.overlayType != EDGE_OVERLAY)
  return;

  var overlay = this.viewer.impl.overlayScenes[overlayName];
  if (overlay) {
    var scene = overlay.scene;

    for (var i = 0; i < scene.children.length; i++) {
      var cylinderMesh = scene.children[i];
      if (cylinderMesh) {

        this.setEdgeScale(cylinderMesh);
      }
    }
  }
};

proto.onCameraChange = function () {

  this.updatePointScale(GEOMETRIES_OVERLAY);
  this.updateEdgeScale(GEOMETRIES_OVERLAY);

  // if (!this.snapper.markupMode) {
  this.render();
  // }
};

proto.destroy = function () {

  this.removeOverlay(GEOMETRIES_OVERLAY);
  this.removeOverlay(INDICATOR_OVERLAY);

  if (_point) {
    _point.dispose();
    _point = null;
  }
};

/***/ }),

/***/ "./extensions/Snapping/index.js":
/*!**************************************!*\
  !*** ./extensions/Snapping/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}
var av = Autodesk.Viewing;

/**
                            * @namespace Autodesk.Viewing.Extensions.Snapping
                            */
var namespace = AutodeskNamespace('Autodesk.Viewing.Extensions.Snapping');

function _export(m, ns) {
  for (var prop in m) {
    if (m.hasOwnProperty(prop)) {
      //Export directly into the module (e.g. for node.js use, where LMV is used via require instead from global namespace)
      module.exports[prop] = m[prop];

      //Export into the desired viewer namespace
      ns[prop] = m[prop];
    }
  }
}

_export(__webpack_require__(/*! ./SnapMath.js */ "./extensions/Snapping/SnapMath.js"), namespace);
_export(__webpack_require__(/*! ./Snapper.js */ "./extensions/Snapping/Snapper.js"), namespace);
_export(__webpack_require__(/*! ./SnapperIndicator.js */ "./extensions/Snapping/SnapperIndicator.js"), namespace);


/**
                                                       * Utility extension that provides access to the {@link Autodesk.Viewing.Extensions.Snapping.Snapper} tool.
                                                       * 
                                                       * The extension id is: `Autodesk.Snapping`
                                                       * 
                                                       * @example
                                                       *   viewer.loadExtension('Autodesk.Snapping')
                                                       *  
                                                       * @memberof Autodesk.Viewing.Extensions
                                                       * @alias Autodesk.Viewing.Extensions.SnappingExtension
                                                       * @see {@link Autodesk.Viewing.Extension} for common inherited methods.
                                                       * @class
                                                      */var
SnappingExtension = /*#__PURE__*/function (_av$Extension) {_inherits(SnappingExtension, _av$Extension);

  /**
                                                                                                         * @alias Autodesk.Viewing.Extensions.SnappingExtension
                                                                                                         * @constructor
                                                                                                         */
  function SnappingExtension(viewer, options) {_classCallCheck(this, SnappingExtension);return _possibleConstructorReturn(this, _getPrototypeOf(SnappingExtension).call(this,
    viewer, options));
  }

  /**
     * Load the extension.
     *
     * @returns {Promise} that resolves when dependent extension finishes loading.
     * 
     * @alias Autodesk.Viewing.Extensions.SnappingExtension#load
    */_createClass(SnappingExtension, [{ key: "load", value: function load()
    {
      // Load the required dependency (and return the pending load as the load completion Promise)
      return this.viewer.loadExtension('Autodesk.CompGeom');
    }

    /**
       * Unloads the extension.
       * It does not unload dependent extensions.
       *
       * @returns {boolean} Always returns true
       * 
       * @alias Autodesk.Viewing.Extensions.SnappingExtension#unload
      */ }, { key: "unload", value: function unload()
    {return true;}


    /**
                    * Unused method.
                    *
                    * @returns {boolean} Always returns true
                    * 
                    * @alias Autodesk.Viewing.Extensions.SnappingExtension#activate
                   */ }, { key: "activate", value: function activate()
    {return true;}

    /**
                    * Unused method.
                    *
                    * @returns {boolean} Always returns false
                    * 
                    * @alias Autodesk.Viewing.Extensions.SnappingExtension#deactivate
                   */ }, { key: "deactivate", value: function deactivate()
    {return false;} }]);return SnappingExtension;}(av.Extension);


// The ExtensionManager requires an extension to be registered.
av.theExtensionManager.registerExtension('Autodesk.Snapping', SnappingExtension);

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/compat.js":
/*!***********************!*\
  !*** ./src/compat.js ***!
  \***********************/
/*! exports provided: getGlobal, isBrowser, isNodeJS, isIE11, launchFullscreen, exitFullscreen, inFullscreen, fullscreenElement, isFullscreenAvailable, getAndroidVersion, isTouchDevice, isIOSDevice, isAndroidDevice, isMobileDevice, isSafari, isFirefox, isChrome, isMac, isWindows, ObjectAssign, disableDocumentTouchSafari, enableDocumentTouchSafari, touchStartToClick */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGlobal", function() { return getGlobal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return isBrowser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNodeJS", function() { return isNodeJS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIE11", function() { return isIE11; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "launchFullscreen", function() { return launchFullscreen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exitFullscreen", function() { return exitFullscreen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inFullscreen", function() { return inFullscreen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fullscreenElement", function() { return fullscreenElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFullscreenAvailable", function() { return isFullscreenAvailable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAndroidVersion", function() { return getAndroidVersion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTouchDevice", function() { return isTouchDevice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIOSDevice", function() { return isIOSDevice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAndroidDevice", function() { return isAndroidDevice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isMobileDevice", function() { return isMobileDevice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSafari", function() { return isSafari; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFirefox", function() { return isFirefox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isChrome", function() { return isChrome; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isMac", function() { return isMac; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWindows", function() { return isWindows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectAssign", function() { return ObjectAssign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "disableDocumentTouchSafari", function() { return disableDocumentTouchSafari; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enableDocumentTouchSafari", function() { return enableDocumentTouchSafari; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "touchStartToClick", function() { return touchStartToClick; });

function getGlobal() {
  return typeof window !== "undefined" && window !== null ?
  window :
  typeof self !== "undefined" && self !== null ?
  self :
  global;
}

var _window = getGlobal();
var _document = _window && _window.document;

var isBrowser = typeof navigator !== "undefined";

var isNodeJS = function isNodeJS() {
  return !isBrowser;
};

var isIE11 = isBrowser && !!navigator.userAgent.match(/Edge|Trident\/7\./);

// fix IE events
if (typeof window !== "undefined" && isIE11) {
  (function () {
    function CustomEvent(event, params) {
      params = params || { bubbles: false, cancelable: false, detail: undefined };
      var evt = _document.createEvent('CustomEvent');
      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
      return evt;
    }

    CustomEvent.prototype = _window.CustomEvent.prototype;

    _window.CustomEvent = CustomEvent;
  })();
}

// IE does not implement ArrayBuffer slice. Handy!
if (!ArrayBuffer.prototype.slice) {
  ArrayBuffer.prototype.slice = function (start, end) {
    // Normalize start/end values
    if (!end || end > this.byteLength) {
      end = this.byteLength;
    } else
    if (end < 0) {
      end = this.byteLength + end;
      if (end < 0) end = 0;
    }
    if (start < 0) {
      start = this.byteLength + start;
      if (start < 0) start = 0;
    }

    if (end <= start) {
      return new ArrayBuffer();
    }

    // Bytewise copy- this will not be fast, but what choice do we have?
    var len = end - start;
    var view = new Uint8Array(this, start, len);
    var out = new Uint8Array(len);
    for (var i = 0; i < len; i++) {
      out[i] = view[i];
    }
    return out.buffer;
  };
}

// IE doesn't implement Math.log2
(function () {
  Math.log2 = Math.log2 || function (x) {
    return Math.log(x) / Math.LN2;
  };
})();

//The BlobBuilder object
if (typeof window !== "undefined")
_window.BlobBuilder = _window.BlobBuilder || _window.WebKitBlobBuilder || _window.MozBlobBuilder || _window.MSBlobBuilder;


// Launch full screen on the given element with the available method
function launchFullscreen(element, options) {
  if (element.requestFullscreen) {
    element.requestFullscreen(options);
  } else if (element.mozRequestFullScreen) {
    element.mozRequestFullScreen(options);
  } else if (element.webkitRequestFullscreen) {
    element.webkitRequestFullscreen(options);
  } else if (element.msRequestFullscreen) {
    element.msRequestFullscreen(options);
  }
};

// Exit full screen with the available method
function exitFullscreen(_document) {
  if (!inFullscreen(_document)) {
    return;
  }
  if (_document.exitFullscreen) {
    _document.exitFullscreen();
  } else if (_document.mozCancelFullScreen) {
    _document.mozCancelFullScreen();
  } else if (_document.webkitExitFullscreen) {
    _document.webkitExitFullscreen();
  } else if (_document.msExitFullscreen) {
    _document.msExitFullscreen();
  }
};

// Determines if the browser is in full screen
function inFullscreen(_document) {

  // Special case for Ms-Edge that has webkitIsFullScreen with correct value
  // and fullscreenEnabled with wrong value (thanks MS)

  if ("webkitIsFullScreen" in _document) return !!_document.webkitIsFullScreen;
  if ("fullscreenElement" in _document) return !!_document.fullscreenElement;
  if ("mozFullScreenElement" in _document) return !!_document.mozFullScreenElement;
  if ("msFullscreenElement" in _document) return !!_document.msFullscreenElement;

  return !!_document.querySelector(".viewer-fill-browser"); // Fallback for iPad
};

function fullscreenElement(_document) {
  return _document.fullscreenElement || _document.mozFullScreenElement || _document.webkitFullscreenElement || _document.msFullscreenElement;
};

function isFullscreenAvailable(element) {
  return element.requestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen || element.msRequestFullscreen;
};

// Get the version of the android device through user agent.
// Return the version string of android device, e.g. 4.4, 5.0...
function getAndroidVersion(ua) {
  ua = ua || navigator.userAgent;
  var match = ua.match(/Android\s([0-9\.]*)/);
  return match ? match[1] : false;
};

// Determine if this is a touch or notouch device.
function isTouchDevice() {
  /*
                                 // Temporarily disable touch support through hammer on Android 5, to debug
                                 // some specific gesture issue with Chromium WebView when loading viewer3D.js.
                                 if (parseInt(getAndroidVersion()) == 5) {
                                     return false;
                                 }
                                 */

  return typeof window !== 'undefined' && ('ontouchstart' in window || navigator.maxTouchPoints > 0);
};

// Since iOS 13, the iPad identifies itself as a desktop, so the only way to reliably detect is to search for multitouch capabilities
// (insofar as no other Apple device implements it)
var _isIOSDevice = isBrowser && (/ip(ad|hone|od)/.test(navigator.userAgent.toLowerCase()) || navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
function isIOSDevice() {
  return _isIOSDevice;
}

var _isAndroidDevice = isBrowser && navigator.userAgent.toLowerCase().indexOf('android') !== -1;
function isAndroidDevice() {
  return _isAndroidDevice;
}

function isMobileDevice() {
  if (!isBrowser) return false;
  return isIOSDevice() || isAndroidDevice();
};

function isSafari() {
  if (!isBrowser) return false;
  var _ua = navigator.userAgent.toLowerCase();
  return _ua.indexOf("safari") !== -1 && _ua.indexOf("chrome") === -1;
};

function isFirefox() {
  if (!isBrowser) return false;
  var _ua = navigator.userAgent.toLowerCase();
  return _ua.indexOf("firefox") !== -1;
};

function isChrome() {
  if (!isBrowser) return false;
  var _ua = navigator.userAgent.toLowerCase();
  return _ua.indexOf("chrome") !== -1;
};

function isMac() {
  if (!isBrowser) return false;
  var _ua = navigator.userAgent.toLowerCase();
  return _ua.indexOf("mac os") !== -1;
};

function isWindows() {
  if (!isBrowser) return false;
  var _ua = navigator.userAgent.toLowerCase();
  return _ua.indexOf("win32") !== -1 || _ua.indexOf("windows") !== -1;
};

function ObjectAssign(des, src) {
  for (var key in src) {
    if (src.hasOwnProperty(key))
    des[key] = src[key];
  }
  return des;
};


// Hack to work around Safari's use of pinch and pan inside the viewer canvas.
function disableTouchSafari(event) {
  var xOff = _window.hasOwnProperty("pageXOffset") ? _window.pageXOffset : _document.documentElement.scrollLeft;
  var yOff = _window.hasOwnProperty("pageYOffset") ? _window.pageYOffset : _document.documentElement.scrollTop;

  // event.pageX and event.pageY returned undefined through Chrome console device mode
  var pageX = typeof event.pageX === "undefined" ? event.changedTouches[0].pageX : event.pageX;
  var pageY = typeof event.pageY === "undefined" ? event.changedTouches[0].pageY : event.pageY;

  // If we aren't inside the canvas, then allow default propagation of the event
  var element = _document.elementFromPoint(pageX - xOff, pageY - yOff);
  if (!element || element.nodeName !== 'CANVAS')
  return true;
  // If it's a CANVAS, check that it's owned by us
  if (element.getAttribute('data-viewer-canvas' !== 'true'))
  return true;
  // Inside the canvas, prevent the event from propagating to Safari'safely
  // standard handlers, which will pan and zoom the page.
  event.preventDefault();
  return false;
};

// Hack to work around Safari's use of pinch and pan inside the viewer canvas.
function disableDocumentTouchSafari() {
  if (isMobileDevice() && isSafari()) {
    // Safari mobile disable default touch handling inside viewer canvas
    // Use capture to make sure Safari doesn't capture the touches and prevent
    // us from disabling them.
    _document.documentElement.addEventListener('touchstart', disableTouchSafari, true);
    _document.documentElement.addEventListener('touchmove', disableTouchSafari, true);
    _document.documentElement.addEventListener('touchcanceled', disableTouchSafari, true);
    _document.documentElement.addEventListener('touchend', disableTouchSafari, true);
  }
};

// Hack to work around Safari's use of pinch and pan inside the viewer canvas.
// This method is not being invoked explicitly.
function enableDocumentTouchSafari() {
  if (isMobileDevice() && isSafari()) {
    // Safari mobile disable default touch handling inside viewer canvas
    // Use capture to make sure Safari doesn't capture the touches and prevent
    // us from disabling them.
    _document.documentElement.removeEventListener('touchstart', disableTouchSafari, true);
    _document.documentElement.removeEventListener('touchmove', disableTouchSafari, true);
    _document.documentElement.removeEventListener('touchcanceled', disableTouchSafari, true);
    _document.documentElement.removeEventListener('touchend', disableTouchSafari, true);
  }
};


// Convert touchstart event to click to remove the delay between the touch and
// the click event which is sent after touchstart with about 300ms deley.
// Should be used in UI elements on touch devices.
function touchStartToClick(e) {
  // Buttons that activate fullscreen are a special case. The HTML5 fullscreen spec
  // requires the original user gesture signal to avoid a security issue.  See LMV-2396 and LMV-2326
  if (e.target.className.indexOf("fullscreen") > -1 || e.target.className.indexOf("webvr") > -1)
  return;
  e.preventDefault(); // Stops the firing of delayed click event.
  e.stopPropagation();
  e.target.click(); // Maps to immediate click.
};

//Safari doesn't have the Performance object
//We only need the now() function, so that's easy to emulate.
(function () {
  var global = getGlobal();
  if (!global.performance)
  global.performance = Date;
})();

// Polyfill for IE and Safari
// https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
Number.isInteger = Number.isInteger || function (value) {
  return typeof value === "number" &&
  isFinite(value) &&
  Math.floor(value) === value;
};

// Polyfill for IE
String.prototype.repeat = String.prototype.repeat || function (count) {
  if (count < 1) return '';
  var result = '',pattern = this.valueOf();
  while (count > 1) {
    if (count & 1) result += pattern;
    count >>= 1, pattern += pattern;
  }
  return result + pattern;
};

// Polyfill for IE
// It doesn't support negative values for start and end; it complicates the code using this function.
if (!Array.prototype.fill) {
  Object.defineProperty(Array.prototype, "fill", {
    enumerable: false,
    value: function value(_value, start, end) {
      start = start === undefined ? 0 : start;
      end = end === undefined ? this.length : end;
      for (var i = start; i < end; ++i) {
        this[i] = _value;}
    } });

}
// Polyfill for IE
Int32Array.prototype.lastIndexOf = Int32Array.prototype.lastIndexOf || function (searchElement, fromIndex) {
  return Array.prototype.lastIndexOf.call(this, searchElement, fromIndex);
};

// Polyfill for IE
// It doesn't support negative values for start and end; it complicates the code using this function.
if (!Array.prototype.find) {
  Object.defineProperty(Array.prototype, "find", {
    enumerable: false,
    value: function value(callback, _this) {
      var len = this.length;
      for (var i = 0; i < len; ++i) {
        var item = this[i];
        if (callback.call(_this, item, i, this))
        return item;
      }
      return undefined;
    } });

}

// Polyfill for IE
if (typeof Object.assign != 'function') {
  // Must be writable: true, enumerable: false, configurable: true
  Object.defineProperty(Object, "assign", {
    value: function assign(target, varArgs) {// .length of function is 2
      'use strict';
      if (target == null) {// TypeError if undefined or null
        throw new TypeError('Cannot convert undefined or null to object');
      }

      var to = Object(target);

      for (var index = 1; index < arguments.length; index++) {
        var nextSource = arguments[index];

        if (nextSource != null) {// Skip over if undefined or null
          for (var nextKey in nextSource) {
            // Avoid bugs when hasOwnProperty is shadowed
            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
      return to;
    },
    writable: true,
    configurable: true });

}

// Polyfill for IE and iOS devices
if (typeof window !== "undefined" && (isIE11 || isIOSDevice()) && !HTMLCanvasElement.prototype.toBlob) {
  Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {
    value: function value(callback, type, quality) {
      var canvas = this;
      setTimeout(function () {

        var binStr = atob(canvas.toDataURL(type, quality).split(',')[1]),
        len = binStr.length,
        arr = new Uint8Array(len);

        for (var i = 0; i < len; i++) {
          arr[i] = binStr.charCodeAt(i);
        }

        callback(new Blob([arr], { type: type || 'image/png' }));

      });
    } });

}

// Polyfill for IE (LMV-3823)
if (!Uint8Array.prototype.slice) {

  // This will work for genuine arrays, array-like objects, 
  // NamedNodeMap (attributes, entities, notations),
  // NodeList (e.g., getElementsByTagName), HTMLCollection (e.g., childNodes),
  // and will not fail on other DOM objects (as do DOM elements in IE < 9)
  Uint8Array.prototype.slice = function (begin, end) {
    // IE < 9 gets unhappy with an undefined end argument
    end = typeof end !== 'undefined' ? end : this.length;

    // For native Array objects, we use the native slice function
    if (Object.prototype.toString.call(this) === '[object Array]') {
      return _slice.call(this, begin, end);
    }

    // For array like object we handle it ourselves.
    var i,cloned = [],
    size,len = this.length;

    // Handle negative value for "begin"
    var start = begin || 0;
    start = start >= 0 ? start : Math.max(0, len + start);

    // Handle negative value for "end"
    var upTo = typeof end == 'number' ? Math.min(end, len) : len;
    if (end < 0) {
      upTo = len + end;
    }

    // Actual expected size of the slice
    size = upTo - start;

    if (size > 0) {
      cloned = new Array(size);
      if (this.charAt) {
        for (i = 0; i < size; i++) {
          cloned[i] = this.charAt(start + i);
        }
      } else {
        for (i = 0; i < size; i++) {
          cloned[i] = this[start + i];
        }
      }
    }

    return cloned;
  };
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./src/wgs/scene/VertexBufferReader.js":
/*!*********************************************!*\
  !*** ./src/wgs/scene/VertexBufferReader.js ***!
  \*********************************************/
/*! exports provided: VertexBufferReader, BoundsCallback */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VertexBufferReader", function() { return VertexBufferReader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoundsCallback", function() { return BoundsCallback; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "three");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);





var TAU = Math.PI * 2;

//Constants duplicated from src/lmvtk/VertexBufferBuilder.js
var VBB_GT_TRIANGLE_INDEXED = 0,
VBB_GT_LINE_SEGMENT = 1,
VBB_GT_ARC_CIRCULAR = 2,
VBB_GT_ARC_ELLIPTICAL = 3,
VBB_GT_TEX_QUAD = 4,
VBB_GT_ONE_TRIANGLE = 5;

var VBB_INSTANCED_FLAG = 0, // this is intentionally 0 for the instancing case!
VBB_SEG_START_RIGHT = 0, // this starts intentionally at 0!
VBB_SEG_START_LEFT = 1,
VBB_SEG_END_RIGHT = 2,
VBB_SEG_END_LEFT = 3;

var VBB_COLOR_OFFSET = 6,
VBB_DBID_OFFSET = 7,
VBB_FLAGS_OFFSET = 8,
VBB_LAYER_VP_OFFSET = 9;

/**
                          * Initializes a "view" into a compacted interleaved vertex buffer array using our custom 2D vertex layout.
                          * See src/lmvtk/VertexBufferBuilder.js for more details.
                          */
function VertexBufferReader(geometry)
{
  this.vb = geometry.vb.buffer;
  this.vbf = new Float32Array(this.vb);
  this.vbi = new Int32Array(this.vb);
  this.vbs = new Uint16Array(this.vb);

  this.ib = geometry.ib;

  this.stride = geometry.vbstride;
  this.vcount = this.vbf.length / this.stride;

  this.useInstancing = geometry.numInstances > 0;
  this.useCompactBuffers = geometry.unpackXform;
  this.texData = this.useCompactBuffers && geometry.tIdColor && geometry.tIdColor.image && geometry.tIdColor.image.data && new Uint32Array(geometry.tIdColor.image.data.buffer);
};

VertexBufferReader.prototype.getDbIdAt = function (vindex) {
  if (this.texData) {
    return this.texData[this.vbs[vindex * this.stride * 2 + VBB_DBID_OFFSET]];
  }
  return this.vbi[vindex * this.stride + VBB_DBID_OFFSET];
};

VertexBufferReader.prototype.getColorAt = function (vindex) {
  if (this.texData) {
    return this.texData[this.vbs[vindex * this.stride * 2 + VBB_COLOR_OFFSET]];
  }
  return this.vbi[vindex * this.stride + VBB_COLOR_OFFSET];
};

VertexBufferReader.prototype.getVertexFlagsAt = function (vindex) {
  if (this.texData) {
    return this.vbi[vindex * this.stride + 4];
  }
  return this.vbi[vindex * this.stride + VBB_FLAGS_OFFSET];
};

VertexBufferReader.prototype.getLayerIndexAt = function (vindex) {
  if (this.texData) {
    return this.vbi[vindex * this.stride + 5] & 0xffff;
  }
  return this.vbi[vindex * this.stride + VBB_LAYER_VP_OFFSET] & 0xffff;
};

VertexBufferReader.prototype.getViewportIndexAt = function (vindex) {
  if (this.texData) {
    return this.vbi[vindex * this.stride + 5] >> 16 & 0xffff;
  }
  return this.vbi[vindex * this.stride + VBB_LAYER_VP_OFFSET] >> 16 & 0xffff;
};

VertexBufferReader.prototype.decodeLineAt = function (vindex, layer, vpId, callback)
{
  if (!callback.onLineSegment) {return;}

  if (this.useCompactBuffers) {
    var vertexOffset = this.stride * vindex * 2;
    var x0 = this.useCompactBuffers.x * this.vbs[vertexOffset] / 65535 + this.useCompactBuffers.z;
    var y0 = this.useCompactBuffers.y * this.vbs[vertexOffset + 1] / 65535 + this.useCompactBuffers.w;
    var angle = this.vbs[vertexOffset + 2] / 65535 * TAU - Math.PI;
    var distAlong = this.vbs[vertexOffset + 3] / 65535 * Math.max(this.useCompactBuffers.x, this.useCompactBuffers.y);
    var lineWidth = this.vbs[vertexOffset + 4] / 32767 * Math.max(this.useCompactBuffers.x, this.useCompactBuffers.y) * 2.0;
  } else {
    var baseOffset = this.stride * vindex;
    var x0 = this.vbf[baseOffset];
    var y0 = this.vbf[baseOffset + 1];
    var angle = this.vbf[baseOffset + 2] * TAU - Math.PI; // decode angle: see VertexBufferBuilder.addVertexLine
    var distAlong = this.vbf[baseOffset + 3];
    var lineWidth = this.vbf[baseOffset + 4] * 2.0;
  }

  var x1 = x0 + distAlong * Math.cos(angle);
  var y1 = y0 + distAlong * Math.sin(angle);

  callback.onLineSegment(x0, y0, x1, y1, vpId, lineWidth);
};

VertexBufferReader.prototype.decodeCircularArcAt = function (vindex, layer, vpId, callback)
{
  if (!callback.onCircularArc) {return;}

  if (this.useCompactBuffers) {
    var vertexOffset = this.stride * vindex * 2;
    var cx = this.useCompactBuffers.x * this.vbs[vertexOffset] / 65535 + this.useCompactBuffers.z;
    var cy = this.useCompactBuffers.y * this.vbs[vertexOffset + 1] / 65535 + this.useCompactBuffers.w;
    var start = this.vbs[vertexOffset + 2] / 65535 * TAU;
    var end = this.vbs[vertexOffset + 3] / 65535 * TAU;
    var radius = this.vbs[vertexOffset + 5] / 65535 * Math.max(this.useCompactBuffers.x, this.useCompactBuffers.y);
  } else {
    var baseOffset = this.stride * vindex;
    var cx = this.vbf[baseOffset];
    var cy = this.vbf[baseOffset + 1];
    var start = this.vbf[baseOffset + 2] * TAU;
    var end = this.vbf[baseOffset + 3] * TAU;
    var radius = this.vbf[baseOffset + 5];
  }

  callback.onCircularArc(cx, cy, start, end, radius, vpId);
};

VertexBufferReader.prototype.decodeEllipticalArcAt = function (vindex, layer, vpId, callback)
{
  if (!callback.onEllipticalArc) {return;}

  // Note: compaction will not happen for the VBB_GT_ARC_ELLIPTICAL
  var baseOffset = this.stride * vindex;
  var cx = this.vbf[baseOffset];
  var cy = this.vbf[baseOffset + 1];
  var start = this.vbf[baseOffset + 2] * TAU;
  var end = this.vbf[baseOffset + 3] * TAU;
  var major = this.vbf[baseOffset + 5];
  var minor = this.vbf[baseOffset + 10];
  var tilt = this.vbf[baseOffset + 11];

  callback.onEllipticalArc(cx, cy, start, end, major, minor, tilt, vpId);
};

VertexBufferReader.prototype.decodeTexQuadAt = function (vindex, layer, vpId, callback)
{
  if (!callback.onTexQuad) {return;}

  if (this.useCompactBuffers) {
    var vertexOffset = this.stride * vindex * 2;
    var centerX = this.useCompactBuffers.x * this.vbs[vertexOffset] / 65535 + this.useCompactBuffers.z;
    var centerY = this.useCompactBuffers.y * this.vbs[vertexOffset + 1] / 65535 + this.useCompactBuffers.w;
    var rotation = this.vbs[vertexOffset + 2] / 65535 * TAU;
    var width = this.vbs[vertexOffset + 3] / 65535 * Math.max(this.useCompactBuffers.x, this.useCompactBuffers.y);
    var height = this.vbs[vertexOffset + 4] / 65535 * Math.max(this.useCompactBuffers.x, this.useCompactBuffers.y);
  } else {
    var baseOffset = this.stride * vindex;
    var centerX = this.vbf[baseOffset];
    var centerY = this.vbf[baseOffset + 1];
    // yes, this is in a different order than output, following VertexBufferBuilder's order
    var rotation = this.vbf[baseOffset + 2] * TAU;
    var width = this.vbf[baseOffset + 3];
    var height = this.vbf[baseOffset + 4];
  }

  callback.onTexQuad(centerX, centerY, width, height, rotation, vpId);
};

VertexBufferReader.prototype.decodeOneTriangleAt = function (vindex, layer, vpId, callback)
{
  if (!callback.onOneTriangle) {return;}

  if (this.useCompactBuffers) {
    var vertexOffset = this.stride * vindex * 2;
    var x1 = this.useCompactBuffers.x * this.vbs[vertexOffset] / 65535 + this.useCompactBuffers.z;
    var y1 = this.useCompactBuffers.y * this.vbs[vertexOffset + 1] / 65535 + this.useCompactBuffers.w;
    var x2 = this.useCompactBuffers.x * this.vbs[vertexOffset + 2] / 65535 + this.useCompactBuffers.z;
    var y2 = this.useCompactBuffers.y * this.vbs[vertexOffset + 3] / 65535 + this.useCompactBuffers.w;
    var x3 = this.useCompactBuffers.x * this.vbs[vertexOffset + 4] / 65535 + this.useCompactBuffers.z;
    var y3 = this.useCompactBuffers.y * this.vbs[vertexOffset + 5] / 65535 + this.useCompactBuffers.w;
  } else {
    var baseOffset = this.stride * vindex;
    var x1 = this.vbf[baseOffset];
    var y1 = this.vbf[baseOffset + 1];
    var x2 = this.vbf[baseOffset + 2];
    var y2 = this.vbf[baseOffset + 3];
    var x3 = this.vbf[baseOffset + 4];
    var y3 = this.vbf[baseOffset + 5];
  }

  callback.onOneTriangle(x1, y1, x2, y2, x3, y3, vpId);
};


VertexBufferReader.prototype.decodeTriangleIndexed = function (vi0, vi1, vi2, layer, vpId, callback)
{
  if (!callback.onOneTriangle) {return;}

  if (this.useCompactBuffers) {
    var vertexOffset = this.stride * vi0 * 2;
    var x1 = this.useCompactBuffers.x * this.vbs[vertexOffset] / 65535 + this.useCompactBuffers.z;
    var y1 = this.useCompactBuffers.y * this.vbs[vertexOffset + 1] / 65535 + this.useCompactBuffers.w;

    vertexOffset = this.stride * vi1 * 2;
    var x2 = this.useCompactBuffers.x * this.vbs[vertexOffset] / 65535 + this.useCompactBuffers.z;
    var y2 = this.useCompactBuffers.y * this.vbs[vertexOffset + 1] / 65535 + this.useCompactBuffers.w;

    vertexOffset = this.stride * vi2 * 2;
    var x3 = this.useCompactBuffers.x * this.vbs[vertexOffset] / 65535 + this.useCompactBuffers.z;
    var y3 = this.useCompactBuffers.y * this.vbs[vertexOffset + 1] / 65535 + this.useCompactBuffers.w;
  } else {
    var baseOffset = this.stride * vi0;
    var x1 = this.vbf[baseOffset];
    var y1 = this.vbf[baseOffset + 1];

    baseOffset = this.stride * vi1;
    var x2 = this.vbf[baseOffset];
    var y2 = this.vbf[baseOffset + 1];

    baseOffset = this.stride * vi2;
    var x3 = this.vbf[baseOffset];
    var y3 = this.vbf[baseOffset + 1];
  }

  callback.onOneTriangle(x1, y1, x2, y2, x3, y3, vpId);
};


// used by the snapper and by the bounds finder
VertexBufferReader.prototype.enumGeomsForObject = function (dbId, callback)
{
  if (this.useInstancing) {

    //When instancing is used, each geometry primitive is encoded into a single vertex
    //and there is no index buffer.

    var i = 0;
    while (i < this.vcount) {
      var flag = this.getVertexFlagsAt(i);

      //var vertexId  = (flag >>  0) & 0xff;        //  8 bit
      var geomType = flag >> 8 & 0xff; //  8 bit
      //var linePattern = (flag >> 16) & 0xff;      //  8 bit
      var layerId = this.getLayerIndexAt(i); // 16 bit
      var vpId = this.getViewportIndexAt(i); // 16 bit     
      var visible = this.getDbIdAt(i) === dbId;
      if (visible) {
        switch (geomType) {
          case VBB_GT_LINE_SEGMENT:this.decodeLineAt(i, layerId, vpId, callback);break;
          case VBB_GT_ARC_CIRCULAR:this.decodeCircularArcAt(i, layerId, vpId, callback);break;
          case VBB_GT_ARC_ELLIPTICAL:this.decodeEllipticalArcAt(i, layerId, vpId, callback);break; //  compaction is not performed
          case VBB_GT_TEX_QUAD:this.decodeTexQuadAt(i, layerId, vpId, callback);break;
          case VBB_GT_ONE_TRIANGLE:this.decodeOneTriangleAt(i, layerId, vpId, callback);break;
          default:break;}

      }

      //In the case of instancing, there is no vertex duplication and no index buffer, we just
      //move to the next vertex
      i += 1;
    }
  } else {

    var i = 0;
    while (i < this.ib.length) {
      var vi = this.ib[i];
      var flag = this.getVertexFlagsAt(vi);

      //var vertexId    = (flag >>  0) & 0xff;        //  8 bit
      var geomType = flag >> 8 & 0xff; //  8 bit
      //var linePattern = (flag >> 16) & 0xff;        //  8 bit
      var layerId = this.getLayerIndexAt(vi); // 16 bit
      var vpId = this.getViewportIndexAt(vi); // 16 bit

      var visible = this.getDbIdAt(vi) === dbId;

      if (geomType === VBB_GT_TRIANGLE_INDEXED) {

        //Triangles are encoded in three vertices (like a simple mesh) instead of 4 like everything else

        if (visible) {
          this.decodeTriangleIndexed(this.ib[i], this.ib[i + 1], this.ib[i + 2], layerId, vpId, callback);
        }

        //Advance to the next primitive
        i += 3;

      } else {

        if (visible) {
          switch (geomType) {
            case VBB_GT_LINE_SEGMENT:this.decodeLineAt(vi, layerId, vpId, callback);break;
            case VBB_GT_ARC_CIRCULAR:this.decodeCircularArcAt(vi, layerId, vpId, callback);break;
            case VBB_GT_ARC_ELLIPTICAL:this.decodeEllipticalArcAt(vi, layerId, vpId, callback);break;
            case VBB_GT_TEX_QUAD:this.decodeTexQuadAt(vi, layerId, vpId, callback);break;
            case VBB_GT_ONE_TRIANGLE:this.decodeOneTriangleAt(vi, layerId, vpId, callback);break;
            default:break;}

        }

        //Skip duplicate vertices (when not using instancing and the geometry is not a simple polytriangle,
        //each vertex is listed four times with a different vertexId flag
        i += 6;
      }


    }
  }

};


/**
    * Used by the bounds finder.
    * @param {array[number]} layerIdsVisible - list of layer ids that are visible
    * @param {function} callback
    * @private
    */
VertexBufferReader.prototype.enumGeomsForVisibleLayer = function (layerIdsVisible, callback)
{
  var filter = function filter(dbId, layerId, viewportId) {
    return !layerIdsVisible || layerId !== 0 && layerIdsVisible.indexOf(layerId) !== -1;
  };
  this.enumGeoms(filter, callback);
};


/**
    * Enumerate all geometric primitives that match the given filter.
    * @param {function} [filter] - function(dbId, layerId, viewportId): Filter function to define a subset of primitives to include. By default, all geometry is included.
    * @param {function} callback
    * @private
    */
VertexBufferReader.prototype.enumGeoms = function (filter, callback)
{
  if (this.useInstancing) {

    //When instancing is used, each geometry primitive is encoded into a single vertex
    //and there is no index buffer.

    var i = 0;
    while (i < this.vcount) {
      var flag = this.getVertexFlagsAt(i);

      //var vertexId    = (flag >>  0) & 0xff;        //  8 bit
      var geomType = flag >> 8 & 0xff; //  8 bit
      //var linePattern = (flag >> 16) & 0xff;        //  8 bit
      var layerId = this.getLayerIndexAt(i); // 16 bit
      var vpId = this.getViewportIndexAt(i); // 16 bit
      var dbId = this.getDbIdAt(i);

      // Get the bounds of only the visible layers. Ignore layer 0, which is always the page.
      // If layerId visibility is not set, consider the layer visible.
      var visible = !filter || filter(dbId, layerId, vpId);
      if (visible) {
        switch (geomType) {
          case VBB_GT_LINE_SEGMENT:this.decodeLineAt(i, layerId, vpId, callback);break;
          case VBB_GT_ARC_CIRCULAR:this.decodeCircularArcAt(i, layerId, vpId, callback);break;
          case VBB_GT_ARC_ELLIPTICAL:this.decodeEllipticalArcAt(i, layerId, vpId, callback);break;
          case VBB_GT_TEX_QUAD:this.decodeTexQuadAt(i, layerId, vpId, callback);break;
          case VBB_GT_ONE_TRIANGLE:this.decodeOneTriangleAt(i, layerId, vpId, callback);break;
          default:break;}

      }

      //In the case of instancing, there is no vertex duplication and no index buffer, we just
      //move to the next vertex
      i += 1;
    }
  } else {

    var i = 0;
    while (i < this.ib.length) {
      var vi = this.ib[i];
      var flag = this.getVertexFlagsAt(vi);

      //var vertexId    = (flag >>  0) & 0xff;        //  8 bit
      var geomType = flag >> 8 & 0xff; //  8 bit
      //var linePattern = (flag >> 16) & 0xff;        //  8 bit
      var layerId = this.getLayerIndexAt(vi); // 16 bit
      var vpId = this.getViewportIndexAt(vi); // 16 bit
      var dbId = this.getDbIdAt(vi);

      // Get the bounds of only the visible layers. Ignore layer 0, which is always the page.
      // If layerId visibility is not set, consider the layer visible.
      var visible = !filter || filter(dbId, layerId, vpId);

      if (geomType === VBB_GT_TRIANGLE_INDEXED) {

        //Triangles are encoded in three vertices (like a simple mesh) instead of 4 like everything else

        if (visible) {
          this.decodeTriangleIndexed(this.ib[i], this.ib[i + 1], this.ib[i + 2], layerId, vpId, callback);
        }

        //Advance to the next primitive
        i += 3;

      } else {

        if (visible) {
          switch (geomType) {
            case VBB_GT_LINE_SEGMENT:this.decodeLineAt(vi, layerId, vpId, callback);break;
            case VBB_GT_ARC_CIRCULAR:this.decodeCircularArcAt(vi, layerId, vpId, callback);break;
            case VBB_GT_ARC_ELLIPTICAL:this.decodeEllipticalArcAt(vi, layerId, vpId, callback);break;
            case VBB_GT_TEX_QUAD:this.decodeTexQuadAt(vi, layerId, vpId, callback);break;
            case VBB_GT_ONE_TRIANGLE:this.decodeOneTriangleAt(vi, layerId, vpId, callback);break;
            default:break;}

        }

        //Skip duplicate vertices (when not using instancing and the geometry is not a simple polytriangle,
        //each vertex is listed four times with a different vertexId flag
        i += 6;
      }

    }
  }

};



/**
    * Callback class for calculating bounds of 2D objects via VertexBufferReader
    * @private
    */
function BoundsCallback(bounds) {
  this.bounds = bounds;
  // workspace, so we don't reallocate this each time
  this.point = new three__WEBPACK_IMPORTED_MODULE_0__["Vector4"]();
  this.point.z = 0.0;
  this.point.w = 1.0; // it's a point, not a vector
}

BoundsCallback.prototype.onVertex = function (cx, cy, vpId) {
  this.point.x = cx;
  this.point.y = cy;
  this.bounds.expandByPoint(this.point);
};

BoundsCallback.prototype.onLineSegment = function (x1, y1, x2, y2, vpId) {
  this.onVertex(x1, y1);
  this.onVertex(x2, y2);
};

BoundsCallback.prototype.onCircularArc = function (cx, cy, start, end, radius, vpId) {
  this.onEllipticalArc(cx, cy, start, end, radius, radius, 0.0, vpId);
};

BoundsCallback.prototype.onEllipticalArc = function (cx, cy, start, end, major, minor, tilt, vpId) {
  if (tilt == 0.0) {
    // does start and end make a full ellipse?
    if (start <= 0 && end >= 2.0 * Math.PI - 0.00001) {
      // full way around, simply treat it like a rectangle
      this.onTexQuad(cx, cy, 2 * major, 2 * minor, tilt, vpId);
    } else {
      // Not a full ellipse. We take the start and end points and also figure
      // out the four "compass rose" points that are between these two locations.
      // The start and end locations often exist as separate vertices so would
      // already be included, but for some line types they may not exist, so we
      // include them here.
      this.point.x = cx + Math.cos(start) * major;
      this.point.y = cy + Math.sin(start) * minor;
      this.bounds.expandByPoint(this.point);
      this.point.x = cx + Math.cos(end) * major;
      this.point.y = cy + Math.sin(end) * minor;
      this.bounds.expandByPoint(this.point);

      // now check each NESW compass point, i.e., middle of each edge
      if (start > end) {
        // add right edge
        this.point.x = cx + major;
        this.point.y = cy;
        this.bounds.expandByPoint(this.point);
        // make start < end for the rest of the tests
        start -= 2.0 * Math.PI;
      }
      if (start < 0.5 * Math.PI && end > 0.5 * Math.PI) {
        // add top edge
        this.point.x = cx;
        this.point.y = cy + minor;
        this.bounds.expandByPoint(this.point);
      }
      if (start < Math.PI && end > Math.PI) {
        // add left edge
        this.point.x = cx - major;
        this.point.y = cy;
        this.bounds.expandByPoint(this.point);
      }
      if (start < 1.5 * Math.PI && end > 1.5 * Math.PI) {
        // add bottom edge
        this.point.x = cx;
        this.point.y = cy - minor;
        this.bounds.expandByPoint(this.point);
      }
    }
  } else {
    // Has a tilt.
    // From what we see, you should never reach here, as tilted ellipses are actually
    // always tessellated. So, we do a fallback: call the onTexQuad with the rotation.
    // This call will be a pretty good approximation, putting a rotated bounding box
    // around the whole ellipse. For more accuracy you would need to tessellate the
    // ellipse and get its points (especially if you don't have a full ellipse).
    this.onTexQuad(cx, cy, 2 * major, 2 * minor, tilt, vpId);

    // does start and end make a full ellipse?
    //if ( (start <= 0) && (end >= 2.0 * Math.PI - 0.00001) ) {
    //}
  }
};

// Currently this case does not actually come up, as textured quads, i.e., images, are
// not something that can be selected, from what data I have tried. So I have not spent
// any time on the rotated case.
// TODO: this code is only partially tested: I had problems getting a selectable raster
// object in a DWG convert to an F2D.
BoundsCallback.prototype.onTexQuad = function (centerX, centerY, width, height, rotation, vpId) {
  var halfWidth = 0.5 * width;
  var halfHeight = 0.5 * width;
  if (rotation == 0.0) {
    this.onVertex(centerX - halfWidth, centerY - halfHeight);
    this.onVertex(centerX + halfWidth, centerY + halfHeight);
  } else {
    // A more complex rectangle, rotated. Take the four corners and rotate each
    // around the center.
    var rmtx = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"](); // Matrix3() does not have enough helper methods
    var mtx = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
    // Take a rectangle centered at the origin, rotate it, translate it to the final
    // position. Each corner is added to the bounds.
    rmtx.makeRotationZ(rotation);
    // put it into the final position:
    mtx.makeTranslation(centerX, centerY, 0.0);
    mtx.multiply(rmtx);

    for (var i = 0; i < 4; i++) {
      this.point.x = i % 2 == 1 ? halfWidth : -halfWidth;
      this.point.y = i >= 2 ? halfHeight : -halfHeight;
      this.point.applyMatrix4(mtx);
      this.bounds.expandByPoint(this.point);
    }
  }
};

BoundsCallback.prototype.onOneTriangle = function (x1, y1, x2, y2, x3, y3, vpId) {
  this.onVertex(x1, y1);
  this.onVertex(x2, y2);
  this.onVertex(x3, y3);
};

/***/ }),

/***/ "three":
/*!************************!*\
  !*** external "THREE" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = THREE;

/***/ })

/******/ });
//# sourceMappingURL=Snapping.js.map